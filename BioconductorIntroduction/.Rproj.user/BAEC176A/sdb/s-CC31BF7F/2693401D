{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Analysis of ATAC-seq data in R and Bioconductor\"\ndate: \"`r Sys.Date()`\"\nauthor: \"Thomas Carroll\"\noutput:\n  rmdformats::html_clean:\n    highlight: pygments\n---\n\n\n```{r knitr_init, echo=FALSE, cache=FALSE}\nlibrary(knitr)\nlibrary(rmdformats)\n\n## Global options\noptions(max.print=\"75\")\nopts_chunk$set(echo=FALSE,\n\t             cache=TRUE,\n               prompt=FALSE,\n               tidy=TRUE,\n               comment=NA,\n               message=FALSE,\n               warning=FALSE)\nopts_knit$set(width=75)\n```\n\n\n## ATAC-seq, MNase-seq and DNase-seq\n\n\n![ATAC,MNase,DNase - https://www.the-scientist.com/?articles.view/articleNo/44772/title/Reveling-in-the-Revealed/](https://www.the-scientist.com/January2016/LT2_2.jpg)\n\n* DNase-seq - Enzymatic digestion to extract signal from open chromatin around transcription factor binding sites.\n\n* MNase-seq - Enzymatic digestion to extract signal repesenting nucleosome positioning.\n\n* ATAC-seq - Uses transposases and offers a method to simultaneously extract signal from transcription factors binding sites and nucleosome positions from a single sample.\n\n\n# Working with ATAC-seq data in R/Bioconductor\n\n\n## Introduction\n\nIn this workshop we will look at some of the basics of ATAC-seq analysis in R using publically available data.\n\nWe will look at the alignment, post-alignment processing, plotting of ATAC-seq data over TSSs and motif occurrences, peak calling for nucleosome free regions and differential ATAC-seq signal.\n\n### Covering today.\n\n* Aligning ATAC-seq data.\n\n* Plotting fragment lengths from ATAC-seq\n\n* Creation of nucleosome free signal tracks.\n\n* Peak calling for nucleosome free regions.\n\n* Annotation and functional enrichment analysis of ATAC-seq.\n\n* Differential nucleosome free regions from ATAC-seq data.\n\n### The Sequencing Data.\n\nIn this workshop we will make use of three sets of published data.\n\nThe first dataset is from original ATAC-seq paper.\n\nTransposition of native chromatin for multimodal regulatory analysis and personal epigenomics\nJason D. Buenrostro, Paul G. Giresi, Lisa C. Zaba, Howard Y. Chang, and William J. Greenleaf\n\nIn particular, we will make use of the ATACseq_50k_Rep2 sample GEO - GSM1155958 \nData can be retrieved in fastq format from ENA  \n\n* SAMN02192806 - [here](https://www.ebi.ac.uk/ena/data/view/SAMN02192806)\n\n\nFor the second dataset we take ATAC-seq generated by Bing Ren at UCSD as part of the Encode consortium. \nLinks to data and sample information are included in list below.\n\n* Liver day 12 - [ENCSR302LIV](https://www.encodeproject.org/experiments/ENCSR302LIV/)\n\n* Kidney day 15 - [ENCSR023QZX](https://www.encodeproject.org/experiments/ENCSR023QZX/)\n\n* Hindbrain day 12 - [ENCSR088UYE](https://www.encodeproject.org/experiments/ENCSR088UYE/)\n\n\nFinally I have processed some of the data from Christina Leslie' lab at MSKCC exactly as described in this workshop so we can review some of the characteristics of ATAC-seq data alongside the same data processed by Encode's pipeline.\n\nThe raw data and processed BAM file is available from Encodes portal\n\n* T-Reg - [ENCSR724UJS](https://www.encodeproject.org/experiments/ENCSR724UJS/)\n\n\n### The Reference Data\n\nFor ATAC-seq analysis we will require a few pieces of reference data. \n\nThis includes-\n\n* Reference genome in fasta format - [IGenomes](https://support.illumina.com/sequencing/sequencing_software/igenome.html) provides reference genomes for major organims. If you want the exact reference i use here you can [download from here](https://s3.amazonaws.com/rubioinformatics/hg19_Genome.fa)\n\n* Gene models - We will retrieve these from TxDb Bioconductor annotation packages.\n\n* Blacklists - Artefact regions specific to genomes. These can be found in [Encode portal here](https://www.encodeproject.org/annotations/ENCSR636HFF/)\n\n### The Tools.\n\n\nIn this workshop we will concentrate on using R and Bioconductor to process your data.\n\nBioconductor has many packages to handle sequencing data including BAM files, BED files, bigWigs and Fasta files. Some of these tools may require large memory or care to process data in chunks. \nWe process full size ATAC-seq data routinely in R but for some examples in this practical we will use just one chromosome to save time.\n\n### Required R packages and versions.\n\nWe will need the latest version of R v(>=3.4) and Bioconductor (v3.6) with the following packages.\n\n```{r packages, echo=TRUE,eval=FALSE,cache=FALSE}\n\n# install.packages(knitr)\n\n# install.packages(rmdformats)\n\n# install.packages(dplyr)\n\n# install.packages(DT)\n\n# install.packages(tidyr)\n\n# install.packages(ggplot2)\n\n# install.packages(magrittr)\n\n# install.packages(devtools)\n\n# \n# source(\"https://bioconductor.org/biocLite.R\")\n# \n\n# ## Needed for mac and Linux only\n# biocLite(Rsubread)\n# ##\n# \n\n# biocLite(Rsamtools)\n\n# biocLite(GenomicAlignments)\n\n# biocLite(TxDb.Hsapiens.UCSC.hg19.knownGene)\n\n# biocLite(soGGi)\n\n# biocLite(rtracklayer)\n\n# biocLite(ChIPQC)\n\n# biocLite(ChIPseeker)\n\n# biocLite(rGREAT)\n\n# biocLite(limma)\n\n# biocLite(DESeq2)\n\n# biocLite(TxDb.Mmusculus.UCSC.mm10.knownGene)\n\n# biocLite(tracktables)\n\n# biocLite(clusterProfiler)\n\n# biocLite(org.Mm.eg.db)\n\n# biocLite(MotifDb)\n\n# biocLite(Biostrings)\n\n# biocLite(BSgenome.Hsapiens.UCSC.hg19)\n# \n\n# # Finally we need development version of soGGi (named here 1.10.4) \n# # not version on Bioconductor (1.10.0)\n# devtools::install_github(\"ThomasCarroll/soGGi\")\n\n```\n\n\n### IGV genome browser\n\nWe will also make use of IGV genome browser to review some results.\n\nIGV is available from Broad [here](https://software.broadinstitute.org/software/igv/download).\n\n### Processed Data in workshop \n\nWe start with public sequencing data in links below and use reference data in Bioconductor and/or IGenomes.\n\nWe do not run to all the steps together today so i include processed data from various points in analysis at links below\n\n**Essentials**\n\nBAM file and BAI index from our alignment/sorting/indexing.\n\n* [SAMN02192806 - Greenleaf BAM](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam) - Full BAM file for Greenleaf example produced following in our Rsubread alignment, sorting and indexing.  \n\n* [SAMN02192806 - Greenleaf BAI index](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam.bai) - BAI index file for BAM in Greenleaf example produced following in our alignment, sorting and indexing. \n\nSmall BAM, peak calls and directory structure.\n\n* [ATAC_Workshop_Essential.zip](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop_Essential.zip) - Require additional workshop files and directory structure.\n\nOnce you have downloaded the above and unzipped **ATAC_Workshop.zip**, you should move the **Sorted_ATAC_50K_2.bam** and **Sorted_ATAC_50K_2.bam.bai** file into **ATAC_Workshop/ATAC_Data/ATAC_BAM/**\n\nYou should also copy the **RU_ATAC_Workshop.Rmd** to **ATAC_Workshop/** directory and open then to make sure all relative paths are correct. \n\n**Not essential**\n\nSame as above but with BAMs for counting as well as small BAM, peak calls and directory structure.\n\n* [ATAC_Workshop.zip](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop.zip)  - Additional workshop files and directory structure.\n\nBigwigs for IGV.\n\n* [Bigwigs](https://s3.amazonaws.com/rubioinformatics/ATAC_bigWigs.zip) - BigWigs to review in IGV. \n\n\n## Greenleaf dataset fastq to BAM processing.\n\nIn this section we will work alittle with the Greenleaf dataset. \nWe will process one sample of the Greenleaf data from fastq to BAM to allow us to review some of the features of ATAC-seq data and to create some processed files for review and further analysis.\n\n\n### Creating a reference genome\n\nThe IGenomes repositories allow us to retrieve a consistent set of reference annotation for our genome of choice.\n\nHere i have renamed the Fasta to something more meaningful in isolation -- **hg19_Genome.fa**.\n\nWe will use the Rsubread package to align our ATAC-seq data so first we must build an appropriate index from our Fasta for the Rsubread aligner.\n\n**This takes awhile so run this after workshop if interested**\n\n**Takes ~ 30 minutes on 3.1 GHz Intel Core i7 Mac pro**\n```{r processData_BuildIndex, echo=TRUE,eval=FALSE,cache=FALSE}\nlibrary(Rsubread)\n\ngenome <- \"ATAC_Data/ATAC_Reference/hg19_Genome.fa\"\nindexForSubread <- gsub(\"\\\\.fa$\",\"\",genome)\n\nbuildindex(indexForSubread,genome,indexSplit=FALSE)\n\n```\n\n### Aligning Sequence Reads to the Genome.\n\nNow we have a reference genome, we can align our paired-end ATAC-seq reads using Rsubread.\n\nHere we can use a standard alignment for DNA but we increase the maximum allowed fragment length to capture long fragments representing poly-nucleosome signal. \n\nThe maximum allowed fragment length set here is based on parameters used within Greenleaf study.\n\n**This takes awhile so run this after workshop if interested**\n\n**Takes ~ 50 minutes on 3.1 GHz Intel Core i7 Mac pro**\n\n```{r processData_align, echo=TRUE,eval=FALSE,cache=FALSE}\nread1 <- \"ATAC_Data/ATAC_FQs/SRR891269_1.fastq.gz\"\nread2 <- \"ATAC_Data/ATAC_FQs/SRR891269_2.fastq.gz\"\noutBAM <- \"ATAC_50K_2.bam\"\n\nalign(indexForSubread,\n      readfile1=read1,readfile2=read2,\n      output_file = outBAM,\n      nthreads=2,type=1,\n      unique=TRUE,maxFragLength = 2000)\n\n```\n\n### Sorting and Indexing\n\nFollowing alignment we would want to sort and index our BAM file for use with external tool.\n\nFirst we sort our aligned data by sequence order (not Read Name here).\n\nWe then index our file allowing for rapid access of particular genomic locations by other programs (e.g IGV, Samtools) and by R/Bioconductor packaes we will use.\n\n**This takes awhile so run this after workshop if interested**\n\n**Takes ~ 15 minutes on 3.1 GHz Intel Core i7 Mac pro**\n\n```{r processData_indexAndSort, echo=TRUE,eval=FALSE,cache=FALSE}\nlibrary(Rsamtools)\nsortedBAM <- file.path(dirname(outBAM),\n                       paste0(\"Sorted_\",basename(outBAM))\n                       )\n\nsortBam(outBAM,gsub(\"\\\\.bam\",\"\",basename(sortedBAM)))\nindexBam(sortedBAM)\n```\n\n**So around ~ 1hr 30 minutes in total to get to here.**\n\n```{r processData_setBAM, echo=TRUE,eval=TRUE,cache=TRUE,include=TRUE}\nsortedBAM <- \"ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam\"\n```\n\n\n### Number of mapped reads\n\nWe can now check the mapping rate to make sure we do not have any problems with the aligmnent.\nHere we use Rsubread's propmapped to give us number of mapped, unmapped and mapping percentage\n\n**This takes awhile so run this after workshop if interested**\n\n**Takes ~ 15 minutes on 3.1 GHz Intel Core i7 Mac pro**\n```{r mappingStats, echo=TRUE,eval=FALSE,cache=TRUE,dependson=\"processData_setBAM\"}\nlibrary(Rsubread)\npmapped <- propmapped(sortedBAM)\npmapped\n```\n\n```{r mappingStatsResultsFromPropMapped, echo=FALSE,eval=TRUE,cache=TRUE,dependson=\"processData_setBAM\"}\ndfS <- data.frame(Sample=\"ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam\",NumTotal=56598621,NumMapped=55521254,PropMapped=0.980965)\ndfS\n```\n### Distribution of mapped reads\n\nWe can see we have a great mapping rate but we would also want to check the distribution of mapped reads across chromosomes.\n\nATAC-seq is known have high signal on the mitochondrial chromosomes and so we can check for that here.\n\nIn this example, we see an extreme case where the mapping rate to mitochondrial genome is extremely high.\n\n```{r quickMappingStatsPerChromosome, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_setBAM\"}\nlibrary(Rsamtools)\nlibrary(ggplot2)\nlibrary(magrittr)\n\nidxstatsBam(sortedBAM) %>%\n  ggplot(aes(seqnames,mapped,fill=seqnames))+geom_bar(stat=\"identity\")+coord_flip()\n```\n\nLets see if it is always that bad. \n\nSo we take some data from Bing Ren's lab (processed from fastq) and from our neighbour's at MSKCC and see how it looks there. \n\nWe will also take some ChIP-seq to identify a potential similar trend there.\n\n![Distribution of reads](ATAC_Data/images/example_MappingDistPlot.png)\n\n## Greenleaf dataset post-alignment processing.\n\nNow we have the processed the ATAC-seq paired-end data we can start to work with alignments.\n\nWe will identify the expected fragment length distribution and split our data into that representing nucleosome free and mono-nucleosomes.\n\n### Reading in mapped reads\n\nWe will read our newly aligned data using the GenomicAlignments package. \n\nHere we only read properly paired, uniquely mapped reads mapping to Chromosome 20. We also retrieve the read name, mapq scores and importantly the insert sizes. \n\n```{r processData_readingInData, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_setBAM\"}\nlibrary(GenomicAlignments)\natacReads <- readGAlignmentPairs(\"/rugpfs/fs0/ruit/scratch/tcarroll/Let2018_AtaC/BAMs/Sorted_Sample1.bam\",\n                                 param=ScanBamParam(mapqFilter=1, \n                                                    flag=scanBamFlag(isPaired = TRUE, \n                                                                     isProperPair =TRUE), \n                                                    what=c(\"qname\",\"mapq\",\"isize\"), which=GRanges(\"chr20\", IRanges(1,63025520))))\n\n# atacReads <- readGAlignmentPairs(\"/rugpfs/fs0/ruit/scratch/tcarroll/Let2018/BAMS/\",\n#                                  param=ScanBamParam(mapqFilter=1, \n#                                                     flag=scanBamFlag(isPaired = TRUE, \n#                                                                      isProperPair =TRUE), \n#                                                     what=c(\"qname\",\"mapq\",\"isize\"), which=GRanges(\"chr20\", IRanges(1,63025520))))\n#length(atacReads)\natacReads\n\n```\n\n\n### Retrieving insert sizes\n\nNow we have read in the paired aligned data into R, we can retreive the insert sizes from the elementMetadata attached to reads.\n\nSince properly paired reads will have same insert size length we extract insert sizes from read1.\n\n```{r processData_extractingRead1, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_readingInData\"}\n\natacReads_read1 <- GenomicAlignments::first(atacReads)\ninsertSizes <- abs(elementMetadata(atacReads_read1)$isize)\nhead(insertSizes)\n```\n\n### Plotting insert sizes\n\nATAC-seq should represent a mix of fragment lengths corresponding to nucleosome free, mononucleosome and poly-nucleosome fractions.\n\nWe can use the newly acquired insert lengths for chromosome 20 to plot the distribution of all fragment lengths.\n\n\n```{r processData_plottingFragmentLengths, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_extractingRead1\"}\nlibrary(magrittr)\nlibrary(dplyr)\nlibrary(ggplot2)\nfragLenPlot <- table(insertSizes) %>%\n  data.frame %>% \n  rename(InsertSize=insertSizes,Count=Freq) %>% \n  mutate(InsertSize=as.numeric(as.vector(InsertSize)),Count=as.numeric(as.vector(Count))) %>% \n  ggplot(aes(x=InsertSize,y=Count))+geom_line()\n\nq1 <- fragLenPlot+theme_bw()\nq2 <- fragLenPlot + scale_y_continuous(trans='log2')+theme_bw()\nggsave(q1,filename = \"q1_original.png\")\nggsave(q2,filename = \"q2_original.png\")\n\n```\n\n### Plotting insert sizes with Greenleaf open, mono- and di-nucleosome profiles\n\nThis looks very similar to the image from the Greenleaf paper.\n\nWe can now annotate our nucleosome free (< 100bp), mono-nucleosome (180bp-247bp) and di-nucleosome (315-437) as in the Greenleaf study.\n\n```{r processData_plottingFragmentLengths2, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_plottingFragmentLengths\"}\nfragLenPlot+geom_vline(xintercept = c(180,247),colour=\"red\")+geom_vline(xintercept = c(315,437),colour=\"darkblue\")+geom_vline(xintercept = c(100),colour=\"darkgreen\")+theme_bw()\n\nfragLenPlot+ scale_y_continuous(trans='log2')+geom_vline(xintercept = c(180,247),colour=\"red\")+geom_vline(xintercept = c(315,437),colour=\"darkblue\")+geom_vline(xintercept = c(100),colour=\"darkgreen\")+theme_bw()\n\n```\n\n\nAgain we can make a quick comparison with some other datasets.\n\n![Fragment length distributions](ATAC_Data/images/Example_FLdist.png)\n\n![Fragment length distributions](ATAC_Data/images/FL_dist_lohScale.png)\n\n### Plotting ATAC-seq signal of TSSs (Retrieving TSSs regions)\n\nFrom the fragment length plots shown above it would seem we have evidence of data coming both from nucleosome occupied and nucleosome free regions.\n\nWe expect nucleosome free regions to be present at TSSs of active genes and nucleosome signal to be be more enriched in regions surrounding the TSS\n\nTo investigate this we will produce a meta-TSS plot of average signal of the different fragment length signals across TSSs.\n\nFirst then we need a set of TSS positions which we can retrieve from the gene models in the **TxDb.Hsapiens.UCSC.hg19.knownGene** package.\n\n\n```{r processData_plottingFragmentLengthsAcrossTSS, echo=TRUE,eval=TRUE,cache=TRUE}\nlibrary(TxDb.Hsapiens.UCSC.hg19.knownGene)\nTSSs <- resize(genes(TxDb.Hsapiens.UCSC.hg19.knownGene),fix=\"start\",1)\nTSSs\n```\n\n### Plotting ATAC-seq signal of TSSs (Creating open, mono- and di-nucleosome signal profiles)\n\nNow we have all the TSS positions across the genome we can use the soGGi package to make plots of average signal across TSSs for different fragment length ranges.\n\n**This takes awhile so run this after workshop if interested**\n\n**Takes ~ 20 minutes on 3.1 GHz Intel Core i7 Mac pro**\n\n```{r processData_retrievingTSSData, echo=TRUE,eval=FALSE,cache=TRUE}\nlibrary(soGGi)\n\n# Nucleosome free\nnucFree <- regionPlot(bamFile = sortedBAM,\n                        testRanges = TSSs,\n                        style = \"point\",\n                        format=\"bam\",\n                        paired=TRUE,\n                        minFragmentLength = 0,maxFragmentLength = 100,forceFragment = 50)\n\n# Mononucleosome\nmonoNuc <- regionPlot(bamFile = sortedBAM,\n                        testRanges = TSSs,\n                        style = \"point\",\n                        format=\"bam\",\n                        paired=TRUE,\n                        minFragmentLength = 180,maxFragmentLength = 240,forceFragment = 80)\n\n# Dinucleosome\ndiNuc <- regionPlot(bamFile = sortedBAM,\n                        testRanges = TSSs,\n                        style = \"point\",\n                        format=\"bam\",\n                        paired=TRUE,\n                        minFragmentLength = 315,maxFragmentLength = 437,forceFragment = 160)\n\n# nucFree_gL <- nucFree\n# monoNuc_gL <- monoNuc\n# diNuc_gL <- diNuc\n# \n# save(monoNuc_gL,nucFree_gL,diNuc_gL,file=\"ATAC_Data/ATAC_RData/gL_soGGiResults.RData\")\n\n```\n\n### Plotting ATAC-seq signal of TSSs (Plotting open, mono- and di-nucleosome signal profiles)\n\nFrom the meta-TSS plots of different fragment lengths we can see the expected distribution of signal.\n\nNucleosome free fragments having a peak around the the TSS and nucleosome occupied signal peaking around the TSS with a strong peak at the +1 nucleosome.\n\n```{r processData_plotTSSData, echo=TRUE,eval=TRUE,cache=TRUE}\nlibrary(soGGi)\nload(file=\"ATAC_Data/ATAC_RData/gL_soGGiResults.RData\")\nplotRegion(nucFree_gL,outliers=0.01)\nplotRegion(monoNuc_gL,outliers=0.01)\nplotRegion(diNuc_gL,outliers=0.01)\n```\n\n\nAgain we can look at some of other datasets for mono-nucleosomes to get and idea what we may see.\n\n![Mononnucleosome plots](ATAC_Data/images/Mono_nuc_ExternalData.png)\n\n### Subsetting ATAC-seq reads files by insert sizes.\n\nWe may wish to divide our aligned reads into reads representing nucleosome free and nucleosome occupied. \n\nHere we create BAM files for the reads representing nucleosome free, mono and di nucleosome by using insert sizes to filtering read.\n\n```{r processData_createOpenRegionBAM, echo=TRUE,eval=TRUE,cache=TRUE,dependson=c(\"processData_extractingRead1\",\"processData_readingInData\")}\natacReads_Open <- atacReads[insertSizes < 100,]\natacReads_MonoNuc <- atacReads[insertSizes > 180 & insertSizes < 240,]\natacReads_diNuc <- atacReads[insertSizes > 315 & insertSizes < 437,]\n```\n\n### Creating BAM files split by insert sizes.\n\nThe resulting reads can be written back to BAM files for use in other parts of our analysis or for visualisation in programs such as IGV by functions in the rtracklayer package.\n\n\n```{r processData_createOpenRegionBAM_2, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_createOpenRegionBAM\"}\nopenRegionBam <- gsub(\"\\\\.bam\",\"_openRegions\\\\.bam\",sortedBAM)\nmonoNucBam <- gsub(\"\\\\.bam\",\"_monoNuc\\\\.bam\",sortedBAM)\ndiNucBam <- gsub(\"\\\\.bam\",\"_diNuc\\\\.bam\",sortedBAM)\n\nlibrary(rtracklayer)\nexport(atacReads_Open,openRegionBam,format = \"bam\")\nexport(atacReads_MonoNuc,monoNucBam,format = \"bam\")\n#export(atacReads_Open,diNucBam,format = \"bam\")\n```\n\n### Creating an open region bigWig.\n\nWe can make it significantly quicker to review the pile-up of ATAC-seq signal in a genome browser by creating a bigWig file.\n\nAdditional normalisation to total mapped reads and duplicate removal could be applied at this point.\n\n```{r processData_createOpenRegionBigWig_2, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_createOpenRegionBAM\"}\nopenRegionBigWig <- gsub(\"\\\\.bam\",\"_openRegions\\\\.bw\",sortedBAM)\nopenRegionRPMBigWig <- gsub(\"\\\\.bam\",\"_openRegionsRPM\\\\.bw\",sortedBAM)\natacFragments_Open <- granges(atacReads_Open)\nexport.bw(coverage(atacFragments_Open),openRegionBigWig)\n```\n\n![bigWig in IGV](ATAC_Data/images/bigwigImage.png)\n\n# Greenleaf dataset - Finding Open Regions.\n\nA common goal in ATAC-seq is to identify open chromatin regions/nucleosome free regions. \n\nFor the remainder of the workshop we will look at analysing the nucleosome free portions of the our ATAC-seq data.\n\n## Peak calling for nucleosome free regions.\n\nAs we discussed, the reads with insert sizes less than 100bp represent fragments coming from open chromatin and around transcription factors bound to the DNA.\n\nThere are many methods available to call nucleosome free regions from ATAC-seq data with many borrowed from ChIP-seq analysis.\n\n\n### Peak calling using MACS2\n\nOne very popular and standard peak caller for ATAC-seq is MAC2.\n\nMACS2 is well established for identifying punctate peaks found in ChIP-seq data from transcription factors.\n\nMACS2 website can be found [here]() with information on parameters and use cases.\n\n\n### Single end peak calling.\n\nWith single end sequencing from ATAC-seq we do not know how long the fragments are.\n\nTo identify open regions therefore requires some different parameters for MACS2 peak calling.\n\nOne strategy employed is to shift read 5' ends by -100 and then extend from this by 200bp. Considering the expected size of our nucleosome free fragments this should provide a pile-up over nucelosome regions suitable for MACS2 window size. \n\n```{r MACS2_singlePeakCallOpen, engine=\"bash\", echo=TRUE,eval=FALSE,cache=TRUE}\nMACS2 callpeak -t singleEnd.bam --nomodel --shift -100 --extsize 200 --format BAM -g MyGenome\n```\n\nAlternatively for the nucleosome occupied data we can adjust shift and extension to centre the signal on nucleosome centres (nucleosomes wrapped in 147bp of DNA). \n\n```{r MACS2_singlePeakCallmononuc, engine=\"bash\", echo=TRUE,eval=FALSE,cache=TRUE}\nMACS2 callpeak -t singleEnd.bam --nomodel --shift 37 --extsize 73 --format BAM -g MyGenome\n```\n\n### Paired end peak calling.\n\nIf we have sequenced paired-end data then we do know the fragment lengths and can provide pre-filter BAM files to MACS2.\n\nWe have to simply tell MACS2 that the data is paired using the format argument.\n\nBy default MACS2 will guess it is single end BAM.\n\n```{r MACS2_pairedPeakCall, engine=\"bash\", echo=TRUE,eval=FALSE,cache=TRUE}\nMACS2 callpeak -t pairedEnd.bam -f BAMPE --outdir path/to/output/ --name pairedEndPeakName -g MyGenome\n```\n\n```{r MACS2_pairedPeakCall_Actual, engine=\"bash\", echo=TRUE,eval=FALSE,cache=TRUE,tidy=TRUE,include=FALSE}\nMACS2 callpeak  -t ATAC_Data/ATAC_BAMs/Sorted_ATAC_50K_2_openRegions.bam \n                --outdir ATAC_Data/ATAC_Peaks/ATAC_50K_2_openRegions \n                --name ATAC_50K_2_openRegions \n                -f BAMPE -g hs\n```\n\n\nFollowing peak calling we would get 3 files.\n\n* Name.narrowPeak -- Narrow peak format suitable for IGV and further analysis\n\n* Name_peaks.xls -- Peak table suitable for review in excel.(not actually a xls but a tsv)\n\n* summits.bed -- Summit positions for peaks useful for finding motifs and plotting\n\n## QC for low quality, duplicates and signal distribution.\n\nBefore we remove any data we can get a quick assessment of our reads in peaks, duplication rate, low quality reads and reads in artefact regions from ChIPQC.\n\n```{r processData_callQC,messages=FALSE,warning=FALSE, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"readinPeakCalling\"}\nlibrary(ChIPQC)\nlibrary(rtracklayer)\nlibrary(DT)\nlibrary(dplyr)\nlibrary(tidyr)\n\nblkList <- import.bed(\"ATAC_Data/ATAC_blacklists/ENCFF001TDO.bed.gz\")\nopenRegionPeaks <- \"ATAC_Data/ATAC_Peaks/Sorted_ATAC_50K_2_Small_Paired_peaks.narrowPeak\"\n\nqcRes <- ChIPQCsample(\"ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2_openRegions.bam\",peaks = openRegionPeaks,annotation =\"hg19\",chromosomes = \"chr20\",blacklist = blkList,verboseT = FALSE)\n  \n  \n  QCmetrics(qcRes) %>% t %>%  data.frame %>%  dplyr:::select(Reads,starts_with(c(\"Filt\")),starts_with(c(\"RiP\")),starts_with(c(\"RiBL\"))) %>% datatable(rownames = NULL)\n  flagtagcounts(qcRes) %>% t %>%  data.frame  %>% mutate(Dup_Percent=(DuplicateByChIPQC/Mapped)*100) %>% dplyr:::select(Mapped,Dup_Percent) %>% datatable(rownames = NULL)\n  \n```\n\n## Blacklisted Regions\n\nA potential confounder of analysis and a source of noise in ATAC-seq (and ChIPseq/DNAseq etc) are high signal arteact regions within the genome. \n\nSuch regions have been previously defined for many model organisms and are available from the encode portal [here](https://www.encodeproject.org/annotations/ENCSR636HFF/).\n\n![blacklist in IGV](ATAC_Data/images/blkList1.png)\n![blacklist in IGV](ATAC_Data/images/blkList2.png)\n\n\n\n##  Remove blacklisted peaks \n\nSince blacklisted regions may confound our analysis we remove any peaks which have been called there. \n\nRemoving blacklists too early can hide some of the qc issues in your data. The **blacklist** should always be considered in your analysis and recommended to removed data from these regions once QC is considered.\n\n```{r processData_filterBLKlist, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_callQC\"}\nMacsCalls_chr20 <- granges(qcRes[seqnames(qcRes) %in% \"chr20\"])\n\ndata.frame(Blacklisted=sum(MacsCalls_chr20 %over% blkList),Not_Blacklisted=sum(!MacsCalls_chr20 %over% blkList))\nMacsCalls_chr20_filtered <- MacsCalls_chr20[!MacsCalls_chr20 %over% blkList]\n```\n\n\n# Greenleaf dataset - Annotating Open Regions.\n\nIt is often of interest to associate identified open/nucleosome free regions to genomic features such as genes and enhancers.\n\nOnce annotated to genes or enhancers' genes, we can start to associate ATAC-seq data to characteristics of these genes. (functional annotation, expression changes, other epigenetic states)\n\n### Annotating peaks to genes.\n\nA simple approach to annotating nucleosome free region to genes is to associate regions to their closest gene or within a window around a genes transcriptional start site.\n\nWe can use the chipseeker library to identify genes closest to our regions and to give us simple summaries and visualisations of this annotation.\n\nWe use the gene models from TxDb.Hsapiens.UCSC.hg19.knownGene and supply this to ChIPseeker packages annotatePeak function.\n\nChIPseeker's csAnno object will then show breakdown of percentages of peaks in genomic regions.\n\n```{r processData_annotatePeak, echo=TRUE,eval=TRUE,cache=TRUE,dependson=c(\"processData_filterBLKlist\",\"processData_plottingFragmentLengthsAcrossTSS\")}\nlibrary(ChIPseeker)\nMacsCalls_chr20_filteredAnno <-  annotatePeak(MacsCalls_chr20_filtered,\n                                              TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene)\nMacsCalls_chr20_filteredAnno\n```\n\n### Displaying annotation distribution\n\nAs well as showing us a table of the annotation distribution we can visualise this using the plotAnnoPie and plotAnnoBar functions.\n\n```{r processData_Pie, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_annotatePeak\"}\n\nplotAnnoPie(MacsCalls_chr20_filteredAnno)\nplotAnnoBar(MacsCalls_chr20_filteredAnno)\n```\n\n### Visualising overlaps between genomic regions.\n\nIt is important to note that ChIPseeker is making some critical choices for you here. An important decision is the order of preference in annotating our peaks when they fall in multiple gene regions .. ie. (5'UTR and promoter).\n\nThe overlap between annotation can be seen by way of an upset plot.\n\n```{r processData_UpsetPlot,echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_annotatePeak\"}\nupsetplot(MacsCalls_chr20_filteredAnno)\n```\n\n\n\n### Retrieving annotated Nucleosome-free regions.\n\nWith this information we can then subset our peaks/nuc free regions to those only landing in TSS regions (+/- 500)\n\n```{r processData_annotated, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_annotatePeak\"}\nMacsGranges_Anno <- as.GRanges(MacsCalls_chr20_filteredAnno)\nTSS_MacsGranges_Anno <- MacsGranges_Anno[abs(MacsGranges_Anno$distanceToTSS) < 500]\nTSS_MacsGranges_Anno\n```\n\n\n### Functional Analysis of Nucleosome-free regions - 1.\n\nAnother common step to ATAC-seq analysis is to identify any functional enrichment in genes associated to nucleosome free regions.\n\nOne approach is to take the genes we identified from ChIPseeker as having nuclesome free regions and test these for functional enrichment using standard tools. \n\nAnother approach which is well suited to ATAC-seq is that implemented in GREAT.\n\nGREAT first defines potential regulatory regions for all genes and then then tests for enrichment accounting for total size of regulatory regions for a pathway/GO term/gene set.\n\nGREAT is queried typically through its web portal [here](http://great.stanford.edu/public/html/) but we can take advantage of the r interface in rGREAT.\n\n**rGREAT by default will limit our queries and so we may need to be patient. This can be adjusted in rGREAT options.**\n\nWe can submit our peak calls to GREAT using the submitGreatJob function and review available categories of results using availableCategories.\n\n```{r processData_funAnalysise,echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_filterBLKlist\"}\nlibrary(rGREAT)\nseqlevelsStyle(MacsCalls_chr20_filtered) <- \"UCSC\"\n\ngreat_Job <- submitGreatJob(MacsCalls_chr20_filtered, species = \"hg19\")\navailableCategories(great_Job)\n```\n\n### Functional Analysis of Nucleosome-free regions - 2.\n\nFor this example we select the results tables for the GO category using getEnrichmentTables functions and then review the results for Biological processes.\n\n```{r processData_funAnalysis2,echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_funAnalysis2\"}\ngreat_ResultTable = getEnrichmentTables(great_Job, category = \"GO\")\nnames(great_ResultTable)          \ngreat_ResultTable[[\"GO Biological Process\"]][1:4, ]\nsave(great_ResultTable,file=\"ATAC_Data/ATAC_RData/Great_Results.RData\")\n```\n\n## Differential ATAC-seq\n\nWe have briefly reviewed the processing and initial analysis of one ATAC-seq sample using R.\n\nIn the next part we will look at how we can identify changes in open regions using R/Bioconductor.\n\nHere we will take an approach akin that in Diffbind and reasonably esatablished in ATAC-seq analysis. \n\nFirst, We will define a set of non-redundant peaks present in at least 2 samples and use these to assess changes in nuc-free ATAC-seq signal using DESeq2.\n\n## Identifying a set of non-redundant peaks.\n\n![blacklist in IGV](ATAC_Data/images/fromChIPseqTalk.png)\n\nHere we will use soGGi to produce merge our open regions from all samples into a set of non-redundant (no overlapping regions) open regions present in any sample.\n\n```{r processData_consensus, echo=TRUE,eval=TRUE,cache=TRUE}\npeaks <- dir(\"ATAC_Data/ATAC_Peaks_forCounting/\",pattern=\"*.narrowPeak\",full.names=TRUE)\nmyPeaks <- lapply(peaks,ChIPQC:::GetGRanges,simple=TRUE)\n\nnames(myPeaks) <- c(\"HindBrain_1\",\"HindBrain_2\",\"Kidney_1\",\"Kidney_2\",\"Liver_1\",\"Liver_2\")\nGroup <- factor(c(\"HindBrain\",\"HindBrain\",\"Kidney\",\"Kidney\",\"Liver\",\"Liver\"))\nconsensusToCount <- soGGi:::runConsensusRegions(GRangesList(myPeaks),\"none\")\n\nblklist <- import.bed(\"ATAC_Data/ATAC_blacklists/ENCFF547MET.bed.gz\")\n\nconsensusToCount <- consensusToCount[!consensusToCount %over% blklist & !seqnames(consensusToCount) %in% \"chrM\"]\n\nconsensusToCount\n```\n\n## Overlap of nucleosome free regions among replicates.\n\nNow we have a set of non-redundant peaks we can review the correspondance between replicates by venn diagrams of peak overlaps.\n\nHere we pass the overlap matrix generated by soGGi to limma's vennDiagram function.\n\n```{r processData_consensus_Venns, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_consensus\"}\nlibrary(limma)\n\nas.data.frame(elementMetadata(consensusToCount)) %>% dplyr::select(starts_with(\"Liver\")) %>% \n  vennDiagram(main=\"Overlap for Liver open regions\")\n\nas.data.frame(elementMetadata(consensusToCount)) %>% dplyr::select(starts_with(\"Kidney\")) %>% \n  vennDiagram(main=\"Overlap for Kidney open regions\")\n\nas.data.frame(elementMetadata(consensusToCount)) %>% dplyr::select(starts_with(\"HindBrain\")) %>% \n  vennDiagram(main=\"Overlap for Hindbrain open regions\")\n\n```\n\n## PCA of overlaps (occupancy analysis).\n\nWe can also Diffbind style PCA analysis (Occupancy analysis in Diffbind) of peak overlaps to get an overall view of correspondance between peak calls.\n\nHere we pass the matrix of peak overlaps from soGGi to prcomp function and plot the results in ggplot2.\n\n```{r processData_consensus_diffbindStylePCA, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_consensus\"}\nlibrary(tidyr)\n\nmyPlot <- as.data.frame(elementMetadata(consensusToCount)) %>% \n  dplyr::select(-consensusIDs) %>% \n  as.matrix %>% t %>% prcomp %>% .$x %>% data.frame %>% \n  mutate(Samples=rownames(.)) %>% \n  mutate(Group=gsub(\"_\\\\d\",\"\",Samples)) %>% \n  ggplot(aes(x=PC1,y=PC2,colour=Group))+geom_point(size=5)\n\nmyPlot\n```\n\n## Counting for differential ATAC-seq.\n\n\nThe presense or absense of a peak does not fully capture the changes in ATAC-seq signal observed in a genome broswer. Identifying changes of ATAC-seq signal within peaks will allow us to better capture ATAC-seq signal differences.\n\nTo do this we will borrow some methods from RNA-seq,  namely DESeq2, to evaluate changes in ATAC-seq signal between groups/tissues.\n\nFirst we will filter our peaks in a manner similar to Diffbind, where we keep only peaks which are present in at least two replicates.\n\n\n```{r processData_consensusCounting, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_consensus\"}\nlibrary(Rsubread)\noccurrences <- elementMetadata(consensusToCount) %>% as.data.frame %>% dplyr::select(-consensusIDs) %>% rowSums\n\ntable(occurrences) %>% rev %>% cumsum\n\nconsensusToCount <- consensusToCount[occurrences >= 2,]\n\nconsensusToCount\n```\n\nNow we have to set of regions to count in we can use Rsubread to count paired reads landing in peaks.\n\n**Note that Rsubread allows for maximum and minimum fragment lengths!**\n\n**This takes awhile so run this after workshop if interested**\n\n**Takes ~ 10 minutes on 3.1 GHz Intel Core i7 Mac pro**\n\n```{r processData_consensusCounting2, echo=TRUE,eval=FALSE,cache=TRUE,dependson=\"processData_consensusCounting\"}\n\nbamsToCount <- dir(\"ATAC_Data/ATAC_BAM_forCounting/\",full.names = TRUE,pattern = \"*.\\\\.bam$\")\n#indexBam(bamsToCount)\nregionsToCount <- data.frame(GeneID=paste(\"ID\",seqnames(consensusToCount),start(consensusToCount),end(consensusToCount),sep=\"_\"),\n                             Chr=seqnames(consensusToCount),Start=start(consensusToCount),End=end(consensusToCount),Strand=strand(consensusToCount))\nfcResults <- featureCounts(bamsToCount,annot.ext=regionsToCount,isPairedEnd = TRUE,countMultiMappingReads = FALSE,maxFragLength=100)\nmyCounts <- fcResults$counts\ncolnames(myCounts) <- c(\"HindBrain_1\",\"HindBrain_2\",\"Kidney_1\",\"Kidney_2\",\"Liver_1\",\"Liver_2\")\nsave(myCounts,file=\"ATAC_Data/ATAC_RData/countsFromATAC.RData\")\n```\n\n## DESeq2 for differential ATAC-seq.\n\nWith our counts of fragments in nucleosome free regions we can now contruct a DESeq2 object and perform a PCA again but this time using signal within peaks, not just occurrence in regions. \n\nWe pass the GRanges of regions we count to DESeqDataSetFromMatrix function so as to access these from DESeq2 later.\n\n```{r processData_DEseq2_PCA, echo=TRUE,eval=TRUE,cache=TRUE}\nlibrary(DESeq2)\nload(\"ATAC_Data/ATAC_RData/countsFromATAC.RData\")\nmetaData <- data.frame(Group,row.names=colnames(myCounts))\natacDDS <- DESeqDataSetFromMatrix(myCounts,metaData,~Group,rowRanges=consensusToCount)\natacDDS <- DESeq(atacDDS)\natac_Rlog <- rlog(atacDDS)\nplotPCA(atac_Rlog,intgroup=\"Group\",ntop=nrow(atac_Rlog))\n```\n\nWith the new DESeq2 object we can now test for any differences in ATAC-seq signal between groups.\n\nIn this example we look at differences between hindbrain and liver samples. \n\nWe return a GRanges object here to allow us to perform some more GenomicRanges operations.\n\n```{r processData_DEseq2_Results_ResultsTable, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_DEseq2_PCA\"}\nlibrary(DESeq2)\nlibrary(BSgenome.Mmusculus.UCSC.mm10)\nlibrary(tracktables)\n\n\nLiverMinusHindbrain <- results(atacDDS,c(\"Group\",\"Liver\",\"HindBrain\"),format=\"GRanges\")\nLiverMinusHindbrain <- LiverMinusHindbrain[order(LiverMinusHindbrain$pvalue)]\nLiverMinusHindbrain\n```\n\nWe can subset to only open regions within promoters and then create a table to review the results in IGV using makebedtable function in tracktables package. \n\n```{r processData_DEseq2_ResultsToTSSregions, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_DEseq2_Results_ResultsTable\"}\n\nlibrary(TxDb.Mmusculus.UCSC.mm10.knownGene)\ntoOverLap <- promoters(TxDb.Mmusculus.UCSC.mm10.knownGene,500,500)\nLiverMinusHindbrain <- LiverMinusHindbrain[(!is.na(LiverMinusHindbrain$padj) & LiverMinusHindbrain$padj < 0.05) & LiverMinusHindbrain %over% toOverLap,]\n#LiverMinusHindbrain <- LiverMinusHindbrain[!is.na(LiverMinusHindbrain$padj) & LiverMinusHindbrain$padj < 0.05,]\nmakebedtable(LiverMinusHindbrain,\"LiverMinusHindbrain.html\",\"ATAC_Data/\")\n```\n\n## Annotation for differential ATAC-seq.\n\nIn the final part we can annotate our differential ATAC-seq regions to genes and then use gene information to test enrichment for GO sets.\n\nSince we have subset regions to those within +/- 500bp of a TSS we can use a standard enrichment analysis at this point. Here we use clusterProfiler to identify enrichment\n\n```{r processData_DEseq2_functionalEnrichmentAnalysis, echo=TRUE,eval=TRUE,cache=TRUE, dependson=\"processData_DEseq2_ResultsToTSSregions\"}\n\n\nlibrary(clusterProfiler)\nlibrary(ChIPseeker)\n\nanno_LiverMinusHindbrain <- annotatePeak(LiverMinusHindbrain,TxDb = TxDb.Mmusculus.UCSC.mm10.knownGene)\n\n\ngo1 <- enrichGO(as.data.frame(as.GRanges(anno_LiverMinusHindbrain)[as.GRanges(anno_LiverMinusHindbrain)$log2FoldChange > 0])$geneId,\n                OrgDb = \"org.Mm.eg.db\",ont = \"BP\",maxGSSize = 5000)\ngo2 <- enrichGO(as.data.frame(as.GRanges(anno_LiverMinusHindbrain)[as.GRanges(anno_LiverMinusHindbrain)$log2FoldChange < 0])$geneId, \n                OrgDb = \"org.Mm.eg.db\",ont = \"BP\",maxGSSize = 5000)\n\nhead(go1,10) %>% dplyr::select(ID,Description,pvalue,p.adjust) %>% datatable(elementId = \"goEle1\")\nhead(go2,10) %>% dplyr::select(ID,Description,pvalue,p.adjust) %>% datatable(elementId = \"goEle2\")\n\n```\n\n## Export annotated, differential ATAC-seq.\n\nFinally, we can write out the table of annotated differential ATAC-seq peaks to review in Excel or as bed files.\n\n\n```{r processData_DEseq2_export, echo=TRUE,eval=FALSE,cache=TRUE}\n  \nanno_LiverMinusHindbrain_GRanges <- as.GRanges(anno_LiverMinusHindbrain)\nanno_LiverMinusHindbrain_GRanges_Up <- anno_LiverMinusHindbrain[elementMetadata(anno_LiverMinusHindbrain)$log2FoldChange > 0]\nanno_LiverMinusHindbrain_GRanges_Down <- anno_LiverMinusHindbrain[elementMetadata(anno_LiverMinusHindbrain)$log2FoldChange < 0]\nexport.bed(anno_LiverMinusHindbrain_GRanges_Up,\"LiverMinusHindbrain_Up.bed\")\nexport.bed(anno_LiverMinusHindbrain_GRanges_Down,\"LiverMinusHindbrain_Down.bed\")\n\nanno_LiverMinusHindbrain_df <- as.data.frame(anno_LiverMinusHindbrain)\nwrite.table(anno_LiverMinusHindbrain_df,\"LiverMinusHindbrain.csv\",quote=FALSE,row.names=FALSE,sep=\",\")\n\n```\n\n\n## Cutting sites from ATAC-seq data\n\nATAC-seq should generate shorter fragments (our nucleosome free regions) around smaller *protected* areas such as transcription factor binding sites.\n\nWe can therefore look for the pile-up of cut-sites around motifs of interest within different tissues/celltypes/samples.\n\nTo produce cut-sites from our BAM file we first resize our reads to 1bp and make the shift of 4/-5 bp depending on strand to adjust for expected shift from insertion of Tn5 transposase.\n\nHere we will identify CTCF motifs passing an arbitary cut-off and then use soGGi to plot cut-sites around them\n\n```{r processData_motifCuts, echo=TRUE,eval=TRUE,cache=TRUE,dependson=\"processData_createOpenRegionBAM_2\"}\n\nlibrary(MotifDb)\nlibrary(Biostrings)\nlibrary(BSgenome.Hsapiens.UCSC.hg19)\n\nCTCF <- query(MotifDb, c(\"CTCF\"))\nCTCF <- as.list(CTCF)\nmyRes <- matchPWM(CTCF[[1]],BSgenome.Hsapiens.UCSC.hg19[[\"chr20\"]])\ntoCompare <- GRanges(\"chr20\",ranges(myRes))\n\nread1 <- first(atacReads_Open)\nread2 <- second(atacReads_Open)\nFirsts <- resize(granges(read1),fix=\"start\",1)\nFirst_Pos_toCut <- shift(granges(Firsts[strand(read1) == \"+\"]),\n                                         4)\nFirst_Neg_toCut <- shift(granges(Firsts[strand(read1) == \"-\"]),\n                                         -5)\n\n\nSeconds <- resize(granges(read2),fix=\"start\",1)\nSecond_Pos_toCut <- shift(granges(Seconds[strand(read2) == \"+\"]),\n                                4)\nSecond_Neg_toCut <- shift(granges(Seconds[strand(read2) == \"-\"]),\n                                -5)\n  \ntest_toCut <- c(First_Pos_toCut,\n                First_Neg_toCut,\n                Second_Pos_toCut,\n                Second_Neg_toCut)\ncutsCoverage <- coverage(test_toCut)\ncutsCoverage20 <- cutsCoverage[\"chr20\"]\nCTCF_Cuts_open <- regionPlot(cutsCoverage20,\n                         testRanges = toCompare,\n                         style = \"point\",\n                         format=\"rlelist\",distanceAround = 500)\nplotRegion(CTCF_Cuts_open,outliers = 0.001)+ggtitle(\"NucFree Cuts Centred on CTCF\")\n\n```\n",
    "created" : 1522003792702.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2580718959",
    "id" : "2693401D",
    "lastKnownWriteTime" : 1522429225,
    "last_content_update" : 1522429225756,
    "path" : "~/Projects/Results/SashaT/stuff.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}