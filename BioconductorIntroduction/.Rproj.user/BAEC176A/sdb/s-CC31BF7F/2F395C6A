{
    "collab_server" : "",
    "contents" : "require(Biostrings)\nrequire(BSgenome.Hsapiens.UCSC.hg19)\nrequire(GenomeInfoDb)\nrequire(GenomicAlignments)\nrequire(rtracklayer)\nrequire(Rsubread)\nrequire(org.Hs.eg.db)\nrequire(Rsamtools)\nrequire(GenomicFeatures)\nrequire(tximport)\nrequire(dplyr)\nrequire(DESeq2)\nrequire(prettydoc)\nrequire(dplyr)\n\n\n\n\ngetReferencesBioC <- function(){\n  list(\n    \"hg19-UCSC\"=c(sequence=\"BSgenome.Hsapiens.UCSC.hg19\",\n                  annotation=\"org.Hs.eg.db\",\n                  genemodels=\"TxDb.Hsapiens.UCSC.hg19.knownGene\",\n                  blacklist=\"http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeMapability/wgEncodeDacMapabilityConsensusExcludable.bed.gz\"),\n    \"mm9-UCSC\"=c(sequence=\"BSgenome.Mmusculus.UCSC.mm9\",\n                 annotation=\"org.Mm.eg.db\",\n                 genemodels=\"TxDb.Mmusculus.UCSC.mm9.knownGene\",\n                 blacklist=\"http://www.broadinstitute.org/~anshul/projects/mouse/blacklist/mm9-blacklist.bed.gz\"),\n    \"mm10-UCSC\"=c(sequence=\"BSgenome.Mmusculus.UCSC.mm10\",\n                  annotation=\"org.Mm.eg.db\",\n                  genemodels=\"TxDb.Mmusculus.UCSC.mm10.knownGene\",\n                  blacklist=\"http://mitra.stanford.edu/kundaje/akundaje/release/blacklists/mm10-mouse/mm10.blacklist.bed.gz\"),\n    \"dm6-UCSC\"=c(sequence=\"BSgenome.Dmelanogaster.UCSC.dm6\",\n                  annotation=\"org.Dm.eg.db\",\n                  genemodels=\"TxDb.Dmelanogaster.UCSC.dm6.ensGene\",\n                  blacklist=\"http://mitra.stanford.edu/kundaje/akundaje/release/blacklists/mm10-mouse/mm10.blacklist.bed.gz\")\n    \n  )\n}\n\n\n\ngatherReferenceFiles <- function(genome,geneModels=\"\",id2SymbolFile=\"\",id2GOFile=\"\",referencesBioC=getReferencesBioC(),blacklist=\"\",referenceDir=file.path(getwd(),\"Reference\"),\n                                 mode=\"ChIP\",\n                                 executables=list(salmonCMD = \"salmon\"),spikeIn=FALSE\n){\n  require(Rsamtools)\n  require(Rsubread)\n  require(dplyr)\n  require(magrittr)\n  require(rtracklayer)\n  require(Biostrings)\n\n  fasta <- NULL\n  subreadIndex <- NULL\n\n\n  dir.create(referenceDir,showWarnings = FALSE)\n\n  ## Make Annotation files\n  if(!file.exists(genome) & is.character(genome)){\n    require(as.character(referencesBioC[[genome]][\"annotation\"]),character.only = T)\n    id2SymbolFile <- file.path(referenceDir,\n                               gsub(\"\\\\.db\",\"_ID2Symbol.txt\",\n                                    referencesBioC[[genome]][\"annotation\"]))\n    id2GOFile <- file.path(referenceDir,gsub(\"\\\\.db\",\"_GOAnno.txt\",\n                                             referencesBioC[[genome]][\"annotation\"]))\n    id2TopGOFile <- file.path(referenceDir,gsub(\"\\\\.db\",\"_GOAnnoforTopGO.txt\",\n                                                referencesBioC[[genome]][\"annotation\"]))\n\n\n    if(!file.exists(id2SymbolFile)){\n      entrez2Symbol <- eval(parse(text=(as.character(gsub(\"\\\\.db\",\"SYMBOL\",\n                                                          referencesBioC[[genome]][\"annotation\"])))))\n      entrezAnno <- unlist(AnnotationDbi::as.list(entrez2Symbol))\n      entrez2Symbolframe <- data.frame(IDs=names(entrezAnno),\n                                       Symbols=unname(entrezAnno))\n      write.table(entrez2Symbolframe,\n                  file=id2SymbolFile,\n                  row.names=FALSE,sep=\"\\t\",\n                  quote=FALSE,col.names=TRUE)\n    }\n    if(!file.exists(id2GOFile)){\n      go2allegs <- eval(parse(text=(as.character(gsub(\"\\\\.db\",\"GO2ALLEGS\",\n                                                      referencesBioC[[genome]][\"annotation\"])))))\n      goList <- AnnotationDbi::as.list(revmap(go2allegs))\n      goUnlist <- unlist(goList)\n      # goMatrix <- matrix(tmp,ncol=3,byrow=TRUE)\n      goIDs <- goUnlist[grep(\"GOID\",names(goUnlist))]\n      IDs <- gsub(\"\\\\..*\",\"\",names(goIDs))\n      goUnIDs <- unname(goIDs)\n      uniqueIDs <- unique(IDs)\n      GOframe <- data.frame(IDs=IDs,GOIDs=goUnIDs)\n      write.table(GOframe,file=id2GOFile,\n                  row.names=FALSE,sep=\"\\t\",quote=FALSE,col.names=TRUE)\n\n    }else{\n      GOframe <- read.delim(id2GOFile,sep=\"\\t\",header=TRUE)\n    }\n    if(!file.exists(id2TopGOFile)){\n      \n      topGOtable <- GOframe %>% group_by(IDs) %>% summarise(GOgrouped=paste(GOIDs,collapse=\",\"))\n      write.table(topGOtable,file=id2TopGOFile,\n                  row.names=FALSE,sep=\"\\t\",quote=FALSE,col.names=FALSE)\n    }\n  }else if(file.exists(id2SymbolFile) & file.exists(id2GOFile)){\n    message(\"Making my own go from custom\")\n  id2SymbolFile <- id2SymbolFile\n  id2GOFile <- id2GOFile\n  id2TopGOFile <- paste(id2GOFile,\"forTopGO.txt\",sep=\"_\")\n  if(!file.exists(id2TopGOFile)){\n    GOframe <- read.delim(id2GOFile,sep=\"\\t\",header=TRUE)\n    topGOtable <- GOframe %>% group_by(IDs) %>% summarise(GOgrouped=paste(GOIDs,collapse=\",\"))\n    write.table(topGOtable,file=id2TopGOFile,\n                row.names=FALSE,sep=\"\\t\",quote=FALSE,col.names=FALSE)\n  }\n  }else{\n    id2SymbolFile <- NULL\n    id2GOFile <- NULL\n    id2TopGOFile <- NULL \n  }\n\n  ## Make Genome file.\n  if(file.exists(genome)){\n    fastaOut <- genome\n    message(\"An original genome point!\")\n    print(fastaOut)\n  }else{\n    fastaOut <- file.path(referenceDir,paste0(referencesBioC[[genome]][\"sequence\"],\".fa\"))\n    if(spikeIn == \"ERCC92\"){\n      fastaOut <- file.path(referenceDir,paste0(referencesBioC[[genome]][\"sequence\"],\"_ERCC92.fa\"))\n    }\n  }\n\n  ## Using Bioconductor for fasta\n  if(!file.exists(genome) & is.character(genome)){\n    if(!file.exists(fastaOut)){\n      # Load BSgenome library or install\n      ## Could use pacman here https://cran.r-project.org/web/packages/pacman/vignettes/Introduction_to_pacman.html\n      if(require(as.character(referencesBioC[[genome]][\"sequence\"]),character.only = T)){\n        message(\"Loaded \",as.character(referencesBioC[[genome]][\"sequence\"]))\n      }else{\n        source(\"https://bioconductor.org/biocLite.R\")\n        biocLite(as.character(referencesBioC[[genome]][\"sequence\"]))\n      }\n\n      genomeBioc <- eval(parse(text=(as.character(referencesBioC[[genome]][\"sequence\"]))))\n      keptChrome <- seqnames(genomeBioc)[!grepl(\"hap|random|chrUn\",seqnames(genomeBioc))]\n      toWriteFasta <- DNAStringSet(lapply(keptChrome,function(x)genomeBioc[[x]]))\n      names(toWriteFasta) <- keptChrome\n      if(spikeIn == \"ERCC92\"){\n        fileLocations <- system.file(\"extdata\",package=\"rnaPipeR\")\n        myERCCstrings <- readDNAStringSet(file.path(fileLocations,\"ERCC92.fa\"))\n        toWriteFasta <- c(toWriteFasta,myERCCstrings)\n        referencesBioC[[genome]][\"sequence\"] <- paste0(referencesBioC[[genome]][\"sequence\"],\"_ERCC92\")\n      }\n      writeXStringSet(toWriteFasta,fastaOut)\n      indexFa(FaFile(fastaOut))\n    }\n    if(!file.exists(paste0(gsub(\"\\\\.fa$\",\"\",fastaOut),\".00.b.array\"))){\n      buildindex(gsub(\"\\\\.fa$\",\"\",fastaOut),fastaOut,indexSplit=FALSE)\n    }\n    fasta <- fastaOut\n    subreadIndex <- gsub(\"\\\\.fa$\",\"\",fastaOut)\n    ## Using external fastsa\n  }else if(file.exists(genome)){\n    fasta <- genome\n    if(!file.exists(gsub(\"\\\\.fa\",\"\\\\.00\\\\.b\\\\.array\",fasta))){\n      buildindex(gsub(\"\\\\.fa\",\"\",fasta),fasta,indexSplit=FALSE)\n    }\n    indexFa(FaFile(fasta))\n    subreadIndex <- gsub(\"\\\\.fa\",\"\",fasta)\n  }\n  \n  id2TopGOFile <- file.path(referenceDir,gsub(\"\\\\.db\",\"_GOAnnoforTopGO.txt\",\n                                              referencesBioC[[genome]][\"annotation\"]))\n  \n  fastaLengths <- gsub(\"\\\\.fa$\",\"\\\\.lengths\",fastaOut)\n  if(!file.exists(fastaLengths)){\n    require(Rsamtools)\n    effe <- FaFile(fastaOut)\n    chrInfo <- data.frame(names(seqlengths(effe)),seqlengths(effe))\n    colnames(chrInfo) <- c(\"Contigs\",\"Lengths\")\n    write.table(chrInfo,file=fastaLengths,sep=\"\\t\",quote=FALSE,col.names = TRUE,row.names = FALSE)\n  }\n  \n  validSeqnames <- seqnames(seqinfo(FaFile(fastaOut)))\n  if(spikeIn==\"ERCC92\"){\n    fileLocations <- system.file(\"extdata\",package=\"rnaPipeR\")\n    myERCCgtf <- makeTxDbFromGFF(file.path(fileLocations,\"ERCC92.gtf\"))\n    validSeqnames <- unique(c(seqnames(seqinfo(myERCCgtf)),validSeqnames))\n  }\n  \n  if(!file.exists(geneModels) & is.character(genome)){\n    if(spikeIn!=\"ERCC92\"){\n      gtfOut <- file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gtf\"))\n    }else{\n      gtfOut <- file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\"_ERCC92.gtf\"))\n    }\n    gtfOutGZ <- gsub(\"gtf$\",\"gtf.gz\",gtfOut)\n    gtfDisJoinOut <-  gsub(\"gtf$\",\"DisJoint.gtf\",gtfOut)\n    gtfDisJoinOutGZ <- gsub(\"gtf$\",\"gtf.gz\",gtfDisJoinOut)\n    gtf <- gtfOutGZ\n\n    if(!file.exists(gtfOut)){\n      require(as.character(referencesBioC[[genome]][\"genemodels\"]),character.only = T)\n      if(require(as.character(referencesBioC[[genome]][\"genemodels\"]),character.only = T)){\n        message(\"loaded \",referencesBioC[[genome]][\"genemodels\"])\n      }else{\n        source(\"https://bioconductor.org/biocLite.R\")\n        biocLite(as.character(referencesBioC[[genome]][\"genemodels\"]))\n      }\n      txdb <-  eval(parse(text=(as.character(referencesBioC[[genome]][\"genemodels\"]))))\n      txs <- transcripts(txdb, columns = c('gene_id', 'tx_id', 'tx_name', 'exon_id'))\n      metaDataforTx <- dplyr::select(data.frame(mcols(txs)),gene_id,tx_name)\n\n      #txdb <- eval(parse(text=(as.character(ref))))\n      exonsB <- exonsBy(txdb,by = \"tx\",use.names=TRUE)\n      exonsB <- unlist(exonsB)\n      mcols(exonsB)$type <- 'exon'\n      mcols(exonsB)$source <- \"Ref\"\n      mcols(exonsB)$transcript_id <- names(exonsB)\n      mcols(exonsB)$tx_id <- names(exonsB)\n      metaDataForExon <- data.frame(mcols(exonsB))\n      test <- merge(metaDataForExon,metaDataforTx,by.x=\"transcript_id\",by.y=\"tx_name\",all=FALSE,sort=FALSE)\n      mcols(exonsB) <- dplyr::select(test,gene_id,tx_id,exon_id,type,source,transcript_id)\n      mcols(exonsB)$tx_name <- mcols(exonsB)$tx_id\n      keptChrome <- seqnames(exonsB)[!grepl(\"hap|random|chrUn\",seqnames(exonsB))]\n      exonsB <- exonsB[as.vector(seqnames(exonsB)) %in% as.vector(unique(keptChrome)),]\n      filterE <- S4Vectors::lengths(exonsB$gene_id) != 0\n      txdbBiocExons <- exonsB[filterE,]\n\n      cds <- cdsBy(txdb,by = \"tx\",use.names=TRUE)\n      cds <- unlist(cds)\n      mcols(cds)$type <- 'CDS'\n      mcols(cds)$source <- \"ref\"\n      mcols(cds)$transcript_id <-names(cds)\n      mcols(cds)$tx_id <- names(cds)\n      metaDataForCDS <- data.frame(mcols(cds))\n      test <- merge(metaDataForCDS,metaDataforTx,by.x=\"transcript_id\",by.y=\"tx_name\",all=FALSE,sort=FALSE)\n      mcols(cds) <- dplyr::select(test,gene_id,tx_id,cds_id,type,source,transcript_id)\n      mcols(cds)$exon_id <- mcols(cds)$cds_id\n      mcols(cds)$tx_name <- mcols(cds)$tx_id\n      keptChrome <- seqnames(cds)[!grepl(\"hap|random|chrUn\",seqnames(cds))]\n      cds <- cds[as.vector(seqnames(cds)) %in% as.vector(unique(keptChrome)),]\n      filterCDS <- S4Vectors::lengths(cds$gene_id) != 0\n      txdbBiocCDS <- cds[filterCDS,]\n\n      temp <- as.data.frame(mcols(txdbBiocExons))\n      temp2 <- dplyr::select(as.data.frame(mcols(txdbBiocCDS)),-cds_id)\n      new <- GRanges(c(seqnames(txdbBiocExons),seqnames(txdbBiocCDS)),c(ranges(txdbBiocExons),ranges(txdbBiocCDS)),strand = c(strand(txdbBiocExons),strand(txdbBiocCDS)))\n      mcols(new) <- rbind(temp,temp2)\n      new <- sort(new,ignore.strand=TRUE)\n      if(spikeIn==\"ERCC92\"){\n        fileLocations <- system.file(\"extdata\",package=\"rnaPipeR\")\n        myERCCgtf <- makeTxDbFromGFF(file.path(fileLocations,\"ERCC92.gtf\"))\n        \n        txs <- transcripts(myERCCgtf, columns = c('gene_id', 'tx_id', 'tx_name', 'exon_id'))\n        metaDataforTx <- dplyr::select(data.frame(mcols(txs)),gene_id,tx_name)\n\n        #txdb <- eval(parse(text=(as.character(ref))))\n        ExonsERCC <- exonsBy(myERCCgtf,by = \"tx\",use.names=TRUE)\n        ExonsERCC <- unlist(ExonsERCC)\n        mcols(ExonsERCC)$type <- 'exon'\n        mcols(ExonsERCC)$source <- \"Ref\"\n        mcols(ExonsERCC)$transcript_id <- names(ExonsERCC)\n        mcols(ExonsERCC)$tx_id <- names(ExonsERCC)\n        metaDataForExon <- data.frame(mcols(ExonsERCC))\n        test <- merge(metaDataForExon,metaDataforTx,by.x=\"transcript_id\",by.y=\"tx_name\",all=FALSE,sort=FALSE)\n        mcols(ExonsERCC) <- dplyr::select(test,gene_id,tx_id,exon_id,type,source,transcript_id)\n        mcols(ExonsERCC)$tx_name <- mcols(ExonsERCC)$tx_id\n        keptChrome <- seqnames(ExonsERCC)[!grepl(\"hap|random|chrUn\",seqnames(ExonsERCC))]\n        ExonsERCC <- ExonsERCC[as.vector(seqnames(ExonsERCC)) %in% as.vector(unique(keptChrome)),]\n        filterE <- S4Vectors::lengths(ExonsERCC$gene_id) != 0\n        txdbERCCExons <- ExonsERCC[filterE,]\n        temp <- as.data.frame(mcols(txdbERCCExons))\n        tempNew <- as.data.frame(mcols(new))\n        newE <- GRanges(c(seqnames(new),seqnames(txdbERCCExons)),c(ranges(new),ranges(txdbERCCExons)),strand = c(strand(new),strand(txdbERCCExons)))\n        mcols(newE) <- rbind(tempNew,temp)\n        new <- sort(newE,ignore.strand=TRUE)\n      }\n      \n      new <- new[as.vector(seqnames(new)) %in% validSeqnames,]\n      actualGtf <- gtfOutGZ\n      gtf <- gtfOutGZ\n      rtracklayer::export(new,con = gtfOut,format = \"gtf\")\n      bgzip(gtfOut,dest = gtfOutGZ,overwrite = T)\n      indexTabix(gtfOutGZ,format = \"gff\")\n    }else{\n      gtf  <- gtfOutGZ\n      actualGtf <- gtfOutGZ\n    }\n  }else{\n    gtf  <- geneModels\n    actualGtf <- geneModels\n    if(spikeIn!=\"ERCC92\"){\n      gtfOut <- file.path(referenceDir,paste0(basename(gtf),\"_ngsPipeR_\",\".gtf\"))\n    }else{\n      gtfOut <- file.path(referenceDir,paste0(basename(gtf),\"_ngsPipeR_\",\"_ERCC92.gtf\"))\n    }\n    gtfOutGZ <- gsub(\"gtf$\",\"gtf.gz\",gtfOut)\n    gtfDisJoinOut <-  gsub(\"gtf$\",\"DisJoint.gtf\",gtfOut)\n    gtfDisJoinOutGZ <- gsub(\"gtf$\",\"gtf.gz\",gtfDisJoinOut)\n    gtf <- gtfOutGZ\n    if(!file.exists(gtfOut)){\n    txdb <- GenomicFeatures::makeTxDbFromGFF(actualGtf)\n    txs <- transcripts(txdb, columns = c('gene_id', 'tx_id', 'tx_name', 'exon_id'))\n    metaDataforTx <- dplyr::select(data.frame(mcols(txs)),gene_id,tx_name)\n    \n    #txdb <- eval(parse(text=(as.character(ref))))\n    exonsB <- exonsBy(txdb,by = \"tx\",use.names=TRUE)\n    exonsB <- unlist(exonsB)\n    mcols(exonsB)$type <- 'exon'\n    mcols(exonsB)$source <- \"Ref\"\n    mcols(exonsB)$transcript_id <- names(exonsB)\n    mcols(exonsB)$tx_id <- names(exonsB)\n    metaDataForExon <- data.frame(mcols(exonsB))\n    test <- merge(metaDataForExon,metaDataforTx,by.x=\"transcript_id\",by.y=\"tx_name\",all=FALSE,sort=FALSE)\n    mcols(exonsB) <- dplyr::select(test,gene_id,tx_id,exon_id,type,source,transcript_id)\n    mcols(exonsB)$tx_name <- mcols(exonsB)$tx_id\n    keptChrome <- seqnames(exonsB)[!grepl(\"hap|random|chrUn\",seqnames(exonsB))]\n    exonsB <- exonsB[as.vector(seqnames(exonsB)) %in% as.vector(unique(keptChrome)),]\n    filterE <- S4Vectors::lengths(exonsB$gene_id) != 0\n    txdbBiocExons <- exonsB[filterE,]\n    \n    cds <- cdsBy(txdb,by = \"tx\",use.names=TRUE)\n    cds <- unlist(cds)\n    mcols(cds)$type <- 'CDS'\n    mcols(cds)$source <- \"ref\"\n    mcols(cds)$transcript_id <-names(cds)\n    mcols(cds)$tx_id <- names(cds)\n    metaDataForCDS <- data.frame(mcols(cds))\n    test <- merge(metaDataForCDS,metaDataforTx,by.x=\"transcript_id\",by.y=\"tx_name\",all=FALSE,sort=FALSE)\n    mcols(cds) <- dplyr::select(test,gene_id,tx_id,cds_id,type,source,transcript_id)\n    mcols(cds)$exon_id <- mcols(cds)$cds_id\n    mcols(cds)$tx_name <- mcols(cds)$tx_id\n    keptChrome <- seqnames(cds)[!grepl(\"hap|random|chrUn\",seqnames(cds))]\n    cds <- cds[as.vector(seqnames(cds)) %in% as.vector(unique(keptChrome)),]\n    filterCDS <- S4Vectors::lengths(cds$gene_id) != 0\n    txdbBiocCDS <- cds[filterCDS,]\n    \n    temp <- as.data.frame(mcols(txdbBiocExons))\n    temp2 <- dplyr::select(as.data.frame(mcols(txdbBiocCDS)),-cds_id)\n    new <- GRanges(c(seqnames(txdbBiocExons),seqnames(txdbBiocCDS)),c(ranges(txdbBiocExons),ranges(txdbBiocCDS)),strand = c(strand(txdbBiocExons),strand(txdbBiocCDS)))\n    mcols(new) <- rbind(temp,temp2)\n    new <- sort(new,ignore.strand=TRUE)\n    if(spikeIn==\"ERCC92\"){\n      fileLocations <- system.file(\"extdata\",package=\"rnaPipeR\")\n      myERCCgtf <- makeTxDbFromGFF(file.path(fileLocations,\"ERCC92.gtf\"))\n      txs <- transcripts(myERCCgtf, columns = c('gene_id', 'tx_id', 'tx_name', 'exon_id'))\n      metaDataforTx <- dplyr::select(data.frame(mcols(txs)),gene_id,tx_name)\n      \n      #txdb <- eval(parse(text=(as.character(ref))))\n      ExonsERCC <- exonsBy(myERCCgtf,by = \"tx\",use.names=TRUE)\n      ExonsERCC <- unlist(ExonsERCC)\n      mcols(ExonsERCC)$type <- 'exon'\n      mcols(ExonsERCC)$source <- \"Ref\"\n      mcols(ExonsERCC)$transcript_id <- names(ExonsERCC)\n      mcols(ExonsERCC)$tx_id <- names(ExonsERCC)\n      metaDataForExon <- data.frame(mcols(ExonsERCC))\n      test <- merge(metaDataForExon,metaDataforTx,by.x=\"transcript_id\",by.y=\"tx_name\",all=FALSE,sort=FALSE)\n      mcols(ExonsERCC) <- dplyr::select(test,gene_id,tx_id,exon_id,type,source,transcript_id)\n      mcols(ExonsERCC)$tx_name <- mcols(ExonsERCC)$tx_id\n      keptChrome <- seqnames(ExonsERCC)[!grepl(\"hap|random|chrUn\",seqnames(ExonsERCC))]\n      ExonsERCC <- ExonsERCC[as.vector(seqnames(ExonsERCC)) %in% as.vector(unique(keptChrome)),]\n      filterE <- S4Vectors::lengths(ExonsERCC$gene_id) != 0\n      txdbERCCExons <- ExonsERCC[filterE,]\n      temp <- as.data.frame(mcols(txdbERCCExons))\n      tempNew <- as.data.frame(mcols(new))\n      newE <- GRanges(c(seqnames(new),seqnames(txdbERCCExons)),c(ranges(new),ranges(txdbERCCExons)),strand = c(strand(new),strand(txdbERCCExons)))\n      mcols(newE) <- rbind(tempNew,temp)\n      new <- sort(newE,ignore.strand=TRUE)\n    }\n    new <- new[as.vector(seqnames(new)) %in% validSeqnames,]\n    actualGtf <- gtfOutGZ\n    gtf <- gtfOutGZ\n    rtracklayer::export(new,con = gtfOut,format = \"gtf\")\n    bgzip(gtfOut,dest = gtfOutGZ,overwrite = T)\n    indexTabix(gtfOutGZ,format = \"gff\")\n    }\n  }\n  \n  require(GenomicFeatures)\n  igvOut <- gsub(\"gtf.gz$\",\"GenePosForIGV.txt\",gtfOutGZ)\n  if(!file.exists(igvOut)){\n    myRes <- makeTxDbFromGFF(gtfOutGZ)\n    allGenes <- as.data.frame(GenomicFeatures::genes(myRes))\n    myAllGenes <- allGenes %>% select(gene_id,everything())\n    write.table(myAllGenes,igvOut,sep=\"\\t\",quote=FALSE,row.names = FALSE)\n  }\n  disjointGTF <- NULL\n  if(!file.exists(gtfDisJoinOut)){\n    require(GenomicFeatures)\n    txdb <- makeTxDbFromGFF(gtf,format=\"gtf\")\n    txs <- transcripts(txdb, columns = c('gene_id', 'tx_id', 'tx_name', 'exon_id'))\n    metaDataforTx <- dplyr::select(data.frame(mcols(txs)),gene_id,tx_name)\n    genes <- GenomicFeatures::genes(txdb, columns = c('gene_id', 'tx_id', 'tx_name', 'exon_id'))\n    metaDataforGenes <- dplyr::select(data.frame(mcols(genes)),gene_id,tx_name)\n\n    #txdb <- eval(parse(text=(as.character(ref))))\n    exonicParts =  disjointExons(txdb, aggregateGenes=FALSE)\n    mcols(exonicParts)$exon_rank <- mcols(exonicParts)$exonic_rank\n    mcols(exonicParts)$type <- 'exon'\n    mcols(exonicParts)$source <- \"Ref\"\n    mcols(exonicParts)$gene_id <- gsub(\",\",\"AND\",mcols(exonicParts)$gene_id)\n    mcols(exonicParts)$tx_id <- mcols(exonicParts)$transcript_id <- mcols(exonicParts)$tx_name <- seq(1,length(exonicParts))\n    mcols(exonicParts)$exon_id <- paste0(mcols(exonicParts)$gene_id,\"_\",mcols(exonicParts)$exon_rank)\n    # mcols(exonsB)$transcript_id <- names(exonsB)\n    # mcols(exonsB)$tx_id <- names(exonsB)\n    mcols(exonicParts) <- dplyr::select(as.data.frame(mcols(exonicParts)),gene_id,tx_id,tx_name,exon_id,type,source,transcript_id)\n    #mcols(exonsB)$tx_name <- mcols(exonsB)$tx_id\n    keptChrome <- seqnames(exonicParts)[!grepl(\"hap|random|chrUn\",seqnames(exonicParts))]\n    exonicParts <- exonicParts[as.vector(seqnames(exonicParts)) %in% as.vector(unique(keptChrome)),]\n    filterR <- S4Vectors::lengths(exonicParts$gene_id) != 0\n    txdbBiocExonsReduced <- exonicParts[filterR,]\n    txdbBiocExonsReduced <- sort(txdbBiocExonsReduced,ignore.strand=TRUE)\n    #message(\"Got here\")\n\n    new <- sort(txdbBiocExonsReduced,ignore.strand=TRUE)\n    rtracklayer::export(new,con = gtfDisJoinOut,format = \"gtf\")\n    # bgzip(gtfDisJoinOut,dest = gtfDisJoinOutGZ,overwrite = T)\n    # indexTabix(gtfDisJoinOutGZ,format = \"gff\")\n    #message(\"Got here 2\")\n    \n  }\n  disjointGTF <- gtfDisJoinOut\n  tx2GeneFile <- NULL\n  salmonIndexFile <- NULL\n  transFastaOut <- gsub(\"gtf.*\",\"fa\",gtf)\n  tx2GeneFile <- paste0(gsub(\"\\\\.gtf.*\",\"\",gtf),\"_\",\"tx2gene.csv\")\n  salmonIndexFile <- gsub(\"\\\\.gtf.*\",\"\",gtf)\n\n  if(mode==\"RNAseq\" & (!file.exists(paste0(gsub(\"\\\\.gtf.*\",\"\",gtf),\"_\",\"tx2gene.csv\"))\n                    | !file.exists(gsub(\"\\\\.gtf.*\",\".fa\",gtf)))){\n\n\n\n\n    # if(mode==\"RNA\" & !file.exists(tx2GeneFile) & !file.exists(fastaGff3Name)){\n    suppressPackageStartupMessages(library(Biostrings))\n    suppressPackageStartupMessages(library(BSgenome.Hsapiens.UCSC.hg19))\n    suppressPackageStartupMessages(library(GenomeInfoDb))\n\n\n\n\n    suppressPackageStartupMessages(require(GenomicFeatures))\n    txdb <- makeTxDbFromGFF(gtf,format = \"gtf\")\n    if(!file.exists(transFastaOut)){\n      allTranscripts <- exonsBy(txdb,use.names=T,by = \"tx\")\n      seqAllTranscripts <- extractTranscriptSeqs(FaFile(fastaOut),allTranscripts)\n      # if(spikeIn == \"ERCC92\"){\n      #   fileLocations <- system.file(\"extdata\",package=\"rnaPipeR\")\n      #   myERCCstrings <- readDNAStringSet(file.path(fileLocations,\"ERCC92.fa\"))\n      #   seqAllTranscripts <- c(seqAllTranscripts,myERCCstrings)\n      # }\n      writeXStringSet(seqAllTranscripts,filepath = transFastaOut)\n\n\n      ##message(out)\n    }\n    if(!file.exists(tx2GeneFile)){\n      k <- keys(txdb, keytype = \"GENEID\")\n      df <- AnnotationDbi::select(txdb, keys = k, keytype = \"GENEID\", columns = \"TXNAME\")\n      tx2gene <- df[, 2:1]  # tx ID, then gene ID\n      write.table(tx2gene,\n                  file=tx2GeneFile,\n                  sep=\",\",col.names=T,row.names=F)\n\n    }else{\n      message(\"Problem in making Gene to transcript map\")\n    }\n\n\n  }else{\n    transFastaOut <- gsub(\"\\\\.gtf.*\",\".fa\",gtf)\n    tx2GeneFile <- file.path(paste0(gsub(\"\\\\.gtf.*\",\"\",gtf),\"_\",\"tx2gene.csv\"))\n  }\n\n  salmonCMD <- executables$salmonCMD\n  salmonIndexFile <- gsub(\"\\\\.fa$\",\"\",transFastaOut)\n  salmonIndexArgs <- paste(\"index -t\",transFastaOut,\"-i\",gsub(\"\\\\.fa$\",\"\",transFastaOut))\n  if(!file.exists(salmonIndexFile) & mode == \"RNAseq\"){\n    system(paste(salmonCMD, salmonIndexArgs))\n  }\n\n  if(mode == \"ChIP\" | mode == \"ATACseq\" | mode == \"ATAC\" ){\n    if(!file.exists(blacklist) & is.character(genome)){\n      if(genome == \"hg19-UCSC\" & !file.exists( file.path(referenceDir,paste0(genome,\".blacklist\")))){\n        download.file(\"http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeMapability/wgEncodeDacMapabilityConsensusExcludable.bed.gz\",\n                      destfile = file.path(referenceDir,paste0(genome,\".blacklist\")))\n        blacklist <- file.path(referenceDir,paste0(genome,\".blacklist\"))\n      }else if(genome == \"mm9-UCSC\" & !file.exists( file.path(referenceDir,paste0(genome,\".blacklist\")))){\n        download.file(\"http://www.broadinstitute.org/~anshul/projects/mouse/blacklist/mm9-blacklist.bed.gz\",\n                      destfile = file.path(referenceDir,paste0(genome,\".blacklist\")))\n        blacklist <- file.path(referenceDir,paste0(genome,\".blacklist\"))\n      }else{\n        blacklist <- NULL\n      }\n    }else if(!file.exists(blacklist) & !is.character(genome)){\n      blacklist <- NULL\n    }\n  }else{\n    blacklist <- NULL\n  }\n  fastaGff3Name <- transFastaOut\n  return(list(genome=genome,fasta=fasta,gtf=gtf,GenePosForIGV=igvOut,disjointGTF=disjointGTF,id2Symbol=id2SymbolFile,id2GO=id2GOFile,id2TopGO=id2TopGOFile,actualGtf=actualGtf,blacklist=blacklist,subreadIndex=subreadIndex,gff3Fastq=fastaGff3Name,salmonIndexFile=salmonIndexFile,tx2Gene=tx2GeneFile))\n}\n\ngetPBCMetrics <- function(x,name,statsDir){\n  require(GenomicAlignments)\n  name <- name[x]\n  bamFile <- x\n  toOut <- file.path(statsDir,gsub(\"\\\\.bam\",\".PBCstats\",basename(bamFile)))\n  if(!file.exists(toOut)){\n    #bamFile <- \"~/Projects/Results/heinz/eli_DNAseq/DNAseq/BAMs/Sorted_PCP2_4.bam\"\n    test <- readGAlignments(bamFile,param=ScanBamParam(mapqFilter=1))\n    uniqueMapCoverage <- coverage(test)\n    myCov <- as.data.frame(IRanges::table(uniqueMapCoverage))\n    PBC1 <- sum(myCov[myCov$Var2 == 1,\"Freq\"])/sum(myCov[as.numeric(as.vector(myCov$Var2)) > 1,\"Freq\"])\n    PBC2 <- sum(myCov[myCov$Var2 == 1,\"Freq\"])/sum(myCov[as.numeric(as.vector(myCov$Var2)) == 2,\"Freq\"])\n    pbcFrame <- data.frame(PBC1,PBC2)\n    write.table(pbcFrame,file=toOut,sep=\"\\t\",col.names=T,row.names=FALSE)\n  }\n}\n\ngetENAaddress <- function(ID){\n  require(dplyr)\n  require(SRAdb)\n  if(!file.exists('SRAmetadb.sqlite')) sqlfile <<- getSRAdbFile()\n  sra_con <- dbConnect(SQLite(),sqlfile)\n  rs = listSRAfile(c(\"SRX000122\"), sra_con, sraType = \"sra\" )\n  rs %>% mutate(ID=sample,)\n}\n\n\n#' Alignment using STAR\n#'\n#' Alignment, gene expression estimation, QC and initial analysis of RNAseq data\n#'\n#'\n#' @docType methods\n#' @name align_star\n#' @rdname align_star\n#'\n#' @author Thomas Carroll\n#' @param fastq File/s to align\n#' @param genome A character sting of index location\n#' @param params Parameters for STAR aligner\n#' @return Path to Aligned data\n#' @import Rsamtools\n#' @export\nalign_star <- function(fastq,genome,params){\n  message(\"Not ready yet!\")\n}\n\n#' Alignment using subread\n#'\n#' Alignment, gene expression estimation, QC and initial analysis of RNAseq data\n#'\n#'\n#' @docType methods\n#' @name align_subread\n#' @rdname align_subread\n#'\n#' @author Thomas Carroll\n#' @param fastq File/s to align\n#' @param genome A character sting of index location\n#' @param params Parameters for subread aligner\n#' @return Path to Aligned data\n#' @import Rsamtools\n#' @export\nalign_subread <- function(fastq,genome,params){\n  message(\"Not ready yet!\")\n}\n\n#' Alignment using subjunc\n#'\n#' Alignment, gene expression estimation, QC and initial analysis of RNAseq data\n#'\n#'\n#' @docType methods\n#' @name align_subjunc\n#' @rdname align_subjunc\n#'\n#' @author Thomas Carroll\n#' @param fastq File/s to align\n#' @param genome A character sting of index location\n#' @param params Parameters for subjunc aligner\n#' @return Path to Aligned data\n#' @import Rsamtools\n#' @export\nalign_subjunc <- function(fastq,genome,params){\n  message(\"Not ready yet!\")\n}\n\n\n#' Alignment using tomAlign\n#'\n#' Alignment, gene expression estimation, QC and initial analysis of RNAseq data\n#'\n#'\n#' @docType methods\n#' @name align_tomAlign\n#' @rdname align_tomAlign\n#'\n#' @author Thomas Carroll\n#' @param fastq File/s to align\n#' @param genome A character sting of index location\n#' @param params Parameters for subjunc aligner\n#' @return Path to Aligned data\n#' @import Rsamtools\n#' @export\nalign_tomAlign <- function(fastq,genome,params){\n  message(\"Not ready yet!\")\n}\n\n#' Alignment using hisat\n#'\n#' Alignment, gene expression estimation, QC and initial analysis of RNAseq data\n#'\n#'\n#' @docType methods\n#' @name align_hisat\n#' @rdname align_hisat\n#'\n#' @author Thomas Carroll\n#' @param fastq File/s to align\n#' @param genome A character sting of index location\n#' @param params Parameters for hisat aligner\n#' @return Path to Aligned data\n#' @import Rsamtools\n#' @export\nalign_hisat <- function(fastq,genome,params){\n  message(\"Not ready yet!\")\n}\n\n#' Alignment using tophat\n#'\n#' Alignment, gene expression estimation, QC and initial analysis of RNAseq data\n#'\n#'\n#' @docType methods\n#' @name align_tophat\n#' @rdname align_tophat\n#'\n#' @author Thomas Carroll\n#' @param fastq File/s to align\n#' @param genome A character sting of index location\n#' @param params Parameters for tophat aligner\n#' @return Path to Aligned data\n#' @import Rsamtools\n#' @export\nalign_tophat <- function(fastq,genome,params){\n  message(\"Not ready yet!\")\n}\n\nfqCopy <- function(fastq,fqsDir){\n  if(!file.exists(file.path(fqsDir,basename(fastq)))){\n    if(any(grepl(\"ftp|http|https|FTP|HTTP|HTTPS\",fastq))){\n      download.file(fastq,file.path(fqsDir,basename(fastq)))\n    }else{\n      file.copy(from=fastq,to=file.path(fqsDir,basename(fastq)))\n    }\n  }\n\n}\n\n\nmakePipeFileStructure <- function(referenceDir,baseDir,genome,mode=\"ChIP\"){\n  bamsDir <- file.path(baseDir,\"BAMs\")\n  fqsDir <- file.path(baseDir,\"FQs\")\n  peaksDir <- file.path(baseDir,\"Peaks\")\n  stdoutDir <- file.path(baseDir,\"stdout\")\n  stderrDir <- file.path(baseDir,\"stderr\")\n  motifDir <- file.path(baseDir,\"Motif\")\n  chipqcDir <- file.path(baseDir,\"ChIPQC\")\n  degDir <- file.path(baseDir,\"DE_Genes\")\n  bigWigsDir <- file.path(baseDir,\"bigWigs\")\n  countsDir <- file.path(baseDir,\"counts\")\n  statsDir <- file.path(baseDir,\"stats\")\n  if(!dir.exists(chipqcDir) & mode==\"ChIP\"){\n    message(chipqcDir,\" directory does not exist so creating now.\")\n    dir.create(chipqcDir,recursive = T,showWarnings = F)\n  }\n  if(!dir.exists(motifDir)){\n    message(motifDir,\" directory does not exist so creating now.\")\n    dir.create(motifDir,recursive = T,showWarnings = F)\n  }\n  if(!dir.exists(peaksDir) & mode==\"ChIP\"){\n    message(peaksDir,\" directory does not exist so creating now.\")\n    dir.create(peaksDir,recursive = T,showWarnings = F)\n  }\n  if(!dir.exists(degDir)){\n    message(degDir,\" directory does not exist so creating now.\")\n    dir.create(degDir,recursive = T,showWarnings = F)\n  }\n  if(!dir.exists(bigWigsDir)){\n    message(bigWigsDir,\" directory does not exist so creating now.\")\n    dir.create(bigWigsDir,recursive = T,showWarnings = F)\n  }\n  if(!dir.exists(statsDir)){\n    message(statsDir,\" directory does not exist so creating now.\")\n    dir.create(statsDir,recursive = T,showWarnings = F)\n  }\n  if(!dir.exists(countsDir)){\n    message(countsDir,\" directory does not exist so creating now.\")\n    dir.create(countsDir,recursive = T,showWarnings = F)\n  }\n  if(!dir.exists(referenceDir)){\n    message(referenceDir,\" directory does not exist so creating now.\")\n    dir.create(referenceDir,recursive = T,showWarnings = F)\n  }\n  if(!dir.exists(stderrDir)){\n    message(stderrDir,\" directory does not exist so creating now.\")\n    dir.create(stderrDir,recursive = T,showWarnings = F)\n  }\n  if(!dir.exists(stdoutDir)){\n    message(stdoutDir,\" directory does not exist so creating now.\")\n    dir.create(stdoutDir,recursive = T,showWarnings = F)\n  }\n  if(!dir.exists(bamsDir)){\n    message(bamsDir,\" directory does not exist so creating now.\")\n    dir.create(bamsDir,recursive = T,showWarnings = F)\n  }\n  if(!dir.exists(fqsDir)){\n    message(fqsDir,\" directory does not exist so creating now.\")\n    dir.create(fqsDir,recursive = T,showWarnings = F)\n  }\n  return(c(bamsDir=bamsDir,chipqcDir=chipqcDir,degDir=degDir,bigWigsDir=bigWigsDir,statsDir=statsDir,countsDir=countsDir,\n           motifDir=motifDir,fqsDir=fqsDir,peaksDir=peaksDir,stdoutDir=stdoutDir,stderrDir=stderrDir,\n           referenceDir=referenceDir))\n}\n\nalignRNAseq <- function(x,name,index,bamPath,nTH=10,pOff=33){\n  require(Rsubread)\n  require(Rsamtools)\n  k <- x\n  if(grepl(\";\",k)){\n    kAll <- unlist(strsplit(k,\";\"))\n    k <- kAll[1]\n    k2 <- kAll[2]\n  }else{\n    k2 <- NULL\n  }\n  name <- name[x]\n  print(name)\n  if(!file.exists(file.path(bamPath,paste0(name,\".bam\")))){\n    # align(index,readfile1=k,readfile2=k2,output_file = file.path(bamPath,paste0(name,\".bam\")),\n    #       nthreads=nTH,\n    #       type=0,\n    #       phredOffset=pOff)\n    subjunc(index,readfile1=k,readfile2=k2,output_file = file.path(bamPath,paste0(name,\".bam\")),\n            nthreads=nTH,\n            phredOffset=pOff)\n  }\n  if(!file.exists(file.path(bamPath,paste0(\"Sorted_\",name,\".bam\")))){\n    sortBam(file=file.path(bamPath,paste0(name,\".bam\")),\n            destination = file.path(bamPath,paste0(\"Sorted_\",name)))\n  }\n  if(!file.exists(file.path(bamPath,paste0(\"Sorted_\",name,\".bam.bai\")))){\n    indexBam(file.path(bamPath,paste0(\"Sorted_\",name,\".bam\")))\n  }\n}\n\n\nalignDNAseq <- function(x,name,index,bamPath,nTH=10,pOff=33){\n  require(Rsubread)\n  require(Rsamtools)\n  k <- x\n  if(grepl(\";\",k)){\n    kAll <- unlist(strsplit(k,\";\"))\n    k <- kAll[1]\n    k2 <- kAll[2]\n  }else{\n    k2 <- NULL\n  }\n  name <- name[x]\n  print(name)\n  if(!file.exists(file.path(bamPath,paste0(\"Sorted_\",name,\".bam\")))){\n    if(!file.exists(file.path(bamPath,paste0(name,\".bam\")))){\n      print(k)\n      align(index,readfile1=k,readfile2=k2,output_file = file.path(bamPath,paste0(name,\".bam\")),\n            nthreads=nTH,\n          type=1,\n            phredOffset=pOff,unique=FALSE,minFragLength = 0,maxFragLength = 2000)\n    }\n    if(!file.exists(file.path(bamPath,paste0(\"Sorted_\",name,\".bam\")))){\n      sortBam(file=file.path(bamPath,paste0(name,\".bam\")),\n              destination = file.path(bamPath,paste0(\"Sorted_\",name)))\n    }\n    if(!file.exists(file.path(bamPath,paste0(\"Sorted_\",name,\".bam.bai\")))){\n      indexBam(file.path(bamPath,paste0(\"Sorted_\",name,\".bam\")))\n    }\n  }\n}\n\nkmerCountRNAseq <- function(x,name,index,countPath,nTH=1,pOff=33,salmonCMD=\"salmon\"){\n  name <- name[x]\n  #message(file.path(countPath,paste0(name),\"quant.sf\"))\n  if(!file.exists(file.path(countPath,paste0(name),\"quant.sf\"))){\n    require(tximport)\n    k <- x\n    k2 <- NULL\n    if(grepl(\";\",k)){\n      kAll <- unlist(strsplit(k,\";\"))\n      k <- kAll[1]\n      k2 <- kAll[2]\n    }else{\n      k2 <- NULL\n    }\n    READS <- ifelse(is.null(k2),paste0(\"-r\",k),paste0(\"-1 \",k,\" -2 \",k2))\n    print(k)\n    print(k2)\n    salmonArgs <- paste(\"quant -i\",index,\"-l a\",READS,\"-o\",file.path(countPath,paste0(name)))\n    salmonCall <- paste(salmonCMD,salmonArgs)\n    #if(!file.exists(file.path(bamPath,paste0(name,\".bam\")))){\n    print(salmonCall)\n    system(salmonCall)\n    #}\n  }\n}\n\ngenerateFeatureCountsPeaks <- function(x,name,PeakSets,countPath,statsPath,nTH=1,strand=\"un\",readExtension5=0,read2pos=NULL){\n  if(strand==\"un\"){strand <- 0}\n  if(strand==\"fs\"){strand <- 1}\n  if(strand==\"ss\"){strand <- 2}\n\n  name <- names(name)[x]\n  PeakSet <- PeakSets[[x]]\n  if(length(readExtension5)>1){\n    readExtension5 <- readExtension5[x]\n  }\n  \n  require(tximport)\n  require(Rsubread)\n  bamFile <- name\n  dir.create(file.path(countPath,gsub(\"_Consensus\",\"\",names(PeakSets)[x])),showWarnings = FALSE,recursive = TRUE)\n  outputFile <- file.path(countPath,gsub(\"_Consensus\",\"\",names(PeakSets)[x]),gsub(\"\\\\.bam\",paste0(\"_subread_Peak_\",names(PeakSets)[x],\".Counts\"),basename(bamFile)))\n  print(outputFile)\n  if(!file.exists(outputFile)){\n    fcG <- featureCounts(files=bamFile,annot.ext = PeakSet,\n                         useMetaFeatures = TRUE,strandSpecific = strand,\n                         isPairedEnd = FALSE,readExtension5 = readExtension5,read2pos = read2pos)\n    res_fCounts <- list(GeneLevel=fcG)\n    write.table(cbind(res_fCounts$GeneLevel$annotation$GeneID,res_fCounts$GeneLevel$counts),\n                row.names = F,file=outputFile,sep=\"\\t\",quote=F)\n    save(res_fCounts,file=gsub(\"\\\\.Counts\",\"\\\\.RData\",outputFile))\n    return(res_fCounts)\n  }\n}\n\n\ngenerateFeatureCounts <- function(x,name,gtf,disjointGTF,countPath,statsPath,nTH=1,strand=\"un\",PE=FALSE){\n  if(strand==\"un\"){strand <- 0}\n  if(strand==\"fs\"){strand <- 1}\n  if(strand==\"ss\"){strand <- 2}\n  name <- name[x]\n  PE <- PE[name]\n  require(tximport)\n  require(Rsubread)\n  bamFile <- x\n  gtf <- gsub(\"gtf\\\\.gz$\",\"gtf\",gtf)\n  outputFile <- file.path(countPath,gsub(\"\\\\.bam\",\"_subread_Gene.Counts\",basename(bamFile)))\n  if(!file.exists(outputFile)){\n    outputFileExons <- file.path(countPath,gsub(\"\\\\.bam\",\"_subread_Gene.Counts\",basename(bamFile)))\n    fcG <- featureCounts(files=bamFile,isGTFAnnotationFile = TRUE,annot.ext = gtf,\n                         useMetaFeatures = TRUE,strandSpecific = strand,\n                         isPairedEnd = PE)\n    fcE <- featureCounts(files=bamFile,isGTFAnnotationFile = TRUE,annot.ext = disjointGTF,\n                         useMetaFeatures = FALSE,strandSpecific = strand,\n                         isPairedEnd = PE)\n    res_fCounts <- list(GeneLevel=fcG,ExonLevel=fcE)\n    write.table(cbind(res_fCounts$GeneLevel$annotation$GeneID,res_fCounts$GeneLevel$counts),\n                row.names = F,file=outputFile,sep=\"\\t\",quote=F)\n    write.table(res_fCounts$GeneLevel$stat,\n                row.names = F,file=file.path(statsPath,gsub(\"\\\\.Counts\",\"\\\\.Stats\",basename(outputFile))),sep=\"\\t\",quote=F)\n    ExonLevel <- cbind(res_fCounts$ExonLevel$annotation$GeneID,paste(res_fCounts$ExonLevel$annotation$Chr,res_fCounts$ExonLevel$annotation$Start,res_fCounts$ExonLevel$annotation$End,sep=\"_\"),res_fCounts$ExonLevel$counts)\n    write.table(ExonLevel,\n                row.names = F,file=file.path(countPath,gsub(\"\\\\.Counts\",\"\\\\.ExonCounts\",basename(outputFile))),sep=\"\\t\",quote=F)\n\n    save(res_fCounts,file=gsub(\"\\\\.Counts\",\"\\\\.RData\",outputFile))\n    return(res_fCounts)\n  }\n}\ngetPairedFragmentLength <- function(x,name,statsDir){\n  name <- name[x]\n  bamFile <- x\n  if(!file.exists(file.path(statsDir,gsub(\"\\\\.bam\",\"_FragDist\\\\.bam\",basename(bamFile))))){\n    require(GenomicAlignments)\n    require(Rsamtools)\n    test <- readGAlignmentPairs(bamFile,param=ScanBamParam(flag=scanBamFlag(isProperPair=TRUE),what=c(\"flag\",\"isize\")))\n    toPlotreads <- first(test)\n    toPlotPosIsize <- mcols(toPlotreads[strand(toPlotreads) == \"+\"])$isize\n    toPlotNegIsize <- abs(mcols(toPlotreads[strand(toPlotreads) == \"-\"])$isize)\n    toPlot <- table(c(toPlotPosIsize,toPlotNegIsize))\n    write.table(data.frame(toPlot),file.path(statsDir,gsub(\"\\\\.bam\",\"_FragDist\\\\.bam\",basename(bamFile))))\n  }\n}\n\nexportNormalisedBW <- function(x,name,bigWigPath,normaliseTo=\"RPM\"){\n  name <- name[x]\n  bamFile <- x\n  bigWigFile_prefix <- file.path(bigWigPath,gsub(\"\\\\.bam\",\"\",basename(bamFile)))\n  if(!file.exists(paste0(bigWigFile_prefix,\"Neg.bw\"))\n     | !file.exists(paste0(bigWigFile_prefix,\"Pos.bw\"))\n     | !file.exists(paste0(bigWigFile_prefix,\"Full.bw\"))\n     | !file.exists(paste0(bigWigFile_prefix,\"FullNormalisedRPM.bw\"))){\n    require(GenomicAlignments)\n    require(rtracklayer)\n    #library(QuasR)\n    message(\"Reading tags from \",bamFile,appendLF=FALSE)\n    total <- readGAlignments(bamFile)\n    message(\"..done\")\n    totalReadNumber <- length(total)\n    message(\"Read in \",length(total),\" reads\")\n    gc()\n    if(!file.exists(paste0(bigWigFile_prefix,\"Pos.bw\"))\n       | !file.exists(paste0(bigWigFile_prefix,\"Full.bw\"))\n       | !file.exists(paste0(bigWigFile_prefix,\"FullNormalisedRPM.bw\"))){\n      message(\"Calculating coverage of positive strand..\",appendLF=FALSE)\n      genomeCovPos <- coverage(total[strand(total) == \"+\"])\n      message(\"Writing coverage to bigwigs..\",appendLF=FALSE)\n      export.bw(genomeCovPos,paste0(bigWigFile_prefix,\"Pos.bw\"))\n      message(\"..done\")\n    }\n    if(!file.exists(paste0(bigWigFile_prefix,\"Neg.bw\"))\n       | !file.exists(paste0(bigWigFile_prefix,\"Full.bw\"))\n       | !file.exists(paste0(bigWigFile_prefix,\"FullNormalisedRPM.bw\"))){\n      message(\"Calculating coverage of negative strand..\",appendLF=FALSE)\n      genomeCovNeg <- coverage(total[strand(total) == \"-\"])\n      message(\"Writing coverage to bigwigs..\",appendLF=FALSE)\n      export.bw(genomeCovNeg,paste0(bigWigFile_prefix,\"Neg.bw\"))\n      message(\"..done\")\n    }\n    if(!file.exists(paste0(bigWigFile_prefix,\"Full.bw\"))\n       | !file.exists(paste0(bigWigFile_prefix,\"FullNormalisedRPM.bw\"))){\n      message(\"Aggregating coverage of both strand..\",appendLF=FALSE)\n      genomeCovFull <- genomeCovNeg+genomeCovPos\n      message(\"Writing coverage to bigwigs..\",appendLF=FALSE)\n      export.bw(genomeCovFull,paste0(bigWigFile_prefix,\"Full.bw\"))\n      message(\"..done\")\n    }\n    if(!file.exists(paste0(bigWigFile_prefix,\"FullNormalisedRPM.bw\"))){\n      message(\"Normalising(zing for you Americans :) ) coverage..\",appendLF=FALSE)\n      genomeCovNorm <- (genomeCovFull/totalReadNumber)*1000000\n      message(\"..done\")\n      message(\"Writing normalised coverage to bigwig..\",appendLF=FALSE)\n      export.bw(genomeCovNorm,paste0(bigWigFile_prefix,\"FullNormalisedRPM.bw\"))\n      message(\"..done\")\n    }\n  }\n}\n\nexportNormalisedBW_DNA <- function(x,name,bigWigPath,qcList,normaliseTo=\"Total\"){\n  require(GenomicAlignments)\n  require(rtracklayer)\n  require(ChIPQC)\n  name <- name[x]\n  bamFile <- x\n  if(!file.exists(file.path(bigWigPath,gsub(\"\\\\.bam\",\"Normalised\\\\.bw\",basename(bamFile))))){\n    #library(QuasR)\n    name <- name[x]\n    bamFile <- x\n    total <- readGAlignments(bamFile)\n    message(\"Reading tags from \",bamFile,appendLF=FALSE)\n    #totalReads <- alignmentStats(bamFile)[,\"mapped\"]\n    qc <- qcList[[name]]\n    if(class(qc) == \"ChIPQCsample\"){\n      if(normaliseTo == \"blacklisted\"){\n        totalReads <- qc@FlagAndTagCounts[\"MapQPass\"] - qc@CountsInFeatures$BlackList\n      }\n      if(normaliseTo == \"Total\"){\n        totalReads <- qc@FlagAndTagCounts[\"Mapped\"]\n      }\n      if(normaliseTo == \"UniqueTotal\"){\n        totalReads <- qc@FlagAndTagCounts[\"Mapped\"]-qc@FlagAndTagCounts[\"Duplicates\"]\n      }\n  \n  \n        extendBy <- ChIPQC::fragmentlength(qc)\n    }else{\n      extendBy <- ceiling(mean(width(total))) \n      totalReads <- length(total)\n    }\n    message(\"..done\")\n    message(\"Read in \",length(total),\" reads\")\n    message(\"Extending reads to fragmentlength of \",extendBy,\" ..\",appendLF=FALSE)\n    temp <- resize(as(total,\"GRanges\"),extendBy,\"start\")\n    message(\"..done\")\n    rm(total)\n    gc()\n    message(\"Calculating coverage..\",appendLF=FALSE)\n    genomeCov <- coverage(temp)\n    rm(temp)\n    message(\"..done\")\n\n    message(\"Normalised coverage..\",appendLF=FALSE)\n    genomeCov <- (genomeCov/totalReads)*1000000\n    message(\"..done\")\n    message(\"Exporting coverage..\",appendLF=FALSE)\n    export.bw(genomeCov,file.path(bigWigPath,gsub(\"\\\\.bam\",\"Normalised\\\\.bw\",basename(bamFile))))\n    message(\"..done\")\n  }\n}\n\nalignmentStats <- function(x,name,statsPath){\n  library(Rsubread)\n  name <- name[x]\n  bamFile <- x\n  alignmentStats_rsubread <- file.path(statsPath,gsub(\"Sorted_|\\\\.bam\",\"\",basename(bamFile)))\n  if(!file.exists(alignmentStats_rsubread)){\n    res <- propmapped(bamFile)\n    #total <- readGAlignments(bamFile)\n    write.table(res,alignmentStats_rsubread,sep=\"\\t\",row.names=F,quote=F)\n    return(res)\n  }\n  NULL\n}\n\ncoverageByTranscriptFromBAM <- function(x,name,gtfReduced){\n\n  name <- name[x]\n  bamFile <- x\n  outCBG <- gsub(\"\\\\.bam$\",\"CoverageOfGenes.txt\",bamFile)\n  if(!file.exists(outCBG)){\n    #library(TxDb.Hsapiens.UCSC.hg19.knownGene)\n    library(Rsamtools)\n    library(GenomicFeatures)\n    library(GenomicAlignments)\n\n    #txdb <- makeTxDbFromGFF(\"~/Projects/Results/RNAseqPipeTest/RNARefDir/TxDb.Hsapiens.UCSC.hg19.knownGene.gtf\")\n    txdb <- makeTxDbFromGFF(gtfReduced)\n    exT <- exonsBy(txdb,by = \"gene\")\n    #res <- readGAlignments(\"~/Projects/Results/RNAseqPipeTest/FirstTest/BAMs/Sorted_GM12878_1.bam\")\n    res <- readGAlignments(bamFile)\n    test <- coverageByTranscript(res,exT)\n    temo <- sapply(test,function(x)spline(x,n=100)$y)\n    temo2 <- (apply(temo,1,mean,trim=0.01)/length(res))*10^6\n    coverageFrame <- data.frame(Pos=seq_len(100),MeanCoverage=temo2)\n    #save(temo,file=gsub(\"\\\\.bam$\",\"Profile\\\\.RData\",bam))\n    write.table(coverageFrame,file=outCBG)\n    save(temo,file=gsub(\"\\\\.bam$\",\"ProfileLine\\\\.RData\",bamFile))\n  }\n}\n\n\n# bamFile <- \"~/Projects/Results/RNAseqPipeTest/FirstTest/BAMs/GM12878_1.bam\"\n# statsDir <- \"~/Projects/Results/RNAseqPipeTest/FirstTest/stats/\"\nsimpleAlignmentStats <- function(x,name,statsDir){\n  require(Rsamtools)\n  name <- name[x]\n  bamFile <- x\n  flagOut <- file.path(statsDir,gsub(\"\\\\.bam\",\"\\\\.FlagStat\",basename(bamFile)))\n  mapqOut <- file.path(statsDir,gsub(\"\\\\.bam\",\"\\\\.mapqStat\",basename(bamFile)))\n  if(!file.exists(flagOut) | !file.exists(mapqOut)){\n    Param <- ScanBamParam(what=c(\"flag\",\"mapq\"))\n    bamFlags <- scanBam(bamFile, param=Param)\n    flag6 <- bamFlags[[1]][[\"flag\"]]\n    flagCounts <- colSums(bamFlagAsBitMatrix(flag6))\n    flagCounts <- data.frame(Group=names(flagCounts),Freq=unname(flagCounts))\n    mapqCounts <- as.data.frame(table(bamFlags[[1]][[\"mapq\"]]))\n    colnames(mapqCounts)[1] <- \"MapQ\"\n    write.table(flagCounts,flagOut,sep=\",\",quote=FALSE,row.names=FALSE)\n    write.table(mapqCounts,mapqOut,sep=\",\",quote=FALSE,row.names = FALSE)\n  }\n}\n\n# contrastName <- contrastVector[[1]]\n# ddsObject <- dds\nhasDEseq2Reps <- function(object, modelMatrix=NULL){\n  if (!.hasSlot(object, \"rowRanges\")) \n    object <- updateObject(object)\n  noReps <- if (is.null(modelMatrix)) {\n    mmtest <- DESeq2:::getModelMatrix(object)\n    nrow(mmtest) == ncol(mmtest)\n  }\n  else {\n    nrow(modelMatrix) == ncol(modelMatrix)\n  }\n  if (noReps) {\n    return(FALSE)\n  }\n  return(TRUE)\n}\n\ncallDESeq2Results <- function(contrastName,ddsObject,DEGdir,id2SymbolFile,parallelR){\n  #library(org.Hs.eg.db)\n  #message(c(\"Group\",contrastName[[1]],contrastName[[2]]))\n  id2symbol <- read.delim(id2SymbolFile,sep=\"\\t\",header=FALSE)\n  #message(c(\"Group\",contrastName[[1]],contrastName[[2]]))\n  myRes <- data.frame(results(ddsObject,contrast = c(\"Group\",contrastName[[1]],contrastName[[2]]),parallel = parallelR))\n  myRes <- data.frame(Name=rownames(myRes),myRes)\n  myRes <- merge(id2symbol,myRes,by=1,all.x=FALSE,all.y=TRUE)\n  myRes <- myRes[order(myRes$padj,decreasing = F),]\n  ## FIX THIS Need to work for all organisms...\n  # Symbol <- unname(unlist(AnnotationDbi::mget(as.character(myRes$Name),org.Hs.egSYMBOL,ifnotfound=NA)))\n  # myRes <- data.frame(Name=myRes$Name,Symbol=Symbol,myRes[,-1])\n\n  write.table(myRes,file=file.path(DEGdir,paste0(paste(c(\"Group\",contrastName[[1]],\"minus\",contrastName[[2]]),collapse=\"_\"),\"DEG.xls\")),row.names = F,quote=F,sep=\"\\t\")\n}\n\n\ncallDESeq2ResultsChIP <- function(contrastName,ddsObject,DEGdir,countDir,parallelR){\n  dir.create(DEGdir,showWarnings = FALSE,recursive = TRUE)\n  if(hasDEseq2Reps(ddsObject)){\n  myRes <- data.frame(results(ddsObject,contrast = c(\"Group\",make.names(contrastName[[1]]),make.names(contrastName[[2]])),parallel = parallelR))\n  myRes <- data.frame(Name=rownames(myRes),myRes)\n  toCombine <- cbind(counts(ddsObject,normalized=FALSE),counts(ddsObject,normalized=TRUE))\n  #myRes <- myRes[order(myRes$padj,decreasing = F),]\n  myRes <- data.frame(IDs=rownames(myRes),myRes)\n  myRes <- merge(myRes,toCombine,by.x=1,by.y=0,all=FALSE)\n  myRes <- myRes[order(myRes$padj,decreasing = F),]\n  ## FIX THIS Need to work for all organisms...\n  # Symbol <- unname(unlist(AnnotationDbi::mget(as.character(myRes$Name),org.Hs.egSYMBOL,ifnotfound=NA)))\n  # myRes <- data.frame(Name=myRes$Name,Symbol=Symbol,myRes[,-1])\n  write.table(myRes,file=file.path(DEGdir,paste0(paste(c(basename(countDir),\"_\",\"Group\",contrastName[[1]],\"minus\",contrastName[[2]]),collapse=\"_\"),\"DEG.xls\")),row.names = F,quote=F,sep=\"\\t\")\n  }\n}\n\n\ncallDEXSeqResults <- function(contrastName,countsObject,sampleTable,tx2geneCompare,DEGdir,id2SymbolFile,parallelR){\n  require(DEXSeq)\n  ourCounts <- countsObject\n  groupData <- sampleTable[sampleTable$Group == contrastName[[1]] | sampleTable$Group == contrastName[[2]],,drop=FALSE]\n  groupCounts <- ourCounts[,colnames(ourCounts) %in% rownames(groupData)]\n  dxd <- DEXSeqDataSet(countData = ceiling(groupCounts),\n                       sampleData = groupData,\n                       design = ~ sample + exon + Group:exon,\n                       featureID = rownames(groupCounts),\n                       groupID = as.character(tx2geneCompare[match(rownames(groupCounts),tx2geneCompare$TXNAME),\"GENEID\"]))\n  dxd <- estimateSizeFactors(dxd)\n  dxd <- estimateDispersions(dxd, fitType=\"local\")\n  dxd <- testForDEU(dxd, reducedModel = ~ sample + exon)\n  #save(dxd,file=\"dxdCaseStudySimulationEvaluation.RData\")\n  dxr <- DEXSeqResults(dxd)\n  dxr <- dxr[order(dxr$pvalue),]\n  qvalDxr <- data.frame(perGeneQValue=perGeneQValue(dxr))\n  dxrDF <- merge(data.frame(as.data.frame(dxr)),qvalDxr,by.x=1,by.y=0)\n  dxrDF <- dxrDF[order(dxrDF$perGeneQValue,dxrDF$pvalue),]\n  \n  id2symbol <- read.delim(id2SymbolFile,sep=\"\\t\",header=FALSE)\n  #message(c(\"Group\",contrastName[[1]],contrastName[[2]]))\n  myRes <- merge(id2symbol,dxrDF,by=1,all.x=FALSE,all.y=TRUE)\n  myRes <- myRes[order(myRes$perGeneQValue,myRes$pvalue,decreasing = F),]\n  ## FIX THIS Need to work for all organisms...\n  # Symbol <- unname(unlist(AnnotationDbi::mget(as.character(myRes$Name),org.Hs.egSYMBOL,ifnotfound=NA)))\n  # myRes <- data.frame(Name=myRes$Name,Symbol=Symbol,myRes[,-1])\n  \n  write.table(myRes,file=file.path(DEGdir,paste0(paste(c(\"Group\",contrastName[[1]],\"minus\",contrastName[[2]]),collapse=\"_\"),\"DTU.xls\")),row.names = F,quote=F,sep=\"\\t\")\n  \n  \n}\n\n\ncallGOfromDEG <- function(DEResFile,topGOmapping,DEGdir){\n  #\n  #   myRes <- data.frame(results(ddsObject,name = contrastName,parallel = parallelR))\n  #   myRes <- data.frame(Name=rownames(myRes),myRes)\n  #   myRes <- myRes[order(myRes$padj,decreasing = F),]\n  #   ## FIX THIS need to work for all organisms....\n  #   Symbol <- unname(unlist(AnnotationDbi::mget(as.character(myRes$Name),org.Hs.egSYMBOL,ifnotfound=NA)))\n  #   myRes <- data.frame(Name=myRes$Name,Symbol=Symbol,myRes[,-1])\n  #\n  #   write.table(myRes,file=file.path(DEGdir,paste0(contrastName,\"DEG.xls\")),row.names = F,quote=F,sep=\"\\t\")\n  require(GO.db)\n  require(topGO)\n  # DEResFile <- \"~/Projects/Results/RNAseqPipeTest/FirstTest/DE_Genes/Group_HeLa_vs_GM12878DEG.xls\"\n  # topGOmapping <- \"~/Projects/Results/RNAseqPipeTest/RNARefDir/org.Hs.eg_GOAnnoforTopGO.txt\"\n  goOut <- file.path(DEGdir,paste0(gsub(\"DEG\\\\.xls\",\"\",basename(DEResFile)),\"\",\"_BP_\",\"GoTable.csv\",sep=\"\"))\n  if(!file.exists(goOut)){\n    DEGres <- read.delim(DEResFile,sep=\"\\t\")\n    #message(\"done\")\n    print(topGOmapping)\n    mappingForTopGO <- readMappings(topGOmapping)\n    #message(\"done\")\n\n    DEResAllIDs <- as.vector(DEGres$V1)\n    DEResSigIDs <- as.vector(DEGres$V1[DEGres$padj < 0.05 & !is.na(DEGres$padj)])\n\n    DoGo(list(Sig=DEResSigIDs),list(DEResAllIDs),mappingForTopGO,goOut,DEGdir)\n  }\n\n}\n\n# sampleSheet <- read.delim(\"/Users/tcarroll/Projects/Software/Github/rnaPipeR/inst/extdata/SampleSheet2.csv\",sep=\",\")\n# genesToTx <- \"/Users/tcarroll/Projects/Results/RNAseqPipeTest/RNARefDir/TxDb.Hsapiens.UCSC.hg19.knownGene_tx2gene.csv\"\n# countDir <- \"/Users/tcarroll/Projects/Results/RNAseqPipeTest/FirstTest/counts/\"\n# DEGdir <- \"/Users/tcarroll/Projects/Results/RNAseqPipeTest/FirstTest/DE_Genes/\"\n# id2SymbolFile <- \"/Users/tcarroll/Projects/Results/RNAseqPipeTest/RNARefDir/org.Hs.eg_ID2Symbol.txt\"\n# parallelR=FALSE\n\n\nrunDESeq2 <- function(sampleSheet,genesToTx,countDir,DEGdir,id2SymbolFile,parallelR=FALSE){\n\n  require(tximport)\n  require(DESeq2)\n\n  files <- file.path(countDir,sampleSheet$GenomicsID,\"quant.sf\")\n  metadata <- dplyr::select(sampleSheet,-GenomicsID,-FQLocation,-InputToUse,-toMerge,-BroadCall)\n  group <- gsub(\"_+$\",\"\",apply(metadata,1,paste,sep=\"_\",collapse=\"_\"))\n  names(files) <- basename(dirname(files))\n  tx2geneCompare <- read.delim(genesToTx,h=T,sep=\",\")\n  txi.salmon <- tximport(files, type = \"salmon\", tx2gene = tx2geneCompare)\n  sampleTable <- data.frame(Group = factor(group))\n  rownames(sampleTable) <- colnames(txi.salmon$counts)\n  dds <- DESeqDataSetFromTximport(txi.salmon, sampleTable, ~Group)\n\n  dds <- DESeq(dds,parallel = parallelR)\n  save(dds,file=file.path(DEGdir,\"dds.RData\"))\n  toPlot <- rlog(dds)\n  save(toPlot,file=file.path(DEGdir,\"rloggedData.RData\"))\n  #plotPCA(toPlot,intgroup=\"Group\")\n\n  # AllComparisons <- unique(combn(group,2,FUN = function(x)paste(x,collapse=\"_\"),simplify = T))\n  # AllComparisons <- unique(combn(group,2,simplify = T))\n  # AllComparisons <- AllComparisons[,!AllComparisons[1,] == AllComparisons[2,]]\n  # pairWiseComparison <- paste(AllComparisons[1,],AllComparisons[2,],sep=\"Vs\")\n  # AllComparisons <- AllComparisons[,match(unique(pairWiseComparison),pairWiseComparison),drop=F]\n  # pairWiseComparison <- pairWiseComparison[match(unique(pairWiseComparison),pairWiseComparison)]\n  # allComparisonList <- unlist(apply(AllComparisons,2,function(x)list(x)),recursive = F)\n  # names(allComparisonList) <- pairWiseComparison\n\n  # contrastVector <- resultsNames(dds)\n  # contrastVector <- contrastVector[contrastVector != \"Intercept\"]\n  contrastsFile <- file.path(DEGdir,\"Contrasts.txt\")\n  if(!file.exists(contrastsFile)){\n    kl <- expand.grid(colData(dds)$Group,\n                      colData(dds)$Group)\n    kl <- kl[kl[,1] != kl[,2],,drop=FALSE]\n    kl <- t(apply(kl,1,sort))\n    kl <- kl[!duplicated(paste(kl[,1],kl[,2],sep=\"_\")),,drop=FALSE]\n    write.table(kl,contrastsFile,sep=\"\\t\",quote=FALSE,row.names=FALSE,col.names=FALSE)\n  }else{\n    kl <- read.delim(contrastsFile,sep=\"\\t\",header=FALSE)\n  }\n  #contrastVector <- paste0(\"Group_\",kl[,1],\"_vs_\",kl[,2])\n  contrastVector <- apply(kl,1,function(x)as.list(x))\n  DEseq2Res <- lapply(contrastVector,callDESeq2Results,ddsObject=dds,DEGdir=DEGdir,parallelR=parallelR,id2SymbolFile=id2SymbolFile)\n  names(DEseq2Res) <- contrastVector\n  return(DEseq2Res)\n}\n\n\nrunDESeq2ChIP <- function(sampleSheet,countDir,DEGdir,parallelR=FALSE){\n  require(tximport)\n  require(DESeq2)\n  \n  files <- dir(countDir,pattern=paste0(\".Counts\"),full.names = TRUE)\n  names(files) <- gsub(\"_subread_Peak.*|Sorted_\",\"\",basename(files))\n  countsFiles <- files\n  #do.call(cbind,list(countsFiles))\n  ans <- list()\n  rownamesToBe <- read.delim(countsFiles[1],sep=\"\\t\",h=F)[,1]\n  for(i in 1:length(countsFiles)){\n    ans[[i]] <- read.delim(countsFiles[i],sep=\"\\t\",h=F)[,2]\n  }\n  fullCounts <- do.call(cbind,ans)\n  rownames(fullCounts) <- rownamesToBe\n  colnames(fullCounts) <- gsub(\"\\\\.Counts\",\"\",names(files))\n  sampleSheet <- sampleSheet[match(colnames(fullCounts),sampleSheet$GenomicsID),]\n  if(grepl(\"^Antibody_\",basename(countDir))){\n    antibodyToFilter <- gsub(\"^Antibody_\",\"\",basename(countDir))\n    sampleSheet <- sampleSheet[sampleSheet$Antibody %in% antibodyToFilter,]\n    fullCounts <- fullCounts[,colnames(fullCounts) %in% sampleSheet$GenomicsID]\n  }\n  \n  \n  metadata <- dplyr::select(sampleSheet,-GenomicsID,-FQLocation,-InputToUse,-toMerge,-BroadCall)\n  group <- gsub(\"_+$\",\"\",apply(metadata,1,paste,sep=\"_\",collapse=\"_\"))\n  #names(files) <- basename(dirname(files))\n  \n  sampleTable <- data.frame(Group = factor(make.names(group)))\n  rownames(sampleTable) <- colnames(fullCounts)\n  \n  dds <- DESeqDataSetFromMatrix(fullCounts, sampleTable, ~Group)\n  \n  dds <- DESeq(dds,parallel = parallelR)\n  save(dds,file=file.path(DEGdir,\"dds.RData\"))\n  toPlot <- rlog(dds)\n  save(toPlot,file=file.path(DEGdir,\"rloggedData.RData\"))\n  #plotPCA(toPlot,intgroup=\"Group\")\n  \n  # AllComparisons <- unique(combn(group,2,FUN = function(x)paste(x,collapse=\"_\"),simplify = T))\n  # AllComparisons <- unique(combn(group,2,simplify = T))\n  # AllComparisons <- AllComparisons[,!AllComparisons[1,] == AllComparisons[2,]]\n  # pairWiseComparison <- paste(AllComparisons[1,],AllComparisons[2,],sep=\"Vs\")\n  # AllComparisons <- AllComparisons[,match(unique(pairWiseComparison),pairWiseComparison),drop=F]\n  # pairWiseComparison <- pairWiseComparison[match(unique(pairWiseComparison),pairWiseComparison)]\n  # allComparisonList <- unlist(apply(AllComparisons,2,function(x)list(x)),recursive = F)\n  # names(allComparisonList) <- pairWiseComparison\n  \n  # contrastVector <- resultsNames(dds)\n  # contrastVector <- contrastVector[contrastVector != \"Intercept\"]\n  contrastsFile <- file.path(DEGdir,\"Contrasts.txt\")\n  if(!file.exists(contrastsFile)){\n    ToExpand <- as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))\n    kl <- expand.grid(ToExpand,\n                      ToExpand)\n    kl <- kl[kl[,1] != kl[,2],,drop=FALSE]\n    kl <- t(apply(kl,1,sort))\n    kl <- kl[!duplicated(paste(kl[,1],kl[,2],sep=\"_\")),,drop=FALSE]\n    write.table(kl,contrastsFile,sep=\"\\t\",quote=FALSE,row.names=FALSE,col.names=FALSE)\n  }else{\n    kl <- read.delim(contrastsFile,sep=\"\\t\",header=FALSE)\n  }\n  #contrastVector <- paste0(\"Group_\",kl[,1],\"_vs_\",kl[,2])\n  contrastVector <- apply(kl,1,function(x)as.list(x))\n  DEseq2Res <- lapply(contrastVector,callDESeq2ResultsChIP,ddsObject=dds,DEGdir=DEGdir,countDir=countDir,parallelR=parallelR)\n  \n  names(DEseq2Res) <- contrastVector\n  return(DEseq2Res)\n}\n\n\nrunDESeq2ChIP2 <- function(sampleSheet,countDir,DEGdir,parallelR=FALSE){\n  # sampleSheet <- newAnalysis\n  # countDir <- file.path(countsDir,basename(consensusPeakCountDirs[i]))\n  # DEGdir <- file.path(degDir,basename(consensusPeakCountDirs[i]))\n  # parallelR=FALSE\n  require(tximport)\n  require(DESeq2)\n  DEseq2Res <- list()\n  if(!file.exists(file.path(DEGdir,\"dds.RData\"))){\n    files <- dir(countDir,pattern=paste0(\".Counts\"),full.names = TRUE)\n    names(files) <- gsub(\"_subread_Peak.*|Sorted_\",\"\",basename(files))\n    countsFiles <- files\n    #do.call(cbind,list(countsFiles))\n    ans <- list()\n    rownamesToBe <- read.delim(countsFiles[1],sep=\"\\t\",h=F,skip=1)[,1]\n    for(i in 1:length(countsFiles)){\n      ans[[i]] <- read.delim(countsFiles[i],sep=\"\\t\",h=F,skip = 1)[,2]\n    }\n    fullCounts <- do.call(cbind,ans)\n    rownames(fullCounts) <- rownamesToBe\n    colnames(fullCounts) <- gsub(\"\\\\.Counts\",\"\",names(files))\n    sampleSheet <- sampleSheet[match(colnames(fullCounts),sampleSheet$GenomicsID),]\n    \n    \n    metadata <- dplyr::select(sampleSheet,-GenomicsID,-FQLocation,-InputToUse,-toMerge,-BroadCall)\n    group <- gsub(\"_+$\",\"\",apply(metadata,1,paste,sep=\"_\",collapse=\"_\"))\n    #names(files) <- basename(dirname(files))\n    \n    sampleTable <- data.frame(Group = factor(make.names(group)))\n    rownames(sampleTable) <- colnames(fullCounts)\n    dds <- DESeqDataSetFromMatrix(fullCounts, sampleTable, ~Group)\n    dds <- DESeq(dds,parallel = FALSE)\n    dir.create(DEGdir,showWarnings = FALSE)\n    save(dds,file=file.path(DEGdir,\"dds.RData\"))\n    toPlot <- rlog(dds)\n    save(toPlot,file=file.path(DEGdir,\"rloggedData.RData\"))\n    \n    \n    \n    \n    uniqueAntibodies <- unique(sampleSheet$Antibody)\n    # if(grepl(\"^Antibody_\",basename(countDir))){\n    #   antibodyToFilter <- gsub(\"^Antibody_\",\"\",basename(countDir))\n    #   sampleSheet <- sampleSheet[sampleSheet$Antibody %in% antibodyToFilter,]\n    #   fullCounts <- fullCounts[,colnames(fullCounts) %in% sampleSheet$GenomicsID]\n    # }\n    print(uniqueAntibodies)\n    if(length(uniqueAntibodies) > 0){\n      for(i in 1:length(uniqueAntibodies)){\n        antibodyToFilter <- uniqueAntibodies[i]\n        sampleSheet2 <- sampleSheet[sampleSheet$Antibody %in% antibodyToFilter,]\n        \n        fullCounts2 <- fullCounts[,colnames(fullCounts) %in% sampleSheet2$GenomicsID,drop=FALSE]\n        print(antibodyToFilter)\n        metadata <- dplyr::select(sampleSheet2,-GenomicsID,-FQLocation,-InputToUse,-toMerge,-BroadCall)\n        group <- gsub(\"_+$\",\"\",apply(metadata,1,paste,sep=\"_\",collapse=\"_\"))\n        #names(files) <- basename(dirname(files))\n        \n        sampleTable <- data.frame(Group = factor(make.names(group)))\n        rownames(sampleTable) <- colnames(fullCounts2)\n        # print(fullCounts2[1:2,])\n        # print(colnames(fullCounts2) %in% sampleSheet2$GenomicsID)\n        # # print(length(colnames(fullCounts) %in% sampleSheet$GenomicsID))\n        if(length(colnames(fullCounts2) %in% sampleSheet2$GenomicsID) > 0 & ncol(fullCounts2) > 2 & length(levels(sampleTable$Group)) > 1 & length(as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))) > 1){\n          # print(\"ello!!!\")\n          # print((length(colnames(fullCounts2) %in% sampleSheet2$GenomicsID) > 0 & ncol(fullCounts2) > 2 & length(levels(sampleTable$Group)) > 1 & length(as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))) > 1))\n          # \n          # kl <- expand.grid(ToExpand,\n          #                   ToExpand)\n          # kl <- kl[kl[,1,drop=FALSE] != kl[,2,drop=FALSE],,drop=FALSE]\n          # print(\"What!\")\n          # \n          dds <- DESeqDataSetFromMatrix(fullCounts2, sampleTable, ~Group)\n          if(hasDEseq2Reps(dds)){\n            dds <- DESeq(dds,parallel = parallelR)\n            DEGdir2 <- file.path(DEGdir,antibodyToFilter)\n            dir.create(DEGdir2,showWarnings = FALSE)\n            save(dds,file=file.path(DEGdir2,\"dds.RData\"))\n            toPlot <- rlog(dds)\n            save(toPlot,file=file.path(DEGdir2,\"rloggedData.RData\"))\n            #plotPCA(toPlot,intgroup=\"Group\")\n            \n            # AllComparisons <- unique(combn(group,2,FUN = function(x)paste(x,collapse=\"_\"),simplify = T))\n            # AllComparisons <- unique(combn(group,2,simplify = T))\n            # AllComparisons <- AllComparisons[,!AllComparisons[1,] == AllComparisons[2,]]\n            # pairWiseComparison <- paste(AllComparisons[1,],AllComparisons[2,],sep=\"Vs\")\n            # AllComparisons <- AllComparisons[,match(unique(pairWiseComparison),pairWiseComparison),drop=F]\n            # pairWiseComparison <- pairWiseComparison[match(unique(pairWiseComparison),pairWiseComparison)]\n            # allComparisonList <- unlist(apply(AllComparisons,2,function(x)list(x)),recursive = F)\n            # names(allComparisonList) <- pairWiseComparison\n            \n            # contrastVector <- resultsNames(dds)\n            # contrastVector <- contrastVector[contrastVector != \"Intercept\"]\n            contrastsFile <- file.path(DEGdir2,\"Contrasts.txt\")\n            if(length(as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))) > 1){\n            if(!file.exists(contrastsFile)){\n              ToExpand <- as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))\n              kl <- expand.grid(ToExpand,\n                                ToExpand)\n              kl <- kl[kl[,1,drop=FALSE] != kl[,2,drop=FALSE],,drop=FALSE]\n              kl <- t(apply(kl,1,sort))\n              kl <- kl[!duplicated(paste(kl[,1,drop=FALSE],kl[,2,drop=FALSE],sep=\"_\")),,drop=FALSE]\n              write.table(kl,contrastsFile,sep=\"\\t\",quote=FALSE,row.names=FALSE,col.names=FALSE)\n            }else{\n              kl <- read.delim(contrastsFile,sep=\"\\t\",header=FALSE)\n            }\n            #contrastVector <- paste0(\"Group_\",kl[,1],\"_vs_\",kl[,2])\n            contrastVector <- apply(kl,1,function(x)as.list(x))\n            DEseq2Res <- lapply(contrastVector,callDESeq2ResultsChIP,ddsObject=dds,DEGdir=DEGdir2,countDir=countDir,parallelR=parallelR)\n            \n            names(DEseq2Res) <- contrastVector\n            }\n          }\n        }\n      }\n    }else{\n      print(\"Ohh\")\n      #antibodyToFilter <- uniqueAntibodies[i]\n      #sampleSheet2 <- sampleSheet[sampleSheet$Antibody %in% antibodyToFilter,]\n      sampleSheet2 <- sampleSheet\n      fullCounts2 <- fullCounts[,colnames(fullCounts) %in% sampleSheet2$GenomicsID,drop=FALSE]\n      #print(antibodyToFilter)\n      metadata <- dplyr::select(sampleSheet2,-GenomicsID,-FQLocation,-InputToUse,-toMerge,-BroadCall)\n      group <- gsub(\"_+$\",\"\",apply(metadata,1,paste,sep=\"_\",collapse=\"_\"))\n      #names(files) <- basename(dirname(files))\n      \n      sampleTable <- data.frame(Group = factor(make.names(group)))\n      rownames(sampleTable) <- colnames(fullCounts2)\n      print(fullCounts2[1:2,])\n      print(colnames(fullCounts2) %in% sampleSheet2$GenomicsID)\n      # print(length(colnames(fullCounts) %in% sampleSheet$GenomicsID))\n      if(length(colnames(fullCounts2) %in% sampleSheet2$GenomicsID) > 0 & ncol(fullCounts2) > 2 &\n         length(levels(sampleTable$Group)) > 1 & length(as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))) > 1){\n        print(\"Ohhellow\")\n        dds <- DESeqDataSetFromMatrix(fullCounts2, sampleTable, ~Group)\n        \n        dds <- DESeq(dds,parallel = parallelR)\n        DEGdir2 <- file.path(DEGdir,\"All\")\n        dir.create(DEGdir2,showWarnings = FALSE)\n        save(dds,file=file.path(DEGdir2,\"dds.RData\"))\n        toPlot <- rlog(dds)\n        save(toPlot,file=file.path(DEGdir2,\"rloggedData.RData\"))\n        #plotPCA(toPlot,intgroup=\"Group\")\n        \n        # AllComparisons <- unique(combn(group,2,FUN = function(x)paste(x,collapse=\"_\"),simplify = T))\n        # AllComparisons <- unique(combn(group,2,simplify = T))\n        # AllComparisons <- AllComparisons[,!AllComparisons[1,] == AllComparisons[2,]]\n        # pairWiseComparison <- paste(AllComparisons[1,],AllComparisons[2,],sep=\"Vs\")\n        # AllComparisons <- AllComparisons[,match(unique(pairWiseComparison),pairWiseComparison),drop=F]\n        # pairWiseComparison <- pairWiseComparison[match(unique(pairWiseComparison),pairWiseComparison)]\n        # allComparisonList <- unlist(apply(AllComparisons,2,function(x)list(x)),recursive = F)\n        # names(allComparisonList) <- pairWiseComparison\n        \n        # contrastVector <- resultsNames(dds)\n        # contrastVector <- contrastVector[contrastVector != \"Intercept\"]\n        if(length(as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))) > 1){\n        contrastsFile <- file.path(DEGdir2,\"Contrasts.txt\")\n        if(!file.exists(contrastsFile)){\n          ToExpand <- as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))\n          kl <- expand.grid(ToExpand,\n                            ToExpand)\n          kl <- kl[kl[,1,drop=FALSE] != kl[,2,drop=FALSE],,drop=FALSE]\n          kl <- t(apply(kl,1,sort))\n          kl <- kl[!duplicated(paste(kl[,1,drop=FALSE],kl[,2,drop=FALSE],sep=\"_\")),,drop=FALSE]\n          write.table(kl,contrastsFile,sep=\"\\t\",quote=FALSE,row.names=FALSE,col.names=FALSE)\n        }else{\n          kl <- read.delim(contrastsFile,sep=\"\\t\",header=FALSE)\n        }\n        #contrastVector <- paste0(\"Group_\",kl[,1],\"_vs_\",kl[,2])\n        contrastVector <- apply(kl,1,function(x)as.list(x))\n        DEseq2Res <- lapply(contrastVector,callDESeq2ResultsChIP,ddsObject=dds,DEGdir=DEGdir2,countDir=countDir,parallelR=parallelR)\n        \n        names(DEseq2Res) <- contrastVector\n        }\n      }\n    }\n    return(DEseq2Res)\n  }\n}\n\n\nrunDESeq2ChIP3 <- function(x,sampleSheet,countDir,DEGdir,callDESeq2ResultsChIP,parallelR=FALSE){\n  \n  countDir <- countDir[x]\n  DEGdir <- DEGdir[x]\n  dir.create(DEGdir,showWarnings = FALSE)\n  # sampleSheet <- newAnalysis\n  # countDir <- file.path(countsDir,basename(consensusPeakCountDirs[i]))\n  # DEGdir <- file.path(degDir,basename(consensusPeakCountDirs[i]))\n  # parallelR=FALSE\n  require(tximport)\n  require(DESeq2)\n  DEseq2Res <- list()\n  if(!file.exists(file.path(DEGdir,\"dds.RData\"))){\n    files <- dir(countDir,pattern=paste0(\".Counts\"),full.names = TRUE)\n    names(files) <- gsub(\"_subread_Peak.*|Sorted_\",\"\",basename(files))\n    countsFiles <- files\n    #do.call(cbind,list(countsFiles))\n    ans <- list()\n    rownamesToBe <- read.delim(countsFiles[1],sep=\"\\t\",h=F,skip=1)[,1]\n    for(i in 1:length(countsFiles)){\n      ans[[i]] <- read.delim(countsFiles[i],sep=\"\\t\",h=F,skip = 1)[,2]\n    }\n    fullCounts <- do.call(cbind,ans)\n    rownames(fullCounts) <- rownamesToBe\n    colnames(fullCounts) <- gsub(\"\\\\.Counts\",\"\",names(files))\n    sampleSheet <- sampleSheet[match(colnames(fullCounts),sampleSheet$GenomicsID),]\n    \n    \n    metadata <- dplyr::select(sampleSheet,-GenomicsID,-FQLocation,-InputToUse,-toMerge,-BroadCall)\n    group <- gsub(\"_+$\",\"\",apply(metadata,1,paste,sep=\"_\",collapse=\"_\"))\n    #names(files) <- basename(dirname(files))\n    \n    sampleTable <- data.frame(Group = factor(make.names(group)))\n    rownames(sampleTable) <- colnames(fullCounts)\n    dds <- DESeqDataSetFromMatrix(fullCounts, sampleTable, ~Group)\n    dds <- DESeq(dds,parallel = FALSE)\n    dir.create(DEGdir,showWarnings = FALSE)\n    save(dds,file=file.path(DEGdir,\"dds.RData\"))\n    toPlot <- rlog(dds)\n    save(toPlot,file=file.path(DEGdir,\"rloggedData.RData\"))\n    \n    \n    \n    \n    uniqueAntibodies <- unique(sampleSheet$Antibody)\n    # if(grepl(\"^Antibody_\",basename(countDir))){\n    #   antibodyToFilter <- gsub(\"^Antibody_\",\"\",basename(countDir))\n    #   sampleSheet <- sampleSheet[sampleSheet$Antibody %in% antibodyToFilter,]\n    #   fullCounts <- fullCounts[,colnames(fullCounts) %in% sampleSheet$GenomicsID]\n    # }\n    print(uniqueAntibodies)\n    if(length(uniqueAntibodies) > 0){\n      for(i in 1:length(uniqueAntibodies)){\n        antibodyToFilter <- uniqueAntibodies[i]\n        sampleSheet2 <- sampleSheet[sampleSheet$Antibody %in% antibodyToFilter,]\n        \n        fullCounts2 <- fullCounts[,colnames(fullCounts) %in% sampleSheet2$GenomicsID,drop=FALSE]\n        print(antibodyToFilter)\n        metadata <- dplyr::select(sampleSheet2,-GenomicsID,-FQLocation,-InputToUse,-toMerge,-BroadCall)\n        group <- gsub(\"_+$\",\"\",apply(metadata,1,paste,sep=\"_\",collapse=\"_\"))\n        #names(files) <- basename(dirname(files))\n        \n        sampleTable <- data.frame(Group = factor(make.names(group)))\n        rownames(sampleTable) <- colnames(fullCounts2)\n        # print(fullCounts2[1:2,])\n        # print(colnames(fullCounts2) %in% sampleSheet2$GenomicsID)\n        # # print(length(colnames(fullCounts) %in% sampleSheet$GenomicsID))\n        if(length(colnames(fullCounts2) %in% sampleSheet2$GenomicsID) > 0 & ncol(fullCounts2) > 2 & length(levels(sampleTable$Group)) > 1 & length(as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))) > 1){\n          # print(\"ello!!!\")\n          # print((length(colnames(fullCounts2) %in% sampleSheet2$GenomicsID) > 0 & ncol(fullCounts2) > 2 & length(levels(sampleTable$Group)) > 1 & length(as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))) > 1))\n          # \n          # kl <- expand.grid(ToExpand,\n          #                   ToExpand)\n          # kl <- kl[kl[,1,drop=FALSE] != kl[,2,drop=FALSE],,drop=FALSE]\n          # print(\"What!\")\n          # \n          dds <- DESeqDataSetFromMatrix(fullCounts2, sampleTable, ~Group)\n          if(ngsPipeR:::hasDEseq2Reps(dds)){\n            dds <- DESeq(dds,parallel = parallelR)\n            DEGdir2 <- file.path(DEGdir,antibodyToFilter)\n            dir.create(DEGdir2,showWarnings = FALSE)\n            save(dds,file=file.path(DEGdir2,\"dds.RData\"))\n            toPlot <- rlog(dds)\n            save(toPlot,file=file.path(DEGdir2,\"rloggedData.RData\"))\n            #plotPCA(toPlot,intgroup=\"Group\")\n            \n            # AllComparisons <- unique(combn(group,2,FUN = function(x)paste(x,collapse=\"_\"),simplify = T))\n            # AllComparisons <- unique(combn(group,2,simplify = T))\n            # AllComparisons <- AllComparisons[,!AllComparisons[1,] == AllComparisons[2,]]\n            # pairWiseComparison <- paste(AllComparisons[1,],AllComparisons[2,],sep=\"Vs\")\n            # AllComparisons <- AllComparisons[,match(unique(pairWiseComparison),pairWiseComparison),drop=F]\n            # pairWiseComparison <- pairWiseComparison[match(unique(pairWiseComparison),pairWiseComparison)]\n            # allComparisonList <- unlist(apply(AllComparisons,2,function(x)list(x)),recursive = F)\n            # names(allComparisonList) <- pairWiseComparison\n            \n            # contrastVector <- resultsNames(dds)\n            # contrastVector <- contrastVector[contrastVector != \"Intercept\"]\n            contrastsFile <- file.path(DEGdir2,\"Contrasts.txt\")\n            if(length(as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))) > 1){\n              if(!file.exists(contrastsFile)){\n                ToExpand <- as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))\n                kl <- expand.grid(ToExpand,\n                                  ToExpand)\n                kl <- kl[kl[,1,drop=FALSE] != kl[,2,drop=FALSE],,drop=FALSE]\n                kl <- t(apply(kl,1,sort))\n                kl <- kl[!duplicated(paste(kl[,1,drop=FALSE],kl[,2,drop=FALSE],sep=\"_\")),,drop=FALSE]\n                write.table(kl,contrastsFile,sep=\"\\t\",quote=FALSE,row.names=FALSE,col.names=FALSE)\n              }else{\n                kl <- read.delim(contrastsFile,sep=\"\\t\",header=FALSE)\n              }\n              #contrastVector <- paste0(\"Group_\",kl[,1],\"_vs_\",kl[,2])\n              contrastVector <- apply(kl,1,function(x)as.list(x))\n              DEseq2Res <- lapply(contrastVector,callDESeq2ResultsChIP,ddsObject=dds,DEGdir=DEGdir2,countDir=countDir,parallelR=parallelR)\n              \n              names(DEseq2Res) <- contrastVector\n            }\n          }\n        }\n      }\n    }else{\n      print(\"Ohh\")\n      #antibodyToFilter <- uniqueAntibodies[i]\n      #sampleSheet2 <- sampleSheet[sampleSheet$Antibody %in% antibodyToFilter,]\n      sampleSheet2 <- sampleSheet\n      fullCounts2 <- fullCounts[,colnames(fullCounts) %in% sampleSheet2$GenomicsID,drop=FALSE]\n      #print(antibodyToFilter)\n      metadata <- dplyr::select(sampleSheet2,-GenomicsID,-FQLocation,-InputToUse,-toMerge,-BroadCall)\n      group <- gsub(\"_+$\",\"\",apply(metadata,1,paste,sep=\"_\",collapse=\"_\"))\n      #names(files) <- basename(dirname(files))\n      \n      sampleTable <- data.frame(Group = factor(make.names(group)))\n      rownames(sampleTable) <- colnames(fullCounts2)\n      print(fullCounts2[1:2,])\n      print(colnames(fullCounts2) %in% sampleSheet2$GenomicsID)\n      # print(length(colnames(fullCounts) %in% sampleSheet$GenomicsID))\n      if(length(colnames(fullCounts2) %in% sampleSheet2$GenomicsID) > 0 & ncol(fullCounts2) > 2 &\n         length(levels(sampleTable$Group)) > 1 & length(as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))) > 1){\n        print(\"Ohhellow\")\n        dds <- DESeqDataSetFromMatrix(fullCounts2, sampleTable, ~Group)\n        \n        dds <- DESeq(dds,parallel = parallelR)\n        DEGdir2 <- file.path(DEGdir,\"All\")\n        dir.create(DEGdir2,showWarnings = FALSE)\n        save(dds,file=file.path(DEGdir2,\"dds.RData\"))\n        toPlot <- rlog(dds)\n        save(toPlot,file=file.path(DEGdir2,\"rloggedData.RData\"))\n        #plotPCA(toPlot,intgroup=\"Group\")\n        \n        # AllComparisons <- unique(combn(group,2,FUN = function(x)paste(x,collapse=\"_\"),simplify = T))\n        # AllComparisons <- unique(combn(group,2,simplify = T))\n        # AllComparisons <- AllComparisons[,!AllComparisons[1,] == AllComparisons[2,]]\n        # pairWiseComparison <- paste(AllComparisons[1,],AllComparisons[2,],sep=\"Vs\")\n        # AllComparisons <- AllComparisons[,match(unique(pairWiseComparison),pairWiseComparison),drop=F]\n        # pairWiseComparison <- pairWiseComparison[match(unique(pairWiseComparison),pairWiseComparison)]\n        # allComparisonList <- unlist(apply(AllComparisons,2,function(x)list(x)),recursive = F)\n        # names(allComparisonList) <- pairWiseComparison\n        \n        # contrastVector <- resultsNames(dds)\n        # contrastVector <- contrastVector[contrastVector != \"Intercept\"]\n        if(length(as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))) > 1){\n          contrastsFile <- file.path(DEGdir2,\"Contrasts.txt\")\n          if(!file.exists(contrastsFile)){\n            ToExpand <- as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))\n            kl <- expand.grid(ToExpand,\n                              ToExpand)\n            kl <- kl[kl[,1,drop=FALSE] != kl[,2,drop=FALSE],,drop=FALSE]\n            kl <- t(apply(kl,1,sort))\n            kl <- kl[!duplicated(paste(kl[,1,drop=FALSE],kl[,2,drop=FALSE],sep=\"_\")),,drop=FALSE]\n            write.table(kl,contrastsFile,sep=\"\\t\",quote=FALSE,row.names=FALSE,col.names=FALSE)\n          }else{\n            kl <- read.delim(contrastsFile,sep=\"\\t\",header=FALSE)\n          }\n          #contrastVector <- paste0(\"Group_\",kl[,1],\"_vs_\",kl[,2])\n          contrastVector <- apply(kl,1,function(x)as.list(x))\n          DEseq2Res <- lapply(contrastVector,callDESeq2ResultsChIP,ddsObject=dds,DEGdir=DEGdir2,countDir=countDir,parallelR=parallelR)\n          \n          names(DEseq2Res) <- contrastVector\n        }\n      }\n    }\n    return(DEseq2Res)\n  }\n}\n\n\n\n\nrunDEXSeq <- function(sampleSheet,genesToTx,countDir,DEGdir,id2SymbolFile,parallelR=FALSE){\n  \n  require(tximport)\n  library(DEXSeq)\n  \n  files <- file.path(countDir,sampleSheet$GenomicsID,\"quant.sf\")\n  metadata <- dplyr::select(sampleSheet,-GenomicsID,-FQLocation,-InputToUse,-toMerge,-BroadCall)\n  group <- gsub(\"_+$\",\"\",apply(metadata,1,paste,sep=\"_\",collapse=\"_\"))\n  names(files) <- basename(dirname(files))\n  tx2geneCompare <- read.delim(genesToTx,h=T,sep=\",\")\n  txi.salmon <- tximport(files, type = \"salmon\", tx2gene = tx2geneCompare,txOut = TRUE)\n  sampleTable <- data.frame(Group = factor(group))\n  rownames(sampleTable) <- colnames(txi.salmon$counts)\n  #sampleData$condition=condition\n  contrastsFile <- file.path(DEGdir,\"Contrasts.txt\")\n  if(!file.exists(contrastsFile)){\n    kl <- expand.grid(colData(dds)$Group,\n                      colData(dds)$Group)\n    kl <- kl[kl[,1] != kl[,2],,drop=FALSE]\n    kl <- t(apply(kl,1,sort))\n    kl <- kl[!duplicated(paste(kl[,1],kl[,2],sep=\"_\")),,drop=FALSE]\n    write.table(kl,contrastsFile,sep=\"\\t\",quote=FALSE,row.names=FALSE,col.names=FALSE)\n  }else{\n    kl <- read.delim(contrastsFile,sep=\"\\t\",header=FALSE)\n  }\n  contrastVector <- apply(kl,1,function(x)as.list(x))\n  \n  ourCounts <- ceiling(txi.salmon$counts)\n  save(ourCounts,file=file.path(DEGdir,\"dxd.RData\"))\n  # dxd <- DEXSeqDataSet(countData = ceiling(txi.salmon$counts),\n  #                      sampleData = sampleTable,\n  #                      design = ~ sample + exon + Group:exon,\n  #                      featureID = rownames(ourCounts),\n  #                      groupID = as.character(tx2geneCompare[match(rownames(ourCounts),tx2geneCompare$TXNAME),\"GENEID\"]))\n  # dxd <- estimateSizeFactors(dxd)\n  # dxd <- estimateDispersions(dxd, fitType=\"local\")\n  # dxd <- testForDEU(dxd, reducedModel = ~ sample + exon)\n  #save(dxd,file=\"dxdCaseStudySimulationEvaluation.RData\")\n  # dxr <- DEXSeqResults(dxd)\n  # dxr <- dxr[order(dxr$pvalue),]\n  # qvalDxr <- perGeneQValue(dxr)\n  DEXSeqRes <- bptry(bplapply(contrastVector,callDEXSeqResults,countsObject=ourCounts,sampleTable=sampleTable,tx2geneCompare=tx2geneCompare,\n                      DEGdir=DEGdir,parallelR=parallelR,id2SymbolFile=id2SymbolFile))\n  \n\n  #save(dxd,file=file.path(DEGdir,\"dxd.RData\"))\n\n\n  #contrastVector <- paste0(\"Group_\",kl[,1],\"_vs_\",kl[,2])\n  # contrastVector <- apply(kl,1,function(x)as.list(x))\n  # DEseq2Res <- lapply(contrastVector,callDESeq2Results,ddsObject=dds,DEGdir=DEGdir,parallelR=parallelR,id2SymbolFile=id2SymbolFile)\n  # names(DEseq2Res) <- contrastVector\n  # return(DEseq2Res)\n  NULL\n}\n\n\ncallSinglePeakSetMeme<- function(FASTA,OUTDIR,NAME,\n                                 memeChIPExecutable=\"meme-chip\",memeChIPdatabase,stdoutDir=\"\",stderrDir=\"\"){\n  require(GenomicRanges)\n  if(!file.exists(file.path(OUTDIR,\"index.html\"))){\n    ARGS <- c(\n      paste0(\"-o\",\" \",file.path(OUTDIR)),\n      paste0(\"-db\",\" \",memeChIPdatabase),\n      FASTA\n    )\n\n    system2(memeChIPExecutable,\n            args =  ARGS,\n            stdout = file.path(stdoutDir,paste0(\"MEMEchip_\",NAME,\".txt\")),\n            stderr = file.path(stderrDir,paste0(\"MEMEchip_\",NAME,\".txt\"))\n    )\n  }\n}\n\ncallSampleSheetMeme <- function(dfSS,macsPeakCalls,referenceFiles,motifDir,\n                                memeChIPExecutable,memeChIPdatabase,stdoutDir,stderrDir,ntop=1000){\n  meme_List <-  bplapply(1:nrow(dfSS),function(x,dfSS,MacsPeaks,referenceFiles,\n                                               memeChIPExecutable,memeChIPdatabase,stdoutDir,stderrDir,ntop,motifDir,callSinglePeakSetMeme)\n    if(!is.na(dfSS$InputToUse[x])){\n      require(GenomicRanges)\n      require(Biostrings)\n      require(Rsamtools)\n      dir.create(file.path(motifDir,\"MEME\"),showWarnings = F)\n      PEAKS <- MacsPeaks[[dfSS$GenomicsID[x]]][[1]]$narrowPeak\n      if(!is.null(PEAKS)){\n        print(\"here\")\n        if(\"peak\" %in% colnames(mcols(PEAKS))){\n          start(PEAKS) <- end(PEAKS) <- start(PEAKS)+mcols(PEAKS)$peak\n        }\n        PEAKS <- resize(PEAKS,201,fix=\"center\")\n        ntop <- min(c(length(PEAKS),ntop))\n        if(\"peak\" %in% colnames(mcols(PEAKS))){\n          PEAKS <- PEAKS[order(PEAKS$pValue,PEAKS$score,decreasing = T),][1:ntop,]\n        }else{\n          PEAKS <- PEAKS[order(PEAKS$score,decreasing = T),][1:ntop,]\n        }\n        #PEAKS <- PEAKS[!seqnames(PEAKS) %in% c(\"chrM\",\"M\",\"MT\"),]\n        seqUnderPeaks <- getSeq(FaFile(referenceFiles[[\"fasta\"]]),PEAKS)\n        names(seqUnderPeaks) <- names(PEAKS)\n        FASTA <- file.path(motifDir,\"MEME\",paste0(dfSS$GenomicsID[x],\".fa\"))\n        writeXStringSet(seqUnderPeaks,FASTA)\n        OUTDIR <- file.path(motifDir,\"MEME\",dfSS$GenomicsID[x])\n        NAME <- paste0(dfSS$GenomicsID[x])\n        motifCalls_meme <- callSinglePeakSetMeme(FASTA,OUTDIR,NAME,\n                                                 memeChIPExecutable=memeChIPExecutable,memeChIPdatabase,\n                                                 stdoutDir=stdoutDir,stderrDir=stderrDir)\n      }\n    },dfSS,macsPeakCalls,referenceFiles,memeChIPExecutable,memeChIPdatabase,stdoutDir,stderrDir,ntop,motifDir,callSinglePeakSetMeme)\n  memeVersion <- system2(memeChIPExecutable,\"--version\",stderr = TRUE,stdout=TRUE)\n  versions <- list(\"MEME\"=as.character(memeVersion))\n  names(meme_List) <- dfSS$GenomicsID\n  c(meme_List,versions)}\n\ncallSampleSheetMacs <- function(dfSS,bamsDir,peaksDir,macsExecutable,stdoutDir,stderrDir,callSingleSampleMacs){\n\n  dfSS <- dfSS[!is.na(dfSS$InputToUse),,drop=FALSE]\n  print(nrow(dfSS))\n  if(nrow(dfSS) > 0){\n  peakCalls_MACS2_List <-  bplapply(1:nrow(dfSS),function(x,bamsDir,peaksDir,dfSS,callSingleSampleMacs,macsExecutable,stdoutDir,stderrDir)\n    if(!is.na(dfSS$InputToUse[x])){\n      print(\"hereIAM\")\n      TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\".bam\"))\n      controlID <- dfSS$InputToUse[x]\n      CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\".bam\"))\n      OUTDIR <- file.path(peaksDir,\"MACS2\",dfSS$GenomicsID[x])\n      format <- ifelse(grepl(\";\",dfSS$FQLocation[x]),\"BAMPE\",\"BAM\")\n      if(grepl(\";\",dfSS$FQLocation[x])){\n        if(!file.exists(file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\")))){\n          require(rtracklayer)\n          require(GenomicAlignments)\n          test <- readGAlignmentPairs(TESTSAMPLE,param=ScanBamParam(what=c(\"qname\",\"flag\",\"rname\",\"strand\",\"pos\",\"qwidth\",\"mapq\",\"cigar\",\"mrnm\",\"mpos\",\"isize\",\"seq\",\"qual\",\"groupid\",\"mate_status\")))\n          test2 <- test[elementMetadata(first(test))$mapq != 0 & elementMetadata(second(test))$mapq != 0]\n          TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\"))\n          CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\"_forMACS2.bam\"))\n\n          export(test2,TESTSAMPLE,\"bam\")\n        }else{\n          TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\"))\n          CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\"_forMACS2.bam\"))\n\n        }\n      }else{\n        if(!file.exists(file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\")))){\n          require(rtracklayer)\n          require(GenomicAlignments)\n          test <- readGAlignments(TESTSAMPLE,param=ScanBamParam(what=c(\"mapq\")))\n          test2 <- test[elementMetadata(test)$mapq != 0,]\n          TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\"))\n          export(test2,TESTSAMPLE,\"bam\")\n          \n          if(controlID != dfSS$GenomicsID[x]){\n            ctrl <- readGAlignments(CONTROLSAMPLE,param=ScanBamParam(what=c(\"mapq\")))\n            ctrl2 <- ctrl[elementMetadata(ctrl)$mapq != 0,]\n            CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\"callingAgainst\",dfSS$GenomicsID[x],\"_forMACS2.bam\"))\n            export(ctrl2,CONTROLSAMPLE,\"bam\")\n          }else{\n            CONTROLSAMPLE <- TESTSAMPLE\n          }\n        }else{\n\n          TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\"))\n          if(controlID != dfSS$GenomicsID[x]){\n            CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\"callingAgainst\",dfSS$GenomicsID[x],\"_forMACS2.bam\"))\n          }else{\n            CONTROLSAMPLE <- TESTSAMPLE\n          }\n        }\n      }\n      dir.create(OUTDIR,showWarnings = FALSE)\n      NAME <- paste0(dfSS$GenomicsID[x],\"_withInput_\",dfSS$InputToUse[x])\n      BROADT <- dfSS$BroadCall[x]\n      if(is.na(BROADT) | BROADT == \"\") BROADT <- FALSE\n      peakCalls_MACS2 <- callSingleSampleMacs(TESTSAMPLE,CONTROLSAMPLE,OUTDIR,NAME,BROADT,\n                                              macsExecutable=macsExecutable,\n                                              stdoutDir=stdoutDir,stderrDir=stderrDir,format=format)\n    },bamsDir=bamsDir,peaksDir=peaksDir,dfSS,callSingleSampleMacs,macsExecutable,stdoutDir,stderrDir)\n  #MacsVersion <- system2(macsExecutable,\"--version\",stderr = TRUE,stdout=TRUE)\n  #versions <- list(\"MACS2\"=as.character(MacsVersion))\n  names(peakCalls_MACS2_List) <- dfSS$GenomicsID\n  #c(peakCalls_MACS2_List,versions)}\n  return(c(peakCalls_MACS2_List))\n  }else{\n    peakCalls_MACS2_List <- list()\n  }\n}\n\n# TESTSAMPLE <- paste0(bams[8],\".bam\")\n# CONTROLSAMPLE <- paste0(bams[4],\".bam\")\n# OUTDIR <- file.path(peaksDir,\"MACS2\",paste0(basename(bams[8])))\n# NAME <- paste0(basename(bams[8]),\"_withInput_\",basename(bams[4]))\n#\n# TESTSAMPLE <- paste0(bams[5],\".bam\")\n# CONTROLSAMPLE <- paste0(bams[11],\".bam\")\n# OUTDIR <- file.path(peaksDir,\"MACS2\",paste0(basename(bams[5])))\n# NAME <- paste0(basename(bams[5]),\"_withInput_\",basename(bams[11]))\n\n\ncallSingleSampleMacs <- function(TESTSAMPLE,CONTROLSAMPLE,OUTDIR,NAME,BROADT,\n                                 macsExecutable=\"macs2\",stdoutDir=\"\",stderrDir=\"\",format=\"BAM\"){\n  require(GenomicRanges)\n  macsFiles <- dir(file.path(OUTDIR,\"\"),full.names = T)\n  temp <- \"\"\n  # if(!all(any(grepl(\"\\\\.narrowPeak$\",macsFiles)),\n  #         any(grepl(\"\\\\.xls$\",macsFiles)),\n  #         any(grepl(\"summits\\\\.bed$\",macsFiles)))){\n  if(!all(any(grepl(\"\\\\.xls$\",macsFiles)))){    \n    ARGS <- c(\"callpeak\",\n              paste0(\"-t\",\" \",TESTSAMPLE),\n              ifelse(CONTROLSAMPLE != TESTSAMPLE,paste0(\"-c\",\" \",CONTROLSAMPLE),\"\"),\n              #paste0(\"-c\",\" \",CONTROLSAMPLE),\n              paste0(\"--outdir\",\" \",OUTDIR),\n              paste0(\"--name\",\" \",NAME),\n              paste0(\"-f\",\" \",format),\n              ifelse(BROADT,\"--broad\",\"\")\n    )\n    temp <- system2(macsExecutable,\n                    args =  ARGS,\n                    stdout = file.path(stdoutDir,paste0(\"MACS_\",NAME,\".txt\")),\n                    stderr = file.path(stderrDir,paste0(\"MACS_\",NAME,\".txt\"))\n    )\n  }\n  \n  macsFiles <- dir(file.path(OUTDIR,\"\"),full.names = T)  \n  if(all(any(grepl(\"\\\\.narrowPeak$\",macsFiles)),\n         any(grepl(\"\\\\.xls$\",macsFiles)),\n         any(grepl(\"summits\\\\.bed$\",macsFiles)))){\n    macsFiles <- dir(file.path(OUTDIR,\"\"),full.names = T)\n    np_l <- grepl(\"\\\\.narrowPeak$\",macsFiles)\n    tsv_l <- grepl(\"\\\\.xls$\",macsFiles)\n    s_l <- grepl(\"summits\\\\.bed$\",macsFiles)\n    \n    if(file.info(macsFiles[np_l])$size){\n      npTb <- read.delim(macsFiles[np_l],sep=\"\\t\",h=F)\n      #message(\"DonePeaks\")\n      npGr <- GRanges(seqnames = npTb[,1],\n                      IRanges(\n                        start= npTb[,2],\n                        end= npTb[,3]\n                      ),\n                      score=npTb[,5],\n                      strand=\"*\",\n                      signalValue=npTb[,7],\n                      pValue=npTb[,8],\n                      qValue=npTb[,9],\n                      peak=npTb[,10]\n      )\n      names(npGr) <- npTb[,4]\n      \n      sTb <- read.delim(macsFiles[s_l],sep=\"\\t\",h=F)\n      sGr <- GRanges(seqnames = sTb[,1],\n                     IRanges(\n                       start= sTb[,2],\n                       end= sTb[,3]\n                     ),\n                     peak=sTb[,5]\n      )\n      names(sGr) <- sTb[,4]\n      \n      tsvTb <- read.delim(macsFiles[tsv_l],sep=\"\\t\",h=T,comment.char = \"#\")\n      tsvGr <- GRanges(seqnames = tsvTb[,1],\n                       IRanges(\n                         start= tsvTb[,2],\n                         end= tsvTb[,3]\n                       ),\n                       abs_summit=tsvTb[,5],\n                       strand=\"*\",\n                       pileup=tsvTb[,6],\n                       \"minuslog10(pvalue)\"=tsvTb[,7],\n                       fold_enrichment=tsvTb[,8],\n                       \"minuslog10(qvalue)\"=tsvTb[,9]\n      )\n      names(tsvGr) <- tsvTb[,10]\n      \n      macsPeakCalls <- list(narrowPeak=npGr,xls=tsvGr,summits=sGr)\n    }else{\n      macsPeakCalls <- NULL\n    }\n  }else if(all(any(grepl(\"\\\\.broadPeak$\",macsFiles)),\n               any(grepl(\"\\\\.xls$\",macsFiles)))){\n    macsFiles <- dir(OUTDIR,full.names = T)\n    np_l <- grepl(\"\\\\.broadPeak$\",macsFiles)\n    tsv_l <- grepl(\"\\\\.xls$\",macsFiles)\n    if(file.info(macsFiles[np_l])$size){\n      npTb <- read.delim(macsFiles[np_l],sep=\"\\t\",h=F)\n      #message(\"DonePeaks\")\n      npGr <- GRanges(seqnames = npTb[,1],\n                      IRanges(\n                        start= npTb[,2],\n                        end= npTb[,3]\n                      ),\n                      score=npTb[,5],\n                      strand=\"*\"\n      )\n      names(npGr) <- npTb[,4]\n      \n      sGr <- resize(npGr,width = 1,fix = \"center\")\n      \n      tsvTb <- read.delim(macsFiles[tsv_l],sep=\"\\t\",h=T,comment.char = \"#\")\n      tsvGr <- GRanges(seqnames = tsvTb[,1],\n                       IRanges(\n                         start= tsvTb[,2],\n                         end= tsvTb[,3]\n                       ),\n                       strand=\"*\",\n                       pileup=tsvTb[,5],\n                       \"minuslog10(pvalue)\"=tsvTb[,6],\n                       fold_enrichment=tsvTb[,7],\n                       \"minuslog10(qvalue)\"=tsvTb[,8]\n      )\n      names(tsvGr) <- tsvTb[,9]\n      \n      macsPeakCalls <- list(narrowPeak=npGr,xls=tsvGr,summits=sGr)\n    }else{\n      macsPeakCalls <- NULL\n    } \n  }else{\n    macsPeakCalls <- NULL\n  }\n  \n  return(list(macsPeakCalls,temp))\n}\n\nChIPQCAnnotationFromGFF3 <- function(gff3,GeneAnnotation=\"Custom\"){\n  txdbFromGFF3 <- makeTxDbFromGFF(gff3,format = \"gtf\")\n  return(ChIPQCAnnotationFromTXDB(txdbFromGFF3,GeneAnnotation))\n}\nChIPQCAnnotationFromTXDB <- function(txdb,GeneAnnotation=\"Custom\",AllChr=NULL){\n  All5utrs <- reduce(unique(unlist(fiveUTRsByTranscript(txdb))))\n  All3utrs <- reduce(unique(unlist(threeUTRsByTranscript(txdb))))\n  Allcds <- reduce(unique(unlist(cdsBy(txdb,\"tx\"))))\n  Allintrons <- reduce(unique(unlist(intronsByTranscript(txdb))))\n  Alltranscripts <- reduce(unique(unlist(transcripts(txdb))))\n\n  posAllTranscripts <- Alltranscripts[strand(Alltranscripts) == \"+\"]\n  posAllTranscripts <- posAllTranscripts[!(start(posAllTranscripts)-20000 < 0)]\n  negAllTranscripts <- Alltranscripts[strand(Alltranscripts) == \"-\"]\n  chrLimits <- seqlengths(negAllTranscripts)[as.character(seqnames(negAllTranscripts))]\n  #negAllTranscripts <- negAllTranscripts[!(end(negAllTranscripts)+20000 > chrLimits)]\n  Alltranscripts <- c(posAllTranscripts,negAllTranscripts)\n  Promoters500 <-  reduce(flank(Alltranscripts,500))\n  Promoters2000to500 <-  reduce(flank(Promoters500,1500))\n  LongPromoter20000to2000  <- reduce(flank(Promoters2000to500,18000))\n  if(!missing(AllChr) & !is.null(AllChr)){\n    All5utrs <- GetGRanges(All5utrs,AllChr=AllChr)\n    All3utrs <- GetGRanges(All3utrs,AllChr=AllChr)\n    Allcds <- GetGRanges(Allcds,AllChr=AllChr)\n    Allintrons <- GetGRanges(Allintrons,AllChr=AllChr)\n    Alltranscripts <- GetGRanges(Alltranscripts,AllChr=AllChr)\n    Promoters500 <- GetGRanges(Promoters500,AllChr=AllChr)\n    Promoters2000to500 <-  GetGRanges(Promoters2000to500,AllChr=AllChr)\n    LongPromoter20000to2000  <- GetGRanges(LongPromoter20000to2000,AllChr=AllChr)\n  }\n  return(list(version=GeneAnnotation,LongPromoter20000to2000=LongPromoter20000to2000,\n              Promoters2000to500=Promoters2000to500,Promoters500=Promoters500,\n              All5utrs=All5utrs,Alltranscripts=Alltranscripts,Allcds=Allcds,\n              Allintrons=Allintrons,All3utrs=All3utrs))\n}\n\n\nsingleSampleChIPQC <- function(x,dfSS,referenceFiles,bamsDir,MacsPeaks,chipqcDir,customAnnotation){\n  library(ChIPQC)\n  try({\n    if(!file.exists(file.path(chipqcDir,paste0(dfSS$GenomicsID[x],\".RData\")))){\n      if(!is.null(MacsPeaks[[dfSS$GenomicsID[x]]][[1]]$narrowPeak)){\n        PEAKS <- MacsPeaks[[dfSS$GenomicsID[x]]][[1]]$narrowPeak\n      }else{\n        PEAKS <- NULL\n      }\n      BAM <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\".bam\"))\n      BLACKLIST <- referenceFiles[[\"blacklist\"]]\n      ANNOTATION <- customAnnotation\n      if(file.exists(referenceFiles[[\"genome\"]])){\n        singleChIPQC <- ChIPQCsample(BAM,peaks=PEAKS,blacklist=BLACKLIST,annotation=ANNOTATION,chromosomes = paste0(\"chr\",1:19))\n      }else{\n        singleChIPQC <- ChIPQCsample(BAM,peaks=PEAKS,blacklist=BLACKLIST,annotation=ANNOTATION,chromosomes = paste0(\"chr\",1:19))\n      }\n      save(singleChIPQC,file = file.path(chipqcDir,paste0(dfSS$GenomicsID[x],\".RData\")))\n    }else{\n      load(file.path(chipqcDir,paste0(dfSS$GenomicsID[x],\".RData\")))\n    }\n    return(singleChIPQC)\n  },silent=TRUE)\n}\n\ncallSampleSheetChIPQC <- function(dfSS,referenceFiles,bamsDir,MacsPeaks,genome,chipqcDir){\n  library(ChIPQC)\n  annotionRData <- file.path(chipqcDir,gsub(\"\\\\.gff3\",\"\\\\.RData\",basename(referenceFiles[[\"gtf\"]])))\n  print(MacsPeaks)\n  if(!file.exists(annotionRData)){\n    customAnnotation <- ChIPQCAnnotationFromGFF3(referenceFiles[[\"gtf\"]],genome)\n    save(customAnnotation,file = annotionRData)\n  }else{\n    load(file = annotionRData)\n  }\n  bptry(bplapply(1:nrow(dfSS),singleSampleChIPQC,dfSS,referenceFiles,bamsDir,MacsPeaks,chipqcDir,customAnnotation))\n}\n\ngatherReferenceFilesOld <- function(genome,geneModels=\"\",referencesBioC=getReferencesBioC(),blacklist=\"\",referenceDir=file.path(getwd(),\"Reference\"),\n                                    mode=\"ChIP\",\n                                    executables=list(salmonCMD = \"salmon\"),spikeIn=FALSE\n){\n  require(Rsamtools)\n  require(Rsubread)\n  require(magrittr)\n  require(dplyr)\n  require(rtracklayer)\n  require(Biostrings)\n  fasta <- NULL\n  subreadIndex <- NULL\n  dir.create(referenceDir,showWarnings = FALSE)\n  \n  if(mode==\"RNAseq\"){\n    mode <- \"RNA\"\n  }else{\n    mode <- \"ChIP\"\n  }\n  \n  fastaOut <- file.path(referenceDir,paste0(referencesBioC[[genome]][\"sequence\"],\".fa\"))\n  if(spikeIn == \"ERCC92\"){\n    fastaOut <- file.path(referenceDir,paste0(referencesBioC[[genome]][\"sequence\"],\"_ERCC92.fa\"))\n  }\n  if(!file.exists(genome) & is.character(genome)){\n    if(!file.exists(fastaOut)){\n      require(as.character(referencesBioC[[genome]][\"sequence\"]),character.only = T)\n      genomeBioc <- eval(parse(text=(as.character(referencesBioC[[genome]][\"sequence\"]))))\n      keptChrome <- seqnames(genomeBioc)[!grepl(\"hap|random|chrUn\",seqnames(genomeBioc))]\n      toWriteFasta <- DNAStringSet(lapply(keptChrome,function(x)genomeBioc[[x]]))\n      names(toWriteFasta) <- keptChrome\n      if(spikeIn == \"ERCC92\"){\n        fileLocations <- system.file(\"extdata\",package=\"rnaPipeR\")\n        myERCCstrings <- readDNAStringSet(file.path(fileLocations,\"ERCC92.fa\"))\n        toWriteFasta <- c(toWriteFasta,myERCCstrings)\n        referencesBioC[[genome]][\"sequence\"] <- paste0(referencesBioC[[genome]][\"sequence\"],\"_ERCC92\")\n      }\n      writeXStringSet(toWriteFasta,fastaOut)\n      indexFa(FaFile(fastaOut))\n    }\n    if(!file.exists(file.path(referenceDir,paste0(gsub(\"\\\\.fa$\",\"\",fastaOut),\".00.b.array\")))){\n      buildindex(gsub(\"\\\\.fa$\",\"\",fastaOut),fastaOut,indexSplit=FALSE)\n    }\n    fasta <- fastaOut\n    subreadIndex <- gsub(\"\\\\.fa$\",\"\",fastaOut)\n\n  }else if(file.exists(genome)){\n    fasta <- genome\n    if(!file.exists(gsub(\"\\\\.fa\",\"\\\\.00\\\\.b\\\\.array\",fasta))){\n      buildindex(file.exists(gsub(\"\\\\.fa\",\"\",fasta)),fasta,indexSplit=FALSE)\n    }\n    subreadIndex <- gsub(\"\\\\.fa\",\"\",fasta)\n  }\n\n  if(!file.exists(geneModels) & is.character(genome)){\n    if(!file.exists(file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gff3\")))\n       | !file.exists(file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gtf\")))){\n      require(as.character(referencesBioC[[genome]][\"genemodels\"]),character.only = T)\n      txdbBioc <- asGFF(eval(parse(text=(as.character(referencesBioC[[genome]][\"genemodels\"])))))\n      keptChrome <- seqnames(txdbBioc)[!grepl(\"hap|random|chrUn\",seqnames(txdbBioc))]\n      txdbBiocGFF <- txdbBioc[as.vector(seqnames(txdbBioc)) %in% as.vector(unique(keptChrome)),]\n      ##txdbBioc <- sort(txdbBioc)\n      ##\n      #message(\"A\")\n      txdb <- eval(parse(text=(as.character(referencesBioC[[genome]][\"genemodels\"]))))\n      #message(\"B\")\n      exons <- exons(txdb, columns = c('gene_id', 'tx_id', 'tx_name', 'exon_id'))\n      mcols(exons)$type <- 'exon'\n      mcols(exons)$source <- (as.character(referencesBioC[[genome]][\"genemodels\"]))\n      mcols(exons)$transcript_id <- mcols(exons)$tx_id\n      #message(\"B\")\n      keptChrome <- seqnames(exons)[!grepl(\"hap|random|chrUn\",seqnames(exons))]\n      #message(\"B5\")\n      exons <- exons[as.vector(seqnames(exons)) %in% as.vector(unique(keptChrome)),]\n      #message(\"B5\")\n      ## Explore exons a bit\n      exons$gene_id\n      class(exons$gene_id)\n      #message(\"B7\")\n      S4Vectors::lengths(exons$gene_id)\n      #message(\"B5\")\n      filterE <- S4Vectors::lengths(exons$gene_id) != 0\n      #message(\"B5\")\n      txdbBioc <- exons[filterE,]\n      #message(\"B5\")\n\n      ##\n      if(!file.exists(file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gff3\")))){\n        export(txdbBiocGFF,con =file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gff3\")),format = \"gff3\")\n        gtf <- file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gff3\"))\n        #message(\"B66\")\n\n      }else{\n        gtf <- file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gff3\"))\n        #message(\"B576\")\n\n      }\n      if(!file.exists(file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gtf\")))){\n        export(txdbBioc,con = file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gtf\")),format = \"gtf\")\n        actualGtf <- file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gtf\"))\n      }\n    }else{\n      gtf <- file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gff3\"))\n      actualGtf <- file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gtf\"))\n    }\n  }else{\n    gtf <- geneModels\n    actualGtf <- geneModels\n  }\n  if(spikeIn == \"ERCC92\"){\n    fileLocations <- system.file(\"extdata\",package=\"rnaPipeR\")\n    gtfRead <- read.delim(actualGtf,sep=\"\\t\",header = FALSE,comment.char = \"#\",stringsAsFactors = FALSE)\n    ERCCgtf <- file.path(fileLocations,\"ERCC92.gtf\")\n    ERCCgtfRead <- read.delim(ERCCgtf,sep=\"\\t\",header = FALSE,comment.char = \"#\",stringsAsFactors = FALSE)\n    gtfNew <- rbind(gtfRead,ERCCgtfRead)\n    write.table(gtfNew,file=gsub(\"\\\\.gtf\",\"\\\\ERCC99.gtf\",gtf),row.names = FALSE,quote=FALSE,sep=\"\\t\")\n    actualGtf <- gsub(\"\\\\.gtf\",\"\\\\ERCC99.gtf\",actualGtf)\n  }\n  gff3 <- gtf\n  fastaGff3Name <- NULL\n  tx2GeneFile <- NULL\n  salmonIndexFile <- NULL\n  if(mode==\"RNA\" & (!file.exists(file.path(paste0(gsub(\"\\\\.fa$\",\"\",gsub(\".gff3$\",\".fa\",gff3)),\"_\",\"tx2gene.csv\")))\n                    | !file.exists(gsub(\".gff3$\",\".fa\",gff3)))){\n    fastaGff3Name <- gsub(\".gff3$\",\".fa\",gff3)\n    tx2GeneFile <- file.path(paste0(gsub(\"\\\\.fa$\",\"\",fastaGff3Name),\"_\",\"tx2gene.csv\"))\n    salmonIndexFile <- gsub(\"\\\\.fa$\",\"\",fastaGff3Name)\n    # if(mode==\"RNA\" & !file.exists(tx2GeneFile) & !file.exists(fastaGff3Name)){\n    if(file.exists(file.path(referenceDir,paste0(as.character(referencesBioC[[genome]][\"genemodels\"]),\".gff3\")))){\n      #message(\"Im in\")\n      suppressPackageStartupMessages(library(Biostrings))\n      suppressPackageStartupMessages(library(BSgenome.Hsapiens.UCSC.hg19))\n      suppressPackageStartupMessages(library(GenomeInfoDb))\n\n      gff3 <- gtf\n      #message(gtf)\n      #message(gff3)\n      fastaGff3Name <- gsub(\".gff3$\",\".fa\",gff3)\n      tx2GeneFile <- file.path(paste0(gsub(\"\\\\.fa$\",\"\",fastaGff3Name),\"_\",\"tx2gene.csv\"))\n      salmonIndexFile <- gsub(\"\\\\.fa$\",\"\",fastaGff3Name)\n      salmonCMD <- executables$salmonCMD\n\n      suppressPackageStartupMessages(require(GenomicFeatures))\n      txdb <- makeTxDbFromGFF(gff3,format = \"gff3\")\n\n      if(!file.exists(fastaGff3Name)){\n        allTranscripts <- exonsBy(txdb,use.names=T)\n        seqAllTranscripts <- extractTranscriptSeqs(FaFile(fasta),allTranscripts)\n        if(spikeIn == \"ERCC92\"){\n          fileLocations <- system.file(\"extdata\",package=\"rnaPipeR\")\n          myERCCstrings <- readDNAStringSet(file.path(fileLocations,\"ERCC92.fa\"))\n          seqAllTranscripts <- c(seqAllTranscripts,myERCCstrings)\n        }\n        writeXStringSet(seqAllTranscripts,filepath = fastaGff3Name)\n        salmonIndexArgs <- paste(\"index -t\",fastaGff3Name,\"-i\",gsub(\"\\\\.fa$\",\"\",fastaGff3Name))\n\n        #message(\"GotHere\")\n        #message(paste(salmonCMD, salmonIndexArgs))\n        # out <- tryCatch(ex <- system2(salmonCMD, salmonIndexArgs, stdout = TRUE,\n        #                               stderr = TRUE), warning = function(w) {\n        #                                 w\n        #                               }, error = function(e) {\n        #                                 e\n        #                               })\n        system(paste(salmonCMD, salmonIndexArgs))\n        #message(\"GotOutOfhere\")\n        #message(out)\n      }\n      if(!file.exists(tx2GeneFile)){\n        k <- keys(txdb, keytype = \"GENEID\")\n        df <- select(txdb, keys = k, keytype = \"GENEID\", columns = \"TXNAME\")\n        tx2gene <- df[, 2:1]  # tx ID, then gene ID\n        write.table(tx2gene,\n                    file=tx2GeneFile,\n                    sep=\",\",col.names=T,row.names=F)\n\n      }\n    }else{\n      message(\"Problem in making Gene to transcript map from GFF3..no GFF3 found.\")\n    }\n\n  }else{\n    fastaGff3Name <- gsub(\".gff3$\",\".fa\",gff3)\n    tx2GeneFile <- file.path(paste0(gsub(\"\\\\.fa$\",\"\",fastaGff3Name),\"_\",\"tx2gene.csv\"))\n    salmonIndexFile <- gsub(\"\\\\.fa$\",\"\",fastaGff3Name)\n  }\n  if(mode == \"ChIP\"){\n    if(!file.exists(blacklist) & is.character(genome)){\n      if(genome == \"hg19-UCSC\" & !file.exists( file.path(referenceDir,paste0(genome,\".blacklist\")))){\n        download.file(\"http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeMapability/wgEncodeDacMapabilityConsensusExcludable.bed.gz\",\n                      destfile = file.path(referenceDir,paste0(genome,\".blacklist\")))\n        blacklist <- file.path(referenceDir,paste0(genome,\".blacklist\"))\n      }else if(genome == \"mm9-UCSC\" & !file.exists( file.path(referenceDir,paste0(genome,\".blacklist\")))){\n        download.file(\"http://www.broadinstitute.org/~anshul/projects/mouse/blacklist/mm9-blacklist.bed.gz\",\n                      destfile = file.path(referenceDir,paste0(genome,\".blacklist\")))\n        blacklist <- file.path(referenceDir,paste0(genome,\".blacklist\"))\n      }else{\n        blacklist <- NULL\n      }\n    }else if(!file.exists(blacklist) & !is.character(genome)){\n      blacklist <- NULL\n    }\n  }else{\n    blacklist <- NULL\n  }\n  return(list(fasta=fasta,gtf=gtf,actualGtf=actualGtf,blacklist=blacklist,subreadIndex=subreadIndex,gff3Fastq=fastaGff3Name,salmonIndexFile=salmonIndexFile,tx2Gene=tx2GeneFile))\n}\n\nDoGo <- function(TestStuff,Gate,id2go,prefix=\"\",DEGdir){\n  ####Read in files####\n  #setwd (\"C:\\\\Documents and Settings\\\\tcarroll\\\\Desktop\\\\InesLatest\\\\New\\\\Results\\\\GOtmp\\\\GatingOnPRC\")\n  ##################################\n  ##################################\n  ###################################\n  #   Function To Reformat GO Table\n  ###################################\n  ##################################\n  ###################################\n\n  #\n  #\n  #   newTable <- function(GenBoth,testgenesboth,HBGOdataBOTH){\n  #     Levels <- buildLevels(HBGOdataBOTH@graph,root=NULL)\n  #     p <- apply(GenBoth,1,GenesInTerm,testgenesboth=testgenesboth,HBGOdataBOTH=HBGOdataBOTH)\n  #     d <- apply(GenBoth,1,DepthToTerm,testgenesboth=testgenesboth,HBGOdataBOTH=HBGOdataBOTH,Levels=Levels)\n  #     GenBoth <- apply(GenBoth,2,CleanGenTable)\n  #     GenBoth <- as.data.frame(GenBoth)\n  #     nearly <- (cbind(GenBoth,p,d))\n  #     colnames(nearly) <- c(\"Go.ID\",\"Description\",\"Annotated\",\"Significant\",\"Expected\",\"rank in Elim\",\"Classic\",\"Elim\",\"Weight\",\"ParentChild\",\"Under Fisher\",\"Genes in Term\",\"Term Depth\")\n  #     return(nearly)\n  #   }\n  #   CleanGenTable <- function(nearly){\n  #     P <- gsub(\"<\",\"\",nearly)\n  #     #P <- as.integer(P)\n  #     return(P)\n  #   }\n  #   DepthToTerm <- function(GenBoth,testgenesboth,HBGOdataBOTH,Levels){\n  #     depth <- unname(unlist(mget(GenBoth[1],Levels$nodes2level)))\n  #     return(depth)\n  #   }\n  #   GenesInTerm <- function(GenBoth,testgenesboth,HBGOdataBOTH){\n  #     #allProbes <- unname(unlist(mget(GenBoth[1], envir=org.Hs.egGO2ALLEGS)[[1]],ifnotfound=NA))\n  #     allProbes <- unname(unlist(mget(GenBoth[1], envir=org.Hs.egGO2ALLEGS,ifnotfound=NA)[[1]]))\n  #\n  #     #PrintingList <- printGenes(HBGOdataBOTH, whichTerms = GenBoth[1], chip = \"org.Hs.eg.db\", geneCutOff=30000)[,3]\n  #     PrintingList <- allProbes[allProbes %in% names(testgenesboth[testgenesboth==1])]\n  #     if(!all(is.na(PrintingList))){\n  #       allSymbols <- unname(unlist(mget(PrintingList, envir=org.Hs.egSYMBOL,ifnotfound=NA)))\n  #     }\n  #     else {allSymbols <- NA}\n  #     #return(cat(unique(allSymbols),sep=\";\"))\n  #     almost <- (paste(unique(allSymbols),sep=\"\",collapse=\";\"))\n  #     #depth <- unname(unlist(mget(GenBoth[1],buildLevels(HBGOdataBOTH@graph,root=NULL)$nodes2level)))\n  #     return(almost)\n  #     #colnames(almost) <- c(\"Go.ID\",\"Description\",\"Annotated\",\"Significant\",\"Expected\",\"rank in Elim\",\"Classic\",\"Elim\",\"Weight\",\"ParentChild\",\"Genes in Term\")\n  #   }\n  ##########################\n  ##########################\n  ##########\n\n\n\n  # ############\n  # ## define the test statistic which will detect underrepresentation\n  # if(!isGeneric(\"GOFisherTestUnder\"))\n  #   setGeneric(\"GOFisherTestUnder\", function(object)\n  #     standardGeneric(\"GOFisherTestUnder\"))\n  # setMethod(\"GOFisherTestUnder\", \"classicCount\",\n  #           function(object) {\n  #             contMat <- contTable(object)\n  #             if(all(contMat == 0))\n  #               p.value <- 1\n  #             else\n  #               p.value <- fisher.test(contMat, alternative =\"less\")$p.value\n  #             ## \"greater\" is for over-, \"less\" for under-, and \"two-sided\" is for both alternatives\n  #             return(p.value)\n  #           })\n  # #########################\n  # test.stat <- new(\"classicCount\", testStatistic = GOFisherTestUnder,name =\"Fisher test underrepresentation\")\n  # ###############################################\n  #\n\n\n\n\n  if (length(prefix) > 0){prefix <- paste0(prefix,\"\")}\n  ClusterEntrez <- vector(\"list\",length=length(TestStuff))\n  testgenes <- vector(\"list\",length=length(TestStuff))\n\n  ClustAllForTopGo <- unlist(Gate,use.names=FALSE)\n  ClustAllForTopGo_u <- unique(ClustAllForTopGo)\n\n\n\n  for(i in 1:length(ClusterEntrez)){\n    ClusterEntrez[[i]] <- unique(TestStuff[[i]][TestStuff[[i]] %in% unlist(Gate,use.names=FALSE)])\n    testgenes[[i]] <- factor(as.integer(ClustAllForTopGo_u %in% ClusterEntrez[[i]]))\n    names(testgenes[[i]]) <- ClustAllForTopGo_u\n  }\n\n  print(testgenes[[i]])\n  for(i in 1:length(ClusterEntrez)){\n    if(length(ClusterEntrez[[i]]) != 0){\n    GOdataOneBP <- new(\"topGOdata\",ontology = \"BP\",allGenes = testgenes[[i]],nodeSize = 3, annot=annFUN.gene2GO, gene2GO =  id2go)\n    #GOdataOneMF <- new(\"topGOdata\",ontology = \"MF\",allGenes = testgenes[[i]],nodeSize = 3,annot = annFUN.org,mapping = \"org.Hs.eg.db\",ID = \"entrez\")\n    #GOdataOneCC <- new(\"topGOdata\",ontology = \"CC\",allGenes = testgenes[[i]],nodeSize = 3,annot = annFUN.org,mapping = \"org.Hs.eg.db\",ID = \"entrez\")\n    resultOneBPC <- runTest(GOdataOneBP, \"classic\", \"fisher\")\n    resultOneBPW <- runTest(GOdataOneBP, \"weight\", \"fisher\")\n    resultOneBPE <- runTest(GOdataOneBP, \"elim\", \"fisher\")\n    #resultOneBPU <- getSigGroups(GOdataOneBP,test.stat)\n    resultOneBPpC <- runTest(GOdataOneBP, \"parentChild\", \"fisher\")\n    #resultOneMFC <- runTest(GOdataOneMF, \"classic\", \"fisher\")\n    #resultOneMFW <- runTest(GOdataOneMF, \"weight\", \"fisher\")\n    #resultOneMFE <- runTest(GOdataOneMF, \"elim\", \"fisher\")\n    #resultOneMFU <- getSigGroups(GOdataOneMF,test.stat)\n    #resultOneMFpC <- runTest(GOdataOneMF, \"parentChild\", \"fisher\")\n    #resultOneCCC <- runTest(GOdataOneCC, \"classic\", \"fisher\")\n    # resultOneCCW <- runTest(GOdataOneCC, \"weight\", \"fisher\")\n    # resultOneCCE <- runTest(GOdataOneCC, \"elim\", \"fisher\")\n    # resultOneCCU <- getSigGroups(GOdataOneCC,test.stat)\n    # resultOneCCpC <- runTest(GOdataOneCC, \"parentChild\", \"fisher\")\n    GenOneBP <- GenTable(GOdataOneBP,resultOneBPC,resultOneBPW,resultOneBPE,resultOneBPpC,topNodes=length(GOdataOneBP@graph@nodes))\n\n    # GenOneBP <- GenTable(GOdataOneBP,resultOneBPC,resultOneBPW,resultOneBPE,resultOneBPpC,resultOneBPU,topNodes=length(GOdataOneBP@graph@nodes))\n    #GenOneMF <- GenTable(GOdataOneMF,resultOneMFC,resultOneMFW,resultOneMFE,resultOneMFpC,resultOneMFU,topNodes=length(GOdataOneMF@graph@nodes))\n    #GenOneCC <- GenTable(GOdataOneCC,resultOneCCC,resultOneCCW,resultOneCCE,resultOneCCpC,resultOneCCU,topNodes=length(GOdataOneCC@graph@nodes))\n\n    #OneBP <- newTable(GenOneBP,testgenes[[i]],GOdataOneBP)\n    #OneMF <- newTable(GenOneMF,testgenes[[i]],GOdataOneMF)\n    #OneCC <- newTable(GenOneCC,testgenes[[i]],GOdataOneCC)\n    write.table(GenOneBP,prefix,sep=\",\",row.names = FALSE)\n    #write.table(OneMF,paste(\"C:\\\\Users\\\\carrol09\\\\Santiago\\\\\",prefix,names(TestStuff[i]),\"_MF_\",\"GoTable.csv\",sep=\"\"),sep=\",\",row.names = FALSE)\n    #write.table(OneCC,paste(\"C:\\\\Users\\\\carrol09\\\\Santiago\\\\\",prefix,names(TestStuff[i]),\"_CC_\",\"GoTable.csv\",sep=\"\"),sep=\",\",row.names = FALSE)\n    }else{\n      GenOneBP <- data.frame(GO.ID=NA,Term=NA,Annotated=NA,Significant=NA,Expected=NA,\"Rank in result2\"=NA,result1=NA,result2=NA,result3=NA,result4=NA)\n      write.table(GenOneBP,prefix,sep=\",\",row.names = FALSE)\n    }\n  }\n}\n\n\n\nplotDupVsAll <- function(sample){\n  dataFrame <- as.data.frame(mcols(sample))\n  Dupps <- rowSums(dataFrame[,c(\"PosDups\",\"NegDups\")])\n  All <- rowSums(dataFrame[,c(\"PosAll\",\"NegAll\")])\n  duppRate <- Dupps/All\n  rfSD <- sample$readToFragmentShiftDiff\n  plot(rfSD,duppRate)\n}\n\n\n\nlibrary(tracktables)\n\n\n\nplotMMVsAll <- function(sample){\n  dataFrame <- as.data.frame(mcols(sample))\n  MM <- rowSums(dataFrame[,c(\"PosMultiMapping\",\"NegMultiMapping\")])\n  All <- rowSums(dataFrame[,c(\"PosAll\",\"NegAll\")])\n  MMRate <- MM/All\n  rfSD <- sample$readToFragmentShiftDiff\n  plot(rfSD,MMRate)\n}\n\n\nUpdateMcols <- function(sample){\n  sample <- sample[[1]]\n  dataFrame <- as.data.frame(mcols(sample))\n  MM <- rowSums(dataFrame[,c(\"PosMultiMapping\",\"NegMultiMapping\")])\n  Dupps <- rowSums(dataFrame[,c(\"PosDups\",\"NegDups\")])\n  All <- rowSums(dataFrame[,c(\"PosAll\",\"NegAll\")])\n  dataFrame[dataFrame$PosAll == 0,\"PosAll\"] <- 1\n  dataFrame[dataFrame$NegAll == 0,\"NegAll\"] <- 1\n  StrandRatio <- dataFrame$PosAll/dataFrame$NegAll\n  duppRate <- Dupps/All\n  MMRate <- MM/All  \n  forMcols <- data.frame(rfSD=sample$readToFragmentShiftDiff,rnSD=sample$readsToNoShiftDiff,MMRate=MMRate,DupRate=duppRate,StrandRatio=StrandRatio,Total=All)\n  mcols(sample) <- forMcols\n  metadata(sample) <- list(\"TotalCountsInPeaks\"=sum(forMcols$Total))\n  return(sample)\n}\n\nUpdateMcolList <- function(sampleList,parallel=F){\n  if(parallel){\n    udSamples <- bplapply(sampleList,UpdateMcols)\n  }else{\n    udSamples <- lapply(sampleList,UpdateMcols)\n  }\n  return(udSamples)\n}\nrbindMcols <- function(x,y){\n  if(class(x) == \"GRanges\"){\n    x <- as.data.frame(mcols(x))\n  }\n  if(class(y) == \"GRanges\"){\n    y <- as.data.frame(mcols(y))\n  }\n  rbind(x,y)\n}\n\nMMVsAllPlot <- function(sampleList){\n  if(class(sampleList) == \"list\"){\n    bigFrame <- NULL\n    lengthsForNames <- lapply(sampleList,length)\n    SampleNames <- unlist(lapply(1:length(lengthsForNames),function(x)rep(names(sampleList)[x],lengthsForNames[[x]])))\n    for(i in 1:length(sampleList)){\n      bigFrame <- rbindMcols(bigFrame,sampleList[[i]])\n    }\n    bigFrame <- cbind(SampleNames,bigFrame)\n    #dataFrame <- as.data.frame(mcols(sample))\n    #test <- cbind(\"Sample\",dataFrame)\n    p <- makeMMVsAllPlot(bigFrame)\n    p <- p+facet_wrap(~SampleNames)\n    return(p)\n  }else{\n    sample <- sampleList\n    dataFrame <- as.data.frame(mcols(sample))\n    test <- cbind(\"Sample\",dataFrame)\n    p <- makeMMVsAllPlot(test)\n    return(p)\n  }\n}\n\n\nDupRateVsAllPlot <- function(sampleList){\n  if(class(sampleList) == \"list\"){\n    bigFrame <- NULL\n    lengthsForNames <- lapply(sampleList,length)\n    SampleNames <- unlist(lapply(1:length(lengthsForNames),function(x)rep(names(sampleList)[x],lengthsForNames[[x]])))\n    for(i in 1:length(sampleList)){\n      bigFrame <- rbindMcols(bigFrame,sampleList[[i]])\n    }\n    bigFrame <- cbind(SampleNames,bigFrame)\n    #dataFrame <- as.data.frame(mcols(sample))\n    #test <- cbind(\"Sample\",dataFrame)\n    p <- makeDupRateVsAllPlot(bigFrame)\n    p <- p+facet_wrap(~SampleNames)\n    return(p)\n  }else{\n    sample <- sampleList\n    dataFrame <- as.data.frame(mcols(sample))\n    test <- cbind(\"Sample\",dataFrame)\n    p <- makeDupRateVsAllPlot(test)\n    return(p)\n  }\n}\n\n\nDupRateVsMMPlot <- function(sampleList){\n  if(class(sampleList) == \"list\"){\n    bigFrame <- NULL\n    lengthsForNames <- lapply(sampleList,length)\n    SampleNames <- unlist(lapply(1:length(lengthsForNames),function(x)rep(names(sampleList)[x],lengthsForNames[[x]])))\n    for(i in 1:length(sampleList)){\n      bigFrame <- rbindMcols(bigFrame,sampleList[[i]])\n    }\n    bigFrame <- cbind(SampleNames,bigFrame)\n    #dataFrame <- as.data.frame(mcols(sample))\n    #test <- cbind(\"Sample\",dataFrame)\n    p <- makeDupRateVsMMPlot(bigFrame)\n    p <- p+facet_wrap(~SampleNames)\n    return(p)\n  }else{\n    sample <- sampleList\n    dataFrame <- as.data.frame(mcols(sample))\n    test <- cbind(\"Sample\",dataFrame)\n    p <- makeDupRateVsMMPlot(test)\n    return(p)\n  }\n}\n\nrfSDscoreDensity <- function(sampleList){\n  if(class(sampleList) == \"list\"){\n    bigFrame <- NULL\n    lengthsForNames <- lapply(sampleList,length)\n    SampleNames <- unlist(lapply(1:length(lengthsForNames),function(x)rep(names(sampleList)[x],lengthsForNames[[x]])))\n    for(i in 1:length(sampleList)){\n      bigFrame <- rbindMcols(bigFrame,sampleList[[i]])\n    }\n    bigFrame <- cbind(SampleNames,bigFrame)\n    #dataFrame <- as.data.frame(mcols(sample))\n    #test <- cbind(\"Sample\",dataFrame)\n    p <- makerfSDscoreDensity(bigFrame)\n    p <- p+facet_wrap(~SampleNames)+xlim(-15,10)\n    return(p)\n  }else{\n    sample <- sampleList\n    dataFrame <- as.data.frame(mcols(sample))\n    test <- cbind(\"Sample\",dataFrame)\n    p <- makerfSDscoreDensity(test)+xlim(-15,10)\n    return(p)\n  }\n}\n\n\nrfvsrn_SD <- function(sampleList){\n  if(class(sampleList) == \"list\"){\n    bigFrame <- NULL\n    lengthsForNames <- lapply(sampleList,length)\n    SampleNames <- unlist(lapply(1:length(lengthsForNames),function(x)rep(names(sampleList)[x],lengthsForNames[[x]])))\n    for(i in 1:length(sampleList)){\n      bigFrame <- rbindMcols(bigFrame,sampleList[[i]])\n    }\n    bigFrame <- cbind(SampleNames,bigFrame)\n    #dataFrame <- as.data.frame(mcols(sample))\n    #test <- cbind(\"Sample\",dataFrame)\n    p <- makerfvsrnPlot(bigFrame)\n    p <- p+facet_wrap(~SampleNames)\n    return(p)\n  }else{\n    sample <- sampleList\n    dataFrame <- as.data.frame(mcols(sample))\n    test <- cbind(\"Sample\",dataFrame)\n    p <- makerfvsrnPlot(test)\n    return(p)\n  }\n}\n\n\nDupRateVsTotal <- function(sampleList,colourByScore=F){\n  if(class(sampleList) == \"list\"){\n    bigFrame <- NULL\n    lengthsForNames <- lapply(sampleList,length)\n    SampleNames <- unlist(lapply(1:length(lengthsForNames),function(x)rep(names(sampleList)[x],lengthsForNames[[x]])))\n    for(i in 1:length(sampleList)){\n      bigFrame <- rbindMcols(bigFrame,sampleList[[i]])\n    }\n    bigFrame <- cbind(SampleNames,bigFrame)\n    #dataFrame <- as.data.frame(mcols(sample))\n    #test <- cbind(\"Sample\",dataFrame)\n    p <- makeDupRateVsTotal(bigFrame,colourByScore)\n    p <- p+facet_wrap(~SampleNames)\n    return(p)\n  }else{\n    sample <- sampleList\n    dataFrame <- as.data.frame(mcols(sample))\n    test <- cbind(\"Sample\",dataFrame)\n    p <- makeDupRateVsTotal(test)\n    return(p)\n  }\n}\n\nmakerfvsrnPlot <- function(test){\n  #P <- ggplot(test,aes(x=rfSD,y=MMRate))+geom_point(alpha = 1,size=1.3)+theme(axis.title.y=element_text(angle=0))\n  P <- ggplot(test,aes(x=rfSD,y=rnSD))+geom_hex(bins=100)+theme(axis.title.y=element_text(angle=0))\n  return(P)\n}\n\nmakeMMVsAllPlot <- function(test){\n  #P <- ggplot(test,aes(x=rfSD,y=MMRate))+geom_point(alpha = 1,size=1.3)+theme(axis.title.y=element_text(angle=0))\n  P <- ggplot(test,aes(x=rfSD,y=MMRate))+geom_hex(bins=100)+theme(axis.title.y=element_text(angle=0))\n  return(P)\n}\n\nmakeDupRateVsAllPlot <- function(test){\n  #P <- ggplot(test,aes(x=rfSD,y=MMRate))+geom_point(alpha = 1,size=1.3)+theme(axis.title.y=element_text(angle=0))\n  P <- ggplot(test,aes(x=rfSD,y=DupRate))+geom_hex(bins=100)+theme(axis.title.y=element_text(angle=0))\n  return(P)\n}\n\n\n\nmakeDupRateVsMMPlot <- function(test){\n  #P <- ggplot(test,aes(x=rfSD,y=MMRate))+geom_point(alpha = 1,size=1.3)+theme(axis.title.y=element_text(angle=0))\n  P <- ggplot(test,aes(x=MMRate,y=DupRate))+geom_hex(bins=100)+theme(axis.title.y=element_text(angle=0))\n  return(P)\n  \n}\n\nmakeDupRateVsTotal <- function(test,colourByScore=F){\n  if(!colourByScore){\n    P <- ggplot(test,aes(x=log2(Total),y=DupRate))+geom_hex(bins=100)+theme(axis.title.y=element_text(angle=0))\n  }else{\n    P <- ggplot(test,aes(x=log2(Total),y=DupRate, z = rfSD))\n    P <- P + stat_summary_2d(bins=100)+scale_fill_gradient2(low = \"Blue\",mid=\"White\",high=\"Red\",midpoint = 0)\n  }\n  return(P)\n}\n\nmakerfSDscoreDensity <- function(test){\n  #P <- ggplot(test,aes(x=rfSD,y=MMRate))+geom_point(alpha = 1,size=1.3)+theme(axis.title.y=element_text(angle=0))\n  P <- ggplot(test,aes(x=rfSD))+geom_density()+theme(axis.title.y=element_text(angle=0))\n  return(P)\n}\n\n\nrunpeakQCs <- function(x,bamFiles,GRangesOfIs,fragLens,aroundPeakDistCalc=3,aroundPeakDistReadIn=3){\n  \n  bamFile <- bamFiles[x]\n  GRangesOfI <- GRangesOfIs[[x]]\n  fragLen <- fragLens[x]\n  peakQCresult <- file.path(dirname(dirname(bamFile)),\"ChIPQC\",paste0(gsub(\"\\\\.bam\",\"\",basename(bamFile)),\"PeakQC.RData\"))\n  if(!file.exists(peakQCresult)){\n    peakQC <- readClusteringInPeaks(bamFile,\n                                    GRangesOfI,\n                                    fragLen,\n                                    aroundPeakDistCalc=aroundPeakDistCalc,\n                                    aroundPeakDistReadIn=aroundPeakDistReadIn)\n  }\n}    \n    \nreadClusteringInPeaks <- function(bamFile, GRangesOfI, fragLen,aroundPeakDistCalc=3,aroundPeakDistReadIn=3){\n  library(GenomicAlignments)\n  library(Rsamtools)\n  library(tracktables)\n  library(GenomicRanges)\n  library(IRanges)\n  bedRangesTemp <- GRanges()\n  \n  GRangesOfITempList <- list()\n  \n  \n  \n  oldGRangesOfI <- GRangesOfI\n  \n  GRangesOfI <- resize(GRangesOfI,fragLen*aroundPeakDistCalc,fix = \"center\")\n  \n  ChrLengths <- scanBamHeader(bamFile)[[1]]$targets\n  \n  Param <- ScanBamParam(which=resize(GRangesOfI,fragLen*aroundPeakDistReadIn,fix = \"center\"),\n                        \n                        what=c(\"flag\",\"mapq\"))\n  message(paste0(\"Reading data for \",bamFile),appendLF = T)\n  \n  Sample_GIT <- readGAlignments(bamFile,param=Param)\n  \n  for(k in 1:length(ChrLengths)){\n    message(paste0(\"Calculating stats for \",names(ChrLengths)[k]),appendLF = T)\n    \n    PosCoverage <- coverage(IRanges(start(Sample_GIT[strand(Sample_GIT)==\"+\" & seqnames(Sample_GIT) == names(ChrLengths)[k]]),start(Sample_GIT[strand(Sample_GIT)==\"+\" & seqnames(Sample_GIT) == names(ChrLengths)[k]])),width=ChrLengths[k])\n    \n    NegCoverage <- coverage(IRanges(end(Sample_GIT[strand(Sample_GIT)==\"-\" & seqnames(Sample_GIT) == names(ChrLengths)[k]]),end(Sample_GIT[strand(Sample_GIT)==\"-\" & seqnames(Sample_GIT) == names(ChrLengths)[k]])),width=ChrLengths[k])\n    \n    test <- shiftApply(c(0,50,seq(fragLen-5,fragLen+5,1)),PosCoverage,NegCoverage,function(x,y)x+y)\n    \n    covShift <- list()\n    \n    tempPos <- PosCoverage\n    tempNeg <- NegCoverage\n    # tempPos[tempPos > 1] <- 1\n    # tempNeg[tempNeg > 1] <- 1 \n    message(\"Calculating reads in peaks\",appendLF = T)\n    posAll <- viewSums(Views(tempPos,ranges(GRangesOfI[seqnames(GRangesOfI) == names(ChrLengths)[k],])))\n    negAll <- viewSums(Views(tempNeg,ranges(GRangesOfI[seqnames(GRangesOfI) == names(ChrLengths)[k],])))\n    tempPos <- PosCoverage\n    tempNeg <- NegCoverage\n    tempPos[tempPos < 2] <- 0\n    tempNeg[tempNeg < 2] <- 0\n    tempPos[tempPos > 1] <-  tempPos[tempPos > 1] - 1\n    tempNeg[tempNeg > 1] <-  tempNeg[tempNeg > 1] - 1\n    message(\"Calculating duplicates in peaks\",appendLF = T)\n    \n    posDups <- viewSums(Views(tempPos,ranges(GRangesOfI[seqnames(GRangesOfI) == names(ChrLengths)[k],])))\n    negDups <- viewSums(Views(tempNeg,ranges(GRangesOfI[seqnames(GRangesOfI) == names(ChrLengths)[k],])))\n    \n    message(\"Calculating local shifted coverage in peaks\",appendLF = T)\n    for(l in 1:length(test)){\n      \n      temp <- test[[l]]\n      \n      temp[temp > 1] <- 1\n      \n      covShift[[l]] <- viewSums(Views(temp,ranges(GRangesOfI[seqnames(GRangesOfI) == names(ChrLengths)[k],])))\n      \n    }\n    \n    covShiftMat <- do.call(cbind,covShift)\n    \n    message(\"Calculating multimapping..\",appendLF = T)\n    PosCoverageMM <- coverage(IRanges(start(Sample_GIT[mcols(Sample_GIT)$mapq==0 & strand(Sample_GIT)==\"+\" & seqnames(Sample_GIT) == names(ChrLengths)[k]]),start(Sample_GIT[mcols(Sample_GIT)$mapq==0 & strand(Sample_GIT)==\"+\" & seqnames(Sample_GIT) == names(ChrLengths)[k]])),width=ChrLengths[k])\n    \n    NegCoverageMM <- coverage(IRanges(end(Sample_GIT[mcols(Sample_GIT)$mapq==0 & strand(Sample_GIT)==\"-\" & seqnames(Sample_GIT) == names(ChrLengths)[k]]),end(Sample_GIT[mcols(Sample_GIT)$mapq==0 & strand(Sample_GIT)==\"-\" & seqnames(Sample_GIT) == names(ChrLengths)[k]])),width=ChrLengths[k])\n    \n    \n    tempPosMM <- PosCoverageMM\n    tempNegMM <- NegCoverageMM\n    #tempPos[tempPos > 1] <- 1\n    #tempNeg[tempNeg > 1] <- 1 \n    posAllMM <- viewSums(Views(tempPosMM,ranges(GRangesOfI[seqnames(GRangesOfI) == names(ChrLengths)[k],])))\n    negAllMM <- viewSums(Views(tempNegMM,ranges(GRangesOfI[seqnames(GRangesOfI) == names(ChrLengths)[k],])))\n    \n    readToFragmentShiftDiff <- rowMeans(covShiftMat[,-c(1,2),drop=FALSE])-covShiftMat[,2,drop=FALSE]\n    readsToNoShiftDiff <-  covShiftMat[,1,drop=FALSE]-covShiftMat[,2,drop=FALSE]\n    dupRates <- cbind(unlist(posDups),unlist(negDups),unlist(posAllMM),unlist(negAllMM),\n                      unlist(posAll),unlist(negAll))\n    colnames(dupRates) <- c(\"PosDups\",\"NegDups\",\"PosMultiMapping\",\"NegMultiMapping\",\"PosAll\",\"NegAll\")\n    GRangesOfITemp <- GRangesOfI[seqnames(GRangesOfI) == names(ChrLengths)[k],]\n    \n    mcols(GRangesOfITemp) <- cbind(as.data.frame(mcols(GRangesOfITemp)),covShiftMat,readToFragmentShiftDiff,readsToNoShiftDiff,dupRates)\n    \n    GRangesOfITemp <- GRangesOfITemp[order(readToFragmentShiftDiff,decreasing=T),]\n    \n    GRangesOfITempList[[k]] <- GRangesOfITemp \n    \n    print(names(ChrLengths)[k])\n    \n  }  \n  \n  temp <- unlist(GRangesList(GRangesOfITempList))\n  \n  temp <- temp[order(temp$readToFragmentShiftDiff),]\n  \n  temp2 <- temp\n  \n  mcols(temp2) <- mcols(temp2)[,c(\"readToFragmentShiftDiff\")]\n  #makebedtable(temp2[order(temp2$X),],paste0(gsub(\".bam\",\"\",basename(bamFile)),\"rankedBySCCovScore.html\"),getwd())\n  peakQC = list(temp,temp2)\n  peakQCresult <- file.path(dirname(dirname(bamFile)),\"ChIPQC\",paste0(gsub(\"\\\\.bam\",\"\",basename(bamFile)),\"PeakQC.RData\"))\n  save(peakQC,file=peakQCresult)\n  return(peakQC)\n}\n\n#library(ggplot2)\n\n\nfastaToGTF <- function(fasta){\n  return(\"x\")\n}\n\n\nsuppressPackageStartupMessages(library(gplots))\nsuppressPackageStartupMessages(library(topGO))\nsuppressPackageStartupMessages(library(org.Hs.eg.db))\n\n\nmakeConsensusPeaks <- function(){\n  \n}\nreSummit <- function(){\n  \n}  \n\n\ncallSampleSheetSicer <- function(dfSS,bamsDir,peaksDir,sicerExecutable,sicerPath,fastaLengths,stdoutDir,stderrDir,callSingleSampleSicer,callSingleSampleSicerNoInput){\n  \n  dfSS <- dfSS[!is.na(dfSS$InputToUse),,drop=FALSE]\n  print(nrow(dfSS))\n  peakCalls_MACS2_List <-  bplapply(1:nrow(dfSS),function(x,bamsDir,peaksDir,dfSS,fastaLengths,sicerExecutable,sicerPath,stdoutDir,stderrDir,callSingleSampleSicer,callSingleSampleSicerNoInput)\n    if(!is.na(dfSS$InputToUse[x])){\n      if(dfSS$InputToUse[x] != dfSS$GenomicsID[x]){\n        print(\"hereIAM\")\n        TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\".bam\"))\n        controlID <- dfSS$InputToUse[x]\n        CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\".bam\"))\n        OUTDIR <- file.path(peaksDir,\"MACS2\",dfSS$GenomicsID[x])\n        format <- ifelse(grepl(\";\",dfSS$FQLocation[x]),\"BAMPE\",\"BAM\")\n        # if(grepl(\";\",dfSS$FQLocation[x])){\n        #   if(!file.exists(file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\")))){\n        #     require(rtracklayer)\n        #     require(GenomicAlignments)\n        #     test <- readGAlignmentPairs(TESTSAMPLE,param=ScanBamParam(what=c(\"qname\",\"flag\",\"rname\",\"strand\",\"pos\",\"qwidth\",\"mapq\",\"cigar\",\"mrnm\",\"mpos\",\"isize\",\"seq\",\"qual\",\"groupid\",\"mate_status\")))\n        #     test2 <- test[elementMetadata(first(test))$mapq != 0 & elementMetadata(second(test))$mapq != 0]\n        #     TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\"))\n        #     CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\"_forMACS2.bam\"))\n        # \n        #     export(test2,TESTSAMPLE,\"bam\")\n        #   }else{\n        #     TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\"))\n        #     CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\"_forMACS2.bam\"))\n        # \n        #   }\n        # }else{\n        \n        \n        # }\n        dir.create(OUTDIR,showWarnings = FALSE)\n        NAME <- paste0(dfSS$GenomicsID[x],\"_withInput_\",dfSS$InputToUse[x])\n        BROADT <- dfSS$BroadCall[x]\n        if(is.na(BROADT) | BROADT == \"\") BROADT <- FALSE\n        peakCalls_MACS2 <- callSingleSampleSicer(basename(TESTSAMPLE),basename(CONTROLSAMPLE),bamsDir,peaksDir,fastaLengths,notSure=1,window=200,\n                                                 shiftSize=140,\n                                                 notSure2=0.74,\n                                                 gapSize=1000,\n                                                 FDR=0.01,                                  \n                                                 sicerExec=sicerExecutable,\n                                                 pythonExec=\"/rugpfs/fs0/ruit/scratch/tcarroll/python2713/bin/python\",\n                                                 sicerDir=sicerPath,\n                                                 stdoutDir=\"\",stderrDir=\"\")\n      }else{\n        print(\"hereIAM\")\n        TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\".bam\"))\n        controlID <- dfSS$InputToUse[x]\n        CONTROLSAMPLE <- \"\"\n        OUTDIR <- file.path(peaksDir,\"MACS2\",dfSS$GenomicsID[x])\n        format <- ifelse(grepl(\";\",dfSS$FQLocation[x]),\"BAMPE\",\"BAM\")\n        # if(grepl(\";\",dfSS$FQLocation[x])){\n        #   if(!file.exists(file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\")))){\n        #     require(rtracklayer)\n        #     require(GenomicAlignments)\n        #     test <- readGAlignmentPairs(TESTSAMPLE,param=ScanBamParam(what=c(\"qname\",\"flag\",\"rname\",\"strand\",\"pos\",\"qwidth\",\"mapq\",\"cigar\",\"mrnm\",\"mpos\",\"isize\",\"seq\",\"qual\",\"groupid\",\"mate_status\")))\n        #     test2 <- test[elementMetadata(first(test))$mapq != 0 & elementMetadata(second(test))$mapq != 0]\n        #     TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\"))\n        #     CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\"_forMACS2.bam\"))\n        # \n        #     export(test2,TESTSAMPLE,\"bam\")\n        #   }else{\n        #     TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\"))\n        #     CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\"_forMACS2.bam\"))\n        # \n        #   }\n        # }else{\n        \n        \n        # }\n        dir.create(OUTDIR,showWarnings = FALSE)\n        NAME <- paste0(dfSS$GenomicsID[x],\"_withInput_\",dfSS$InputToUse[x])\n        BROADT <- dfSS$BroadCall[x]\n        if(is.na(BROADT) | BROADT == \"\") BROADT <- FALSE\n        peakCalls_MACS2 <- callSingleSampleSicerNoInput(basename(TESTSAMPLE),CONTROLSAMPLE,bamsDir,peaksDir,fastaLengths,notSure=1,window=200,\n                                                        shiftSize=140,\n                                                        notSure2=0.74,\n                                                        gapSize=1000,\n                                                        FDR=0.01,                                  \n                                                        sicerExec=sicerExecutable,\n                                                        pythonExec=\"/rugpfs/fs0/ruit/scratch/tcarroll/python2713/bin/python\",\n                                                        sicerDir=sicerPath,\n                                                        stdoutDir=\"\",stderrDir=\"\")\n      }\n    },bamsDir,peaksDir,dfSS,fastaLengths,sicerExecutable,sicerPath,stdoutDir,stderrDir,callSingleSampleSicer,callSingleSampleSicerNoInput)\n  #MacsVersion <- system2(macsExecutable,\"--version\",stderr = TRUE,stdout=TRUE)\n  #versions <- list(\"MACS2\"=as.character(MacsVersion))\n  names(peakCalls_MACS2_List) <- dfSS$GenomicsID\n  #c(peakCalls_MACS2_List,versions)}\n  c(peakCalls_MACS2_List)}\n\n# TESTSAMPLE <- paste0(bams[8],\".bam\")\n# CONTROLSAMPLE <- paste0(bams[4],\".bam\")\n# OUTDIR <- file.path(peaksDir,\"MACS2\",paste0(basename(bams[8])))\n# NAME <- paste0(basename(bams[8]),\"_withInput_\",basename(bams[4]))\n#\n# TESTSAMPLE <- paste0(bams[5],\".bam\")\n# CONTROLSAMPLE <- paste0(bams[11],\".bam\")\n# OUTDIR <- file.path(peaksDir,\"MACS2\",paste0(basename(bams[5])))\n# NAME <- paste0(basename(bams[5]),\"_withInput_\",basename(bams[11]))\n\ncallSingleSampleSicer <- function(TestFile,ControlFile,bamsDir,PeakDirectory,fastaLengths,\n                                  notSure=1,\n                                  window=200,\n                                  shiftSize=140,\n                                  notSure2=0.74,\n                                  gapSize=1000,\n                                  FDR=0.01,                                  \n                                  sicerExec=\"~/Projects/Software/Github/chipseq-pipeline/Process10/BashScripts/SICER.sh\",\n                                  pythonExec=\"/rugpfs/fs0/ruit/scratch/tcarroll/python2713/bin/python\",\n                                  sicerDir=\"~/Downloads/SICER_V1.1_2/SICER/\",\n                                  stdoutDir=\"\",stderrDir=\"\"){\n  \n  # sicerExec <- \"~/Projects/Software/Github/chipseq-pipeline/Process10/BashScripts/SICER.sh\"\n  # bamDir <- \"~/Downloads\"\n  # TestFile <- \"\"\n  # ControlFile <- \n  # PeakDirectory <- \n  # fastaLengths <- \n  # notSure <- 1\n  # window <- 200\n  # shiftSize <- 140\n  # notSure2 <- 0.74\n  # gapSize <- 1000\n  # FDR <- 0.01\n  # sicerDir <- \"~/Downloads/SICER_V1.1_2/SICER/\"\n  # pythonExec <- \"python\"\n  # sh ~/Projects/Software/Github/chipseq-pipeline/Process10/BashScripts/SICER.sh ~/Downloads ENCFF223KED_forSicer.bed ENCFF128QRQ_forSicer.bed ~/Downloads/MySicerOut /Users/tcarroll/Downloads/BSgenome.Mmusculus.UCSC.mm10_ChrLengths.txt 1 200 140 0.74 1000 0.01 ~/Downloads/SICER_V1.1_2/SICER/ python\n  \n  \n  dir.create(PeakDirectory, showWarnings=FALSE, recursive=TRUE)\n  \n  require(Rsamtools)\n  require(GenomicAlignments)\n  require(rtracklayer)\n  \n  NAME <- paste0(gsub(\"Sorted|\\\\.bam\",\"\",TestFile),\"_\",gsub(\"Sorted|\\\\.bam\",\"\",ControlFile))\n  PeakDirectory <- file.path(PeakDirectory,NAME)\n  dir.create(PeakDirectory, showWarnings=FALSE, recursive=TRUE)\n  setwd(PeakDirectory)\n  TestFile <- file.path(bamsDir,TestFile)\n  ControlFile <- file.path(bamsDir,ControlFile)\n  if(file.exists(TestFile) & is.na(index(BamFile(TestFile)))){\n    message(\"Creating index for \",TestFile)\n    indexBam(TestFile)\n    message(\"..done\")\n  }\n  if(file.exists(ControlFile) & is.na(index(BamFile(ControlFile)))){\n    message(\"Creating index for \",ControlFile)\n    indexBam(ControlFile)\n    message(\"..done\")\n  }\n  \n  TESTSAMPLE <- file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TestFile)),\"_forSicer.bed\"))\n  CONTROLSAMPLE <- file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TestFile)),\"_Vs_\",gsub(\"\\\\.bam\",\"\",basename(ControlFile)),\"_forSicer.bed\"))\n  \n  if(!file.exists(TESTSAMPLE)){\n    test <- readGAlignments(TestFile,param=ScanBamParam(what=c(\"mapq\")))\n    test2 <- test[elementMetadata(test)$mapq != 0 & ((strand(test) == \"+\" & !duplicated(start(test))) | (strand(test) == \"-\" & !duplicated(end(test)))),]\n    export.bed(GRanges(test2),con=TESTSAMPLE)\n  }\n  if(!file.exists(CONTROLSAMPLE)){  \n    control <- readGAlignments(ControlFile,param=ScanBamParam(what=c(\"mapq\")))\n    control2 <- control[elementMetadata(control)$mapq != 0 & ((strand(control) == \"+\" & !duplicated(start(control))) | (strand(control) == \"-\" & !duplicated(end(control)))),]\n    export.bed(GRanges(control2),con=CONTROLSAMPLE)\n  }\n  OUTDIR <- PeakDirectory\n  require(GenomicRanges)\n  sicerFiles <- dir(OUTDIR,full.names = T)\n  temp <- \"\"\n  ARGS <- c(bamsDir,\n            basename(TESTSAMPLE),\n            basename(CONTROLSAMPLE),\n            PeakDirectory,\n            fastaLengths,\n            notSure,\n            window,\n            shiftSize,\n            notSure2,\n            gapSize,\n            FDR,\n            sicerDir,\n            pythonExec\n  )\n  stdoutDir <- getwd()\n  stderrDir <- getwd()\n  temp <- system2(sicerExec,\n                  args =  ARGS,\n                  stdout = file.path(stdoutDir,paste0(\"SICER_\",NAME,\".txt\")),\n                  stderr = file.path(stderrDir,paste0(\"SICER_\",NAME,\".txt\")),\n  )\n  return(temp)\n}\n\n\n\ncallSingleSampleSicerNoInput <- function(TestFile,ControlFile,bamsDir,PeakDirectory,fastaLengths,\n                                         notSure=1,\n                                         window=200,\n                                         shiftSize=140,\n                                         notSure2=0.74,\n                                         gapSize=1000,\n                                         FDR=0.01,                                  \n                                         sicerExec=\"/Users/tcarroll/Downloads/SICER_V1.1_2/SICER//SICER-rb.sh\",\n                                         pythonExec=\"/rugpfs/fs0/ruit/scratch/tcarroll/python2713/bin/python\",\n                                         sicerDir=\"~/Downloads/SICER_V1.1_2/SICER/\",\n                                         stdoutDir=\"\",stderrDir=\"\"){\n  \n  # sicerExec <- \"~/Projects/Software/Github/chipseq-pipeline/Process10/BashScripts/SICER.sh\"\n  # bamDir <- \"~/Downloads\"\n  # TestFile <- \"\"\n  # ControlFile <- \n  # PeakDirectory <- \n  # fastaLengths <- \n  # notSure <- 1\n  # window <- 200\n  # shiftSize <- 140\n  # notSure2 <- 0.74\n  # gapSize <- 1000\n  # FDR <- 0.01\n  # sicerDir <- \"~/Downloads/SICER_V1.1_2/SICER/\"\n  # pythonExec <- \"python\"\n  # sh ~/Projects/Software/Github/chipseq-pipeline/Process10/BashScripts/SICER.sh ~/Downloads ENCFF223KED_forSicer.bed ENCFF128QRQ_forSicer.bed ~/Downloads/MySicerOut /Users/tcarroll/Downloads/BSgenome.Mmusculus.UCSC.mm10_ChrLengths.txt 1 200 140 0.74 1000 0.01 ~/Downloads/SICER_V1.1_2/SICER/ python\n  \n  \n  dir.create(PeakDirectory, showWarnings=FALSE, recursive=TRUE)\n  \n  require(Rsamtools)\n  require(GenomicAlignments)\n  require(rtracklayer)\n  \n  NAME <- paste0(gsub(\"Sorted|\\\\.bam\",\"\",TestFile),\"_\",gsub(\"Sorted|\\\\.bam\",\"\",ControlFile))\n  PeakDirectory <- file.path(PeakDirectory,NAME)\n  dir.create(PeakDirectory, showWarnings=FALSE, recursive=TRUE)\n  setwd(PeakDirectory)\n  message(PeakDirectory)\n  TestFile <- file.path(bamsDir,TestFile)\n  ControlFile <- file.path(bamsDir,ControlFile)\n  if(file.exists(TestFile) & is.na(index(BamFile(TestFile)))){\n    message(\"Creating index for \",TestFile)\n    indexBam(TestFile)\n    message(\"..done\")\n  }\n  \n  TESTSAMPLE <- file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TestFile)),\"_forSicer.bed\"))\n  \n  if(!file.exists(TESTSAMPLE)){\n    message(TESTSAMPLE)\n    test <- readGAlignments(TestFile,param=ScanBamParam(what=c(\"mapq\")))\n    test2 <- test[elementMetadata(test)$mapq != 0 & ((strand(test) == \"+\" & !duplicated(start(test))) | (strand(test) == \"-\" & !duplicated(end(test)))),]\n    export.bed(GRanges(test2),con=TESTSAMPLE)\n  }\n  OUTDIR <- PeakDirectory\n  require(GenomicRanges)\n  sicerFiles <- dir(OUTDIR,full.names = T)\n  temp <- \"\"\n  ARGS <- c(bamsDir,\n            basename(TESTSAMPLE),\n            PeakDirectory,\n            fastaLengths,\n            notSure,\n            window,\n            shiftSize,\n            notSure2,\n            gapSize,\n            sicerDir,\n            pythonExec\n  )\n  stdoutDir <- getwd()\n  stderrDir <- getwd()\n  temp <- system2(sicerExec,\n                  args =  ARGS,\n                  stdout = file.path(\"/Users/tcarroll/Projects/Results/chipseq/testRunBroad/\",paste0(\"SICER_\",NAME,\".txt\")),\n                  stderr = file.path(\"/Users/tcarroll/Projects/Results/chipseq/testRunBroad/\",paste0(\"SICER_\",NAME,\".txt\")),\n  )\n  return(temp)\n}\n\natacQC <- function(sortedBAM,IGVpos,statsDir,chrOfInterest=NULL){\n  require(GenomicRanges)\n  IGVGenePositions <- read.delim(IGVpos,sep=\"\\t\")\n  genePos <- makeGRangesFromDataFrame(IGVGenePositions)\n  names(genePos) <- IGVGenePositions$gene_id\n  \n  tssPos <- resize(genePos,fix=\"start\",1)\n  \n  # To remove\n  # require(TxDb.Mmusculus.UCSC.mm10.knownGene)\n  # TSSs <- resize(genes(TxDb.Mmusculus.UCSC.mm10.knownGene),fix=\"start\",1)\n  # TSSs\n  #\n  require(GenomicAlignments)\n  require(Rsamtools)\n  #sortedBAM <- BamFile(\"~/Projects/Results//Fuchs/SamanthaAtac/Sorted_D45_Ctrl.bam\")\n  allC <- seqlengths(BamFile(sortedBAM))\n  notM <- allC[!names(allC) %in% c(\"chrM\",\"M\",\"MT\",\"chrMT\",\"ChrM\",\"ChrMT\",\"mt\",\"m\")]\n  notMGRanes <- GRanges(names(notM), IRanges(1,notM))\n  atacReads <- readGAlignmentPairs(sortedBAM,\n                                 param=ScanBamParam(mapqFilter=1, \n                                                    flag=scanBamFlag(isPaired = TRUE, \n                                                                     isProperPair =TRUE), \n                                                    what=c(\"qname\",\"mapq\",\"isize\"), which=notMGRanes))\n  atacReads_read1 <- GenomicAlignments::first(atacReads)\n  insertSizes <- abs(elementMetadata(atacReads_read1)$isize)\n  \n  library(magrittr)\n  library(dplyr)\n  library(ggplot2)\n  \n  toWriteInserts <- table(insertSizes) %>%\n    data.frame %>% \n    rename(InsertSize=insertSizes,Count=Freq) %>% \n    mutate(InsertSize=as.numeric(as.vector(InsertSize)),Count=as.numeric(as.vector(Count)))\n  \n  write.table(toWriteInserts,file=file.path(statsDir,gsub(\"\\\\.bam\",\".correctFrags\",basename(sortedBAM))))\n  # fragLenPlot <- table(insertSizes) %>%\n  #   data.frame %>% \n  #   rename(InsertSize=insertSizes,Count=Freq) %>% \n  #   mutate(InsertSize=as.numeric(as.vector(InsertSize)),Count=as.numeric(as.vector(Count))) %>% \n  #   ggplot(aes(x=InsertSize,y=Count))+geom_line()\n  # \n  # fragLenPlot+theme_bw()\n  # fragLenPlot + scale_y_continuous(trans='log2')+theme_bw()\n  library(soGGi)\n  \n  \n  # Nucleosome free\n  #sortedBAM <- \"~/Projects/Results//Fuchs/SamanthaAtac/Sorted_D45_Ctrl.bam\"\n  nucFree <- regionPlot(bamFile = sortedBAM,\n                        testRanges = tssPos,\n                        style = \"point\",\n                        format=\"bam\",\n                        paired=TRUE,\n                        minFragmentLength = 0,maxFragmentLength = 100,forceFragment = 50)\n  save(nucFree,file=file.path(statsDir,gsub(\"\\\\.bam\",\"soggi_NucFree.RData\",basename(sortedBAM))))\n  # Mononucleosome\n  monoNuc <- regionPlot(bamFile = sortedBAM,\n                        testRanges = tssPos,\n                        style = \"point\",\n                        format=\"bam\",\n                        paired=TRUE,\n                        minFragmentLength = 180,maxFragmentLength = 240,forceFragment = 80)\n  save(monoNuc,file=file.path(statsDir,gsub(\"\\\\.bam\",\"soggi_monoNuc.RData\",basename(sortedBAM))))\n  \n}\n\n\ncallSingleSampleHomer <- function(TestFile,ControlFile,bamsDir,PeakDirectory,\n                                  notSure=1,\n                                  size=1000,\n                                  minDistance=2500,\n                                  notSure2=0.74,\n                                  gapSize=1000,\n                                  FDR=0.01,                                  \n                                  homerDir=\"/Users/tcarroll/Projects/Software/Homer/\",Paired=TRUE){\n  \n  # sicerExec <- \"~/Projects/Software/Github/chipseq-pipeline/Process10/BashScripts/SICER.sh\"\n  # bamDir <- \"~/Downloads\"\n  # TestFile <- \"\"\n  # ControlFile <- \n  # PeakDirectory <- \n  # fastaLengths <- \n  # notSure <- 1\n  # window <- 200\n  # shiftSize <- 140\n  # notSure2 <- 0.74\n  # gapSize <- 1000\n  # FDR <- 0.01\n  # sicerDir <- \"~/Downloads/SICER_V1.1_2/SICER/\"\n  # pythonExec <- \"python\"\n  # sh ~/Projects/Software/Github/chipseq-pipeline/Process10/BashScripts/SICER.sh ~/Downloads ENCFF223KED_forSicer.bed ENCFF128QRQ_forSicer.bed ~/Downloads/MySicerOut /Users/tcarroll/Downloads/BSgenome.Mmusculus.UCSC.mm10_ChrLengths.txt 1 200 140 0.74 1000 0.01 ~/Downloads/SICER_V1.1_2/SICER/ python\n  # TestFile <- \"Sorted_H3K27Ac_Limb_1.bam\"\n  # ControlFile <- \"Sorted_Input_Limb.bam\"\n  # bamsDir <- \"~/Projects/Results/chipseq/testRunBroad/BAMs/\"\n  # PeakDirectory <- \"~/Projects/Results/chipseq/testRunBroad/Peaks/\"\n  # size=1000\n  # minDistance=2500\n  \n  dir.create(PeakDirectory, showWarnings=FALSE, recursive=TRUE)\n  \n  require(Rsamtools)\n  require(GenomicAlignments)\n  require(rtracklayer)\n  \n  makeTagDirCommand <- file.path(homerDir,\"bin\",\"makeTagDirectory\")\n  findPeaksCommand <- file.path(homerDir,\"bin\",\"findPeaks\")\n  \n  NAME <- paste0(gsub(\"Sorted|\\\\.bam\",\"\",TestFile),\"_\",gsub(\"Sorted|\\\\.bam\",\"\",ControlFile))\n  PeakDirectory <- file.path(PeakDirectory,paste0(NAME,\"_Homer\"))\n  dir.create(PeakDirectory, showWarnings=FALSE, recursive=TRUE)\n  #setwd(PeakDirectory)\n  TestFile <- file.path(bamsDir,TestFile)\n  ControlFile <- file.path(bamsDir,ControlFile)\n  if(file.exists(TestFile) & is.na(index(BamFile(TestFile)))){\n    message(\"Creating index for \",TestFile)\n    indexBam(TestFile)\n    message(\"..done\")\n  }\n  if(file.exists(ControlFile) & is.na(index(BamFile(ControlFile)))){\n    message(\"Creating index for \",ControlFile)\n    indexBam(ControlFile)\n    message(\"..done\")\n  }\n  \n  # TESTSAMPLE <- file.path(bamsDir,basename(TestFile))\n  # CONTROLSAMPLE <- file.path(bamsDir,basename(ControlFile))\n  TESTSAMPLE <- file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TestFile)),\"_forHomer.bam\"))\n  CONTROLSAMPLE <- file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TestFile)),\"_Vs_\",gsub(\"\\\\.bam\",\"\",basename(ControlFile)),\"_forHomer.bam\"))\n  if(Paired){\n    if(!file.exists(TESTSAMPLE)){\n      require(rtracklayer)\n      require(GenomicAlignments)\n      \n      # \n      # test <- readGAlignments(file.path(bamsDir,basename(TestFile)),param=ScanBamParam(what=c(\"mapq\")))\n      # test2 <- test[elementMetadata(test)$mapq != 0,]\n      \n      test <- readGAlignmentPairs(file.path(bamsDir,basename(TestFile)),param=ScanBamParam(what=c(\"qname\",\"flag\",\"rname\",\"strand\",\"pos\",\"qwidth\",\"mapq\",\"cigar\",\"mrnm\",\"mpos\",\"isize\",\"seq\",\"qual\",\"groupid\",\"mate_status\")))\n      test2 <- test[elementMetadata(first(test))$mapq != 0 & elementMetadata(second(test))$mapq != 0]      \n      \n      TESTSAMPLE <- file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TestFile)),\"_forHomer.bam\"))\n      export(test2,TESTSAMPLE,\"bam\")\n      #export(GRanges(test2),con=TESTSAMPLE)\n      args <- c(file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TESTSAMPLE)),\"_HomerTags\")),\n                TESTSAMPLE,\n                \"-format\",\"sam\")\n      system2(makeTagDirCommand,args)\n      rm(test2)\n      rm(test)\n    }\n    if(!file.exists(CONTROLSAMPLE) & ControlFile != TestFile){  \n      # control <- readGAlignments(ControlFile,param=ScanBamParam(what=c(\"mapq\")))\n      # control2 <- control[elementMetadata(control)$mapq != 0 & ((strand(control) == \"+\" & !duplicated(start(control))) | (strand(control) == \"-\" & !duplicated(end(control)))),]\n      # export.bed(GRanges(control2),con=CONTROLSAMPLE)\n      require(rtracklayer)\n      require(GenomicAlignments)\n      # control <- readGAlignments(file.path(bamsDir,basename(ControlFile)),param=ScanBamParam(what=c(\"mapq\")))\n      # control2 <- control[elementMetadata(control)$mapq != 0,]\n      control <- readGAlignmentPairs(file.path(bamsDir,basename(ControlFile)),param=ScanBamParam(what=c(\"qname\",\"flag\",\"rname\",\"strand\",\"pos\",\"qwidth\",\"mapq\",\"cigar\",\"mrnm\",\"mpos\",\"isize\",\"seq\",\"qual\",\"groupid\",\"mate_status\")))\n      control2 <- control2[elementMetadata(first(control2))$mapq != 0 & elementMetadata(second(control2))$mapq != 0]      \n      \n      CONTROLSAMPLE <- file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TestFile)),\"_Vs_\",gsub(\"\\\\.bam\",\"\",basename(ControlFile)),\"_forHomer.bam\"))\n      export(control2,CONTROLSAMPLE,\"bam\")\n      #export(GRanges(test2),con=TESTSAMPLE)\n      # /Users/tcarroll/Projects/Software/Homer/bin/findPeaks \n      # ~/Projects/Results/Fuchs/Sorted_H3K27Ac_Limb_1/ -i ~/Projects/Results/Fuchs/Sorted_Input_LimbcallingAgainstH3K27Ac_Limb_2_forMACS2/ -region -size 1000 -minDist 2500 -o ~/Projects/Results/Fuchs/Sorted_H3K27Ac_Limb_1_Homer.txt\n      # \n      args <- c(file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(CONTROLSAMPLE)),\"_HomerTags\")),\n                CONTROLSAMPLE,\n                \"-format\",\"sam\")\n      system2(makeTagDirCommand,args)\n      rm(control)\n      rm(control2)\n    }\n  }else{\n    if(!file.exists(TESTSAMPLE)){\n      require(rtracklayer)\n      require(GenomicAlignments)\n      test <- readGAlignments(file.path(bamsDir,basename(TestFile)),param=ScanBamParam(what=c(\"mapq\")))\n      test2 <- test[elementMetadata(test)$mapq != 0,]\n      TESTSAMPLE <- file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TestFile)),\"_forHomer.bam\"))\n      export(test2,TESTSAMPLE,\"bam\")\n      #export(GRanges(test2),con=TESTSAMPLE)\n      args <- c(file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TESTSAMPLE)),\"_HomerTags\")),\n                TESTSAMPLE,\n                \"-format\",\"sam\")\n      system2(makeTagDirCommand,args)\n      rm(test2)\n      rm(test)\n    }\n    if(!file.exists(CONTROLSAMPLE) & ControlFile != TestFile){  \n      # control <- readGAlignments(ControlFile,param=ScanBamParam(what=c(\"mapq\")))\n      # control2 <- control[elementMetadata(control)$mapq != 0 & ((strand(control) == \"+\" & !duplicated(start(control))) | (strand(control) == \"-\" & !duplicated(end(control)))),]\n      # export.bed(GRanges(control2),con=CONTROLSAMPLE)\n      require(rtracklayer)\n      require(GenomicAlignments)\n      control <- readGAlignments(file.path(bamsDir,basename(ControlFile)),param=ScanBamParam(what=c(\"mapq\")))\n      control2 <- control[elementMetadata(control)$mapq != 0,]\n      CONTROLSAMPLE <- file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TestFile)),\"_Vs_\",gsub(\"\\\\.bam\",\"\",basename(ControlFile)),\"_forHomer.bam\"))\n      export(control2,CONTROLSAMPLE,\"bam\")\n      #export(GRanges(test2),con=TESTSAMPLE)\n      # /Users/tcarroll/Projects/Software/Homer/bin/findPeaks \n      # ~/Projects/Results/Fuchs/Sorted_H3K27Ac_Limb_1/ -i ~/Projects/Results/Fuchs/Sorted_Input_LimbcallingAgainstH3K27Ac_Limb_2_forMACS2/ -region -size 1000 -minDist 2500 -o ~/Projects/Results/Fuchs/Sorted_H3K27Ac_Limb_1_Homer.txt\n      # \n      args <- c(file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(CONTROLSAMPLE)),\"_HomerTags\")),\n                CONTROLSAMPLE,\n                \"-format\",\"sam\")\n      system2(makeTagDirCommand,args)\n      rm(control)\n      rm(control2)\n    }    \n  }\n  \n  OUTDIR <- PeakDirectory\n  temp <- \"\"\n  homerOut <- file.path(PeakDirectory,paste0(NAME,\"_homer.txt\"))\n  if(ControlFile != TestFile){\n    ARGS <- c(file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TESTSAMPLE)),\"_HomerTags\")),\n              \"-i\",file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(CONTROLSAMPLE)),\"_HomerTags\")),\n              \"-region\",\n              \"-size\",size,\n              \"-minDist\",minDistance,\n              \"-o\",file.path(PeakDirectory,paste0(NAME,\"_homer.txt\"))\n    )\n  }else{\n    ARGS <- c(file.path(bamsDir,paste0(gsub(\"\\\\.bam\",\"\",basename(TESTSAMPLE)),\"_HomerTags\")),\n              \"-region\",\n              \"-size\",size,\n              \"-minDist\",minDistance,\n              \"-o\",file.path(PeakDirectory,paste0(NAME,\"_homer.txt\"))\n    )    \n  }\n  stdoutDir <- getwd()\n  stderrDir <- getwd()\n  \n  homerBed <- file.path(PeakDirectory,paste0(NAME,\"_homer.bed\"))\n  \n  \n  if(!file.exists(homerBed)){\n    \n    system2(findPeaksCommand,args =  ARGS)\n    # ,\n    #                 stdout = file.path(stdoutDir,paste0(\"HOMER_\",NAME,\".txt\")),\n    #                 stderr = file.path(stderrDir,paste0(\"HOMER_\",NAME,\".txt\")),\n    # )\n    homerPeaks <- read.delim(homerOut,header=FALSE,comment.char = \"#\")\n    toPlot <- GRanges(homerPeaks[,2],IRanges(homerPeaks[,3],homerPeaks[,4]))\n    names(toPlot) <- homerPeaks[,1]\n    export.bed(toPlot,homerBed)\n  }else{\n    temp <- \"\"\n  }\n  return(temp)\n}\n\n\ncallSampleSheetHomer <- function(dfSS,bamsDir,peaksDir,homerPath,stdoutDir,stderrDir,callSingleSampleHomer){\n  \n  dfSS <- dfSS[!is.na(dfSS$InputToUse),,drop=FALSE]\n  print(nrow(dfSS))\n  peakCalls_MACS2_List <-  bplapply(1:nrow(dfSS),function(x,bamsDir,peaksDir,dfSS,homerPath,stdoutDir,stderrDir,callSingleSampleHomer)\n    if(!is.na(dfSS$InputToUse[x])){\n      TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\".bam\"))\n      controlID <- dfSS$InputToUse[x]\n      CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\".bam\"))\n      OUTDIR <- file.path(peaksDir,\"HOMER\",dfSS$GenomicsID[x])\n      format <- ifelse(grepl(\";\",dfSS$FQLocation[x]),\"BAMPE\",\"BAM\")\n      # if(grepl(\";\",dfSS$FQLocation[x])){\n      #   if(!file.exists(file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\")))){\n      #     require(rtracklayer)\n      #     require(GenomicAlignments)\n      #     test <- readGAlignmentPairs(TESTSAMPLE,param=ScanBamParam(what=c(\"qname\",\"flag\",\"rname\",\"strand\",\"pos\",\"qwidth\",\"mapq\",\"cigar\",\"mrnm\",\"mpos\",\"isize\",\"seq\",\"qual\",\"groupid\",\"mate_status\")))\n      #     test2 <- test[elementMetadata(first(test))$mapq != 0 & elementMetadata(second(test))$mapq != 0]\n      #     TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\"))\n      #     CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\"_forMACS2.bam\"))\n      # \n      #     export(test2,TESTSAMPLE,\"bam\")\n      #   }else{\n      #     TESTSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",dfSS$GenomicsID[x],\"_forMACS2.bam\"))\n      #     CONTROLSAMPLE <- file.path(bamsDir,paste0(\"Sorted_\",controlID,\"_forMACS2.bam\"))\n      # \n      #   }\n      # }else{\n      \n      \n      # }\n      dir.create(OUTDIR,showWarnings = FALSE)\n      NAME <- paste0(dfSS$GenomicsID[x],\"_withInput_\",dfSS$InputToUse[x])\n      BROADT <- dfSS$BroadCall[x]\n      if(is.na(BROADT) | BROADT == \"\") BROADT <- FALSE\n      PairedOrNot <- all(grepl(\";\",dfSS$FQLocation[x]))\n      peakCalls_MACS2 <- callSingleSampleHomer(basename(TESTSAMPLE),basename(CONTROLSAMPLE),bamsDir,OUTDIR,\n                                               homerDir=homerPath,Paired=PairedOrNot)\n    },bamsDir,peaksDir,dfSS,homerPath,stdoutDir,stderrDir,callSingleSampleHomer)\n  #MacsVersion <- system2(macsExecutable,\"--version\",stderr = TRUE,stdout=TRUE)\n  #versions <- list(\"MACS2\"=as.character(MacsVersion))\n  names(peakCalls_MACS2_List) <- dfSS$GenomicsID\n  #c(peakCalls_MACS2_List,versions)}\n  c(peakCalls_MACS2_List)}\n\n\n# countDir <- \"/rugpfs/fs0/ruit/scratch/tcarroll/chipSeq/testRunBroad/counts\"\n# DEGdir <- \"/rugpfs/fs0/ruit/scratch/tcarroll/chipSeq/testRunBroad/DE_Genes\"\n# sampleSheet <- read.delim(\"/rugpfs/fs0/ruit/scratch/tcarroll/SampleSheet_BroadChIPseq.csv\",sep=\",\")\n# consensusPeakCountDirs <- dir(countsDir,include.dirs = TRUE,full.names = TRUE)\n# consensusPeakCountDirs <- consensusPeakCountDirs[dir.exists(consensusPeakCountDirs)]\n# countDir=file.path(countsDir,basename(consensusPeakCountDirs))\n# DEGdir=file.path(degDir,basename(consensusPeakCountDirs))\n# x <- 1\nrunNoRepChIP <- function(x,sampleSheet,countDir,DEGdir,callnoRepsResultsChIP,parallelR=FALSE){\n  \n  countDir <- countDir[x]\n  DEGdir <- DEGdir[x]\n  dir.create(DEGdir,showWarnings = FALSE)\n  noRepDEGdir <- gsub(\"DE_Genes\",\"DE_Genes_NoRep\",DEGdir)\n  message(noRepDEGdir)\n  dir.create(noRepDEGdir,showWarnings = FALSE,recursive = TRUE)\n  # sampleSheet <- newAnalysis\n  # countDir <- file.path(countsDir,basename(consensusPeakCountDirs[i]))\n  # DEGdir <- file.path(degDir,basename(consensusPeakCountDirs[i]))\n  # parallelR=FALSE\n  require(tximport)\n  require(DESeq2)\n  DEseq2Res <- list()\n  if(file.exists(file.path(DEGdir,\"dds.RData\"))){\n    load(file.path(DEGdir,\"dds.RData\"))\n    # load(\"Shruti/chipseqUpdated2018Collapsed/DE_Genes/TSS_Positions/dds.RData\")\n    #sampleSheet <- read.delim(\"/rugpfs/fs0/ruit/scratch/tcarroll/Ja2108Mnt_ColRel.csv\",sep=\",\")\n    #sampleSheet$Antibody <- factor(gsub(\"_.*\",\"\",sampleSheet$Antibody))\n    sampleSheet <- sampleSheet[sampleSheet$GenomicsID %in% rownames(colData(dds)),]\n    fullCounts <- counts(dds,normalized=FALSE)\n    fullCounts <- fullCounts[,match(sampleSheet$GenomicsID,colnames((fullCounts)))]\n    \n    uniqueAntibodies <- unique(sampleSheet$Antibody)\n    # if(grepl(\"^Antibody_\",basename(countDir))){\n    #   antibodyToFilter <- gsub(\"^Antibody_\",\"\",basename(countDir))\n    #   sampleSheet <- sampleSheet[sampleSheet$Antibody %in% antibodyToFilter,]\n    #   fullCounts <- fullCounts[,colnames(fullCounts) %in% sampleSheet$GenomicsID]\n    # }\n    print(uniqueAntibodies)\n    if(length(uniqueAntibodies) > 0){\n      for(i in 1:length(uniqueAntibodies)){\n        DEGdir2 <- file.path(noRepDEGdir,uniqueAntibodies[i])\n        dir.create(DEGdir2,showWarnings = FALSE)\n        \n        antibodyToFilter <- uniqueAntibodies[i]\n        sampleSheet2 <- sampleSheet[sampleSheet$Antibody %in% antibodyToFilter,]\n        \n        fullCounts2 <- fullCounts[,colnames(fullCounts) %in% sampleSheet2$GenomicsID,drop=FALSE]\n        print(antibodyToFilter)\n        metadata <- dplyr::select(sampleSheet2,-GenomicsID,-FQLocation,-InputToUse,-toMerge,-BroadCall)\n        group <- gsub(\"_+$\",\"\",apply(metadata,1,paste,sep=\"_\",collapse=\"_\"))\n        #names(files) <- basename(dirname(files))\n        \n        sampleTable <- data.frame(Group = factor(make.names(group)))\n        rownames(sampleTable) <- colnames(fullCounts2)\n        \n        #plotPCA(toPlot,intgroup=\"Group\")\n        \n        # AllComparisons <- unique(combn(group,2,FUN = function(x)paste(x,collapse=\"_\"),simplify = T))\n        # AllComparisons <- unique(combn(group,2,simplify = T))\n        # AllComparisons <- AllComparisons[,!AllComparisons[1,] == AllComparisons[2,]]\n        # pairWiseComparison <- paste(AllComparisons[1,],AllComparisons[2,],sep=\"Vs\")\n        # AllComparisons <- AllComparisons[,match(unique(pairWiseComparison),pairWiseComparison),drop=F]\n        # pairWiseComparison <- pairWiseComparison[match(unique(pairWiseComparison),pairWiseComparison)]\n        # allComparisonList <- unlist(apply(AllComparisons,2,function(x)list(x)),recursive = F)\n        # names(allComparisonList) <- pairWiseComparison\n        \n        # contrastVector <- resultsNames(dds)\n        # contrastVector <- contrastVector[contrastVector != \"Intercept\"]\n        contrastsFile <- file.path(DEGdir2,\"Contrasts.txt\")\n        if(!file.exists(contrastsFile)){\n          ToExpand <- as.vector(unique(sampleTable$Group))\n          kl <- expand.grid(ToExpand,\n                            ToExpand)\n          kl <- kl[kl[,1,drop=FALSE] != kl[,2,drop=FALSE],,drop=FALSE]\n          kl <- t(apply(kl,1,sort))\n          kl <- kl[!duplicated(paste(kl[,1,drop=FALSE],kl[,2,drop=FALSE],sep=\"_\")),,drop=FALSE]\n          write.table(kl,contrastsFile,sep=\"\\t\",quote=FALSE,row.names=FALSE,col.names=FALSE)\n        }else{\n          kl <- read.delim(contrastsFile,sep=\"\\t\",header=FALSE)\n        }\n        #contrastVector <- paste0(\"Group_\",kl[,1],\"_vs_\",kl[,2])\n        contrastVector <- apply(kl,1,function(x)as.list(x))\n        DEseq2Res <- lapply(contrastVector,callnoRepsResultsChIP,ddsObject=fullCounts2,metaData=sampleTable,DEGdir=DEGdir2,countDir=countDir,parallelR=parallelR)\n        \n        names(DEseq2Res) <- contrastVector\n      }\n    }\n    \n    \n  }else{\n    print(\"Ohh\")\n    #antibodyToFilter <- uniqueAntibodies[i]\n    #sampleSheet2 <- sampleSheet[sampleSheet$Antibody %in% antibodyToFilter,]\n    sampleSheet2 <- sampleSheet\n    fullCounts2 <- fullCounts[,colnames(fullCounts) %in% sampleSheet2$GenomicsID,drop=FALSE]\n    #print(antibodyToFilter)\n    metadata <- dplyr::select(sampleSheet2,-GenomicsID,-FQLocation,-InputToUse,-toMerge,-BroadCall)\n    group <- gsub(\"_+$\",\"\",apply(metadata,1,paste,sep=\"_\",collapse=\"_\"))\n    #names(files) <- basename(dirname(files))\n    \n    sampleTable <- data.frame(Group = factor(make.names(group)))\n    rownames(sampleTable) <- colnames(fullCounts2)\n    print(fullCounts2[1:2,])\n    print(colnames(fullCounts2) %in% sampleSheet2$GenomicsID)\n    # print(length(colnames(fullCounts) %in% sampleSheet$GenomicsID))\n    if(length(colnames(fullCounts2) %in% sampleSheet2$GenomicsID) > 0 & ncol(fullCounts2) > 2 &\n       length(levels(sampleTable$Group)) > 1 & length(as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))) > 1){\n      print(\"Ohhellow\")\n      dds <- DESeqDataSetFromMatrix(fullCounts2, sampleTable, ~Group)\n      \n      dds <- DESeq(dds,parallel = parallelR)\n      DEGdir2 <- file.path(DEGdir,\"All\")\n      dir.create(DEGdir2,showWarnings = FALSE)\n      save(dds,file=file.path(DEGdir2,\"dds.RData\"))\n      toPlot <- rlog(dds)\n      save(toPlot,file=file.path(DEGdir2,\"rloggedData.RData\"))\n      #plotPCA(toPlot,intgroup=\"Group\")\n      \n      # AllComparisons <- unique(combn(group,2,FUN = function(x)paste(x,collapse=\"_\"),simplify = T))\n      # AllComparisons <- unique(combn(group,2,simplify = T))\n      # AllComparisons <- AllComparisons[,!AllComparisons[1,] == AllComparisons[2,]]\n      # pairWiseComparison <- paste(AllComparisons[1,],AllComparisons[2,],sep=\"Vs\")\n      # AllComparisons <- AllComparisons[,match(unique(pairWiseComparison),pairWiseComparison),drop=F]\n      # pairWiseComparison <- pairWiseComparison[match(unique(pairWiseComparison),pairWiseComparison)]\n      # allComparisonList <- unlist(apply(AllComparisons,2,function(x)list(x)),recursive = F)\n      # names(allComparisonList) <- pairWiseComparison\n      \n      # contrastVector <- resultsNames(dds)\n      # contrastVector <- contrastVector[contrastVector != \"Intercept\"]\n      if(length(as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))) > 1){\n        contrastsFile <- file.path(DEGdir2,\"Contrasts.txt\")\n        if(!file.exists(contrastsFile)){\n          ToExpand <- as.vector(unique(sampleTable$Group[duplicated(colData(dds)$Group)]))\n          kl <- expand.grid(ToExpand,\n                            ToExpand)\n          kl <- kl[kl[,1,drop=FALSE] != kl[,2,drop=FALSE],,drop=FALSE]\n          kl <- t(apply(kl,1,sort))\n          kl <- kl[!duplicated(paste(kl[,1,drop=FALSE],kl[,2,drop=FALSE],sep=\"_\")),,drop=FALSE]\n          write.table(kl,contrastsFile,sep=\"\\t\",quote=FALSE,row.names=FALSE,col.names=FALSE)\n        }else{\n          kl <- read.delim(contrastsFile,sep=\"\\t\",header=FALSE)\n        }\n        #contrastVector <- paste0(\"Group_\",kl[,1],\"_vs_\",kl[,2])\n        contrastVector <- apply(kl,1,function(x)as.list(x))\n        DEseq2Res <- lapply(contrastVector,callnoRepsResultsChIP,ddsObject=dds,DEGdir=DEGdir2,countDir=countDir,parallelR=parallelR)\n        \n        names(DEseq2Res) <- contrastVector\n      }\n    }\n  }\n  return(DEseq2Res)\n}\n\n\n# \n# contrastName <- contrastVector[[1]]\n# ddsObject=fullCounts2\n# metaData=sampleTable\n# DEGdir=DEGdir2\n# countDir=countDir\n# parallelR=FALSE\n# normFactors=NULL\n\ncallnoRepsResultsChIP <- function(contrastName,ddsObject,metaData,DEGdir,countDir,parallelR,normFactors=NULL){\n  dir.create(DEGdir,showWarnings = FALSE,recursive = TRUE)\n  fullCounts2 <- ddsObject\n  if(is.null(normFactors)){\n    normFullCounts <- edgeR::cpm(fullCounts2)\n    normFullCountsLog <- edgeR::cpm(fullCounts2,log=TRUE)\n  }\n  Group1 <- rowMeans(normFullCountsLog[,colnames(normFullCountsLog) %in% rownames(metaData)[metaData$Group == make.names(contrastName[[1]])],drop=FALSE])\n  Group2 <- rowMeans(normFullCountsLog[,colnames(normFullCountsLog) %in% rownames(metaData)[metaData$Group == make.names(contrastName[[2]])],drop=FALSE])\n  Group1noLog <- rowMeans(normFullCounts[,colnames(normFullCounts) %in% rownames(metaData)[metaData$Group == make.names(contrastName[[1]])],drop=FALSE])\n  Group2noLog <- rowMeans(normFullCounts[,colnames(normFullCounts) %in% rownames(metaData)[metaData$Group == make.names(contrastName[[2]])],drop=FALSE])\n  \n  diff <- Group1-Group2\n  basemean <- rowMeans(normFullCounts[,colnames(normFullCounts) %in% rownames(metaData)[metaData$Group %in% unlist(make.names(contrastName[[1]]))],drop=FALSE])\n  sig <- edgeR::binomTest(Group1noLog,Group2noLog)\n  sigAdj <- p.adjust(sig,method = \"BH\")\n  myRes <- data.frame(ID=rownames(fullCounts2),\n                      baseMean=basemean,\n                      log2FoldChange=diff,\n                      lfcSE=NA,stat=NA,\n                      pvalue=sig,\n                      padj=sigAdj)\n  #myRes <- data.frame(Name=rownames(myRes),myRes)\n  myRes <- cbind(myRes,fullCounts2,normFullCounts)\n  #myRes <- myRes[order(myRes$padj,decreasing = F),]\n  #myRes <- data.frame(IDs=rownames(myRes),myRes)\n  #myRes <- merge(myRes,toCombine,by.x=1,by.y=0,all=FALSE)\n  myRes <- myRes[order(myRes$padj,decreasing = F),]\n  ## FIX THIS Need to work for all organisms...\n  # Symbol <- unname(unlist(AnnotationDbi::mget(as.character(myRes$Name),org.Hs.egSYMBOL,ifnotfound=NA)))\n  # myRes <- data.frame(Name=myRes$Name,Symbol=Symbol,myRes[,-1])\n  write.table(myRes,file=file.path(DEGdir,paste0(paste(c(basename(countDir),\"_\",\"Group\",contrastName[[1]],\"minus\",contrastName[[2]]),collapse=\"_\"),\"noRep_DEG.xls\")),row.names = F,quote=F,sep=\"\\t\")\n}\n",
    "created" : 1522429138394.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1829472965",
    "id" : "2F395C6A",
    "lastKnownWriteTime" : 1522435295,
    "last_content_update" : 1522435295,
    "path" : "~/Projects/Software/Github/ngsPipeR/R/pipelineFunctions.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}