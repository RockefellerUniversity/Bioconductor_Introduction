{
    "collab_server" : "",
    "contents" : "require(GenomeInfoDb)\nrequire(GenomicAlignments)\nrequire(Rsamtools)\nrequire(Rsubread)\nrequire(BiocParallel)\nrequire(GenomicFeatures)\nrequire(GenomicRanges)\n\n\n#' Primary processing, QC and analysis of RNA-seq data\n#'\n#' Alignment, gene expression estimation, QC and initial analysis of RNAseq data\n#'\n#'\n#' @docType methods\n#' @name NGSpipeR\n#' @rdname NGSpipeR\n#'\n#' @author Thomas Carroll\n#' @param genome Genome to use\n#' @param sampleSheet A samplesheet of file information and metadata\n#' @param baseDir Where to create output files\n#' @param geneModels A gtf file\n#' @param externalPrograms exe and db file list\n#' @return Nothing returned. Output written to file.\n#' @import Rsamtools\n#' @export\nNGSpipeR <- function(genome,\n                      sampleSheet,\n                      referenceDir=file.path(getwd(),\"ReferenceData\"),\n                      baseDir=getwd(),\n                      geneModels = \"\",id2SymbolFile=\"\",id2GOFile=\"\",\n                      externalPrograms=list(Macs=list(exec=\"macs2\"),\n                                            MemeChIP=list(exec=\"/Users/tcarroll/meme/bin/meme-chip\",\n                                                          db=\"/Users/tcarroll/Downloads/motif_databases/JASPAR/JASPAR_CORE_2014.meme\"),\n                                            Salmon=list(exec=\"DYLD_FALLBACK_LIBRARY_PATH=/Users/tcarroll/Downloads/Salmon-0.8.2_macOX_10.12/lib /Users/tcarroll/Downloads/Salmon-0.8.2_macOX_10.12/bin/salmon\")),\n                      pipeOptions=list(kmerCountOnly=TRUE),\n                     mode=\"RNAseq\",spikeIn=FALSE,extendToFragmentLength=FALSE\n){\n\n  \n  \n  require(GenomeInfoDb)\n  require(GenomicAlignments)\n  require(Rsamtools)\n  require(Rsubread)\n  require(BiocParallel)\n  require(GenomicFeatures)\n  require(GenomicRanges)\n  require(dplyr)\n  require(tidyr)\n\n  macsExecutable <- externalPrograms[[\"Macs\"]][[\"exec\"]]\n  memeChIPExecutable <- externalPrograms[[\"MemeChIP\"]][[\"exec\"]]\n  memeChIPdatabase <- externalPrograms[[\"MemeChIP\"]][[\"db\"]]\n  salmonExecutable <- externalPrograms[[\"Salmon\"]][[\"exec\"]]\n\n  pipeDirectories <- makePipeFileStructure(referenceDir,baseDir,genome)\n\n  motifDir=pipeDirectories[\"motifDir\"]\n  bamsDir=pipeDirectories[\"bamsDir\"]\n  fqsDir=pipeDirectories[\"fqsDir\"]\n  peaksDir=pipeDirectories[\"peaksDir\"]\n  stdoutDir=pipeDirectories[\"stdoutDir\"]\n  stderrDir=pipeDirectories[\"stderrDir\"]\n  referenceDir=pipeDirectories[\"referenceDir\"]\n  chipqcDir=pipeDirectories[\"chipqcDir\"]\n  degDir=pipeDirectories[\"degDir\"]\n  countsDir=pipeDirectories[\"countsDir\"]\n  statsDir=pipeDirectories[\"statsDir\"]\n  bigWigsDir=pipeDirectories[\"bigWigsDir\"]\n\n  rand <- \"part\"\n  referenceFiles <- gatherReferenceFiles(genome,geneModels=geneModels,id2SymbolFile,id2GOFile,\n                                         getReferencesBioC(),referenceDir=referenceDir,mode=mode,\n                                         executables=list(salmonCMD=salmonExecutable),\n                                         spikeIn=spikeIn)\n\n  # sampleSheet <- \"~/Projects/Results/Fuchs/mntSampleSeet_ColRel2_WithNorm.csv\"\n  newAnalysis <- read.delim(sampleSheet,sep=\",\",stringsAsFactors = F)\n  rownames(newAnalysis) <- newAnalysis[,1]\n  if(any(colnames(newAnalysis) == \"toNormalise\")){\n    normH3_Samples <- newAnalysis$toNormalise\n    names(normH3_Samples) <- newAnalysis$GenomicsID\n    newAnalysis <- dplyr::select(newAnalysis,-toNormalise)\n  }else{\n    normH3_Samples <- NULL\n  }\n\n  unsplitFastq <- newAnalysis$FQLocation\n  names(unsplitFastq) <- paste(newAnalysis$GenomicsID,rand,sep=\"_\")\n\n  fastq <- unlist(lapply(unsplitFastq,\n                         function(x)\n                           setdiff(unlist(strsplit(x, \"((?<=:\\\\w)|(?=:\\\\w)|(?=:/\\\\w))\", perl=T)),\":\")),\n                  recursive=T)\n  print(fastq)\n  names(fastq) <- gsub(paste0(\"_\",rand,\"$\"),\"\",names(fastq))\n\n  names(fastq) <- paste(names(fastq),\"pairs\",sep=\"_\")\n  fastq <- unlist(lapply(fastq,\n                         function(x)\n                           strsplit(x,\";\")),\n                  recursive=T)\n  names(fastq) <- gsub(paste0(\"_\",\"pairs\",\"$\"),\"\",names(fastq))\n  print(fastq)\n  uniqueFastqToDownload <- unique(fastq)\n\n  res_Download <- bplapply(unique(uniqueFastqToDownload),fqCopy,fqsDir=fqsDir)\n\n  ###\n  ###\n  samplesToFastq <- gsub(\"_part\\\\d+|_pairs\\\\d+\",\"\",names(fastq))\n  uniqueSamplesToFastq <- unique(samplesToFastq)\n  samplePairs<- gsub(\"_part\\\\d+\",\"\",names(fastq))\n  uniquesamplePairs <- unique(samplePairs)\n  \n  fqsOut <- uniquesamplePairs\n  #fqsOut[grep]\n  fqsOut[!fqsOut  %in% names(fastq)[!grepl(\"part\",names(fastq))]] <- paste0(uniquesamplePairs[!uniquesamplePairs  %in% names(fastq)[!grepl(\"part\",names(fastq))]],\".fq.gz\")\n  fqsOut[fqsOut  %in% names(fastq)[!grepl(\"part\",names(fastq))]] <- as.vector(na.omit(fastq[match(fqsOut,names(fastq)[!grepl(\"part\",names(fastq))])]))\n  # for(i in 1:length(uniqueSamplesToFastq)){\n  #   require(stringr)\n  #   tmpFastq <- fastq[samplesToFastq %in% uniqueSamplesToFastq[i]]\n  #   if(length(tmpFastq) > 1){\n  #   if(any(str_detect(names(tmpFastq),\"_pairs\"))){\n  #     pairNo <- str_match(names(tmpFastq),\"_pairs\\\\d+\")\n  #     pairNoUnique <- unique(pairNo)\n  #   }else{\n  #     pairNo <- \"\"\n  #     pairNoUnique <- unique(pairNo)\n  #   }\n  #   for(l in 1:length(pairNoUnique)){\n  #       tmpFastqToRead <- tmpFastq[pairNo %in% pairNoUnique[l]]\n  #       if(!file.exists(file.path(fqsDir,paste0(uniqueSamplesToFastq[i],pairNoUnique[l],\".fq.gz\")))){\n  #         for(f in 1:length(tmpFastqToRead)){\n  #           library(ShortRead)\n  #           message(file.path(fqsDir,basename(tmpFastqToRead)[f]))\n  #           myfastq <- readFastq(file.path(fqsDir,basename(tmpFastqToRead)[f]))\n  #           if(f == 1){\n  #             writeFastq(myfastq,file = file.path(fqsDir,paste0(uniqueSamplesToFastq[i],pairNoUnique[l],\".fq.gz\")))\n  #           }else{\n  #             writeFastq(myfastq,file = file.path(fqsDir,paste0(uniqueSamplesToFastq[i],pairNoUnique[l],\".fq.gz\")),mode = \"a\")\n  #           }\n  #           message(file.path(fqsDir,paste0(uniqueSamplesToFastq[i],pairNoUnique[l],\".fq.gz\")))\n  #         }\n  #       }\n  #     }\n  #   }\n  # }\n  \n  mergeFQs <- function(x,uniqueSamplesToFastq,samplesToFastq,fastq,fqsDir){\n    require(stringr)\n    tmpFastq <- fastq[samplesToFastq %in% uniqueSamplesToFastq[x]]\n    if(length(tmpFastq) > 1 & str_detect(names(tmpFastq),\"_part\")){\n      if(any(str_detect(names(tmpFastq),\"_pairs\"))){\n        pairNo <- str_match(names(tmpFastq),\"_pairs\\\\d+\")\n        pairNoUnique <- unique(pairNo)\n      }else{\n        pairNo <- \"\"\n        pairNoUnique <- unique(pairNo)\n      }\n      for(l in 1:length(pairNoUnique)){\n        tmpFastqToRead <- tmpFastq[pairNo %in% pairNoUnique[l]]\n        if(!file.exists(file.path(fqsDir,paste0(uniqueSamplesToFastq[x],pairNoUnique[l],\".fq.gz\")))){\n          for(f in 1:length(tmpFastqToRead)){\n            library(ShortRead)\n            message(file.path(fqsDir,basename(tmpFastqToRead)[f]))\n            myfastq <- readFastq(file.path(fqsDir,basename(tmpFastqToRead)[f]))\n            if(f == 1){\n              writeFastq(myfastq,file = file.path(fqsDir,paste0(uniqueSamplesToFastq[x],pairNoUnique[l],\".fq.gz\")))\n            }else{\n              writeFastq(myfastq,file = file.path(fqsDir,paste0(uniqueSamplesToFastq[x],pairNoUnique[l],\".fq.gz\")),mode = \"a\")\n            }\n            message(file.path(fqsDir,paste0(uniqueSamplesToFastq[x],pairNoUnique[l],\".fq.gz\")))\n          }\n        }\n      }\n    }\n  }\n  \n  bplapply(1:length(uniqueSamplesToFastq),mergeFQs,uniqueSamplesToFastq,samplesToFastq,fastq,fqsDir)  \n  fastq2 <- file.path(fqsDir,fqsOut)\n  names(fastq2) <- uniquesamplePairs\n  fastq <- fastq2\n  \n  ###\n  ###  \n  fastqP <- fastq[grepl(\"pairs\",names(fastq))]\n  fastqNP <- fastq[!grepl(\"pairs\",names(fastq))]\n  IDpairs <- gsub(\"_pairs\\\\d+\",\"\",names(fastqP))\n  if(length(fastqP) > 1){\n    uniqueIDpairs <- unique(IDpairs)\n    fastqP <- unlist(lapply(uniqueIDpairs,function(x)paste0(fastqP[IDpairs==x],collapse = \";\")))\n    names(fastqP) <- uniqueIDpairs\n    fastq <- c(fastqP,fastqNP)\n  }else{\n    fastq <- c(fastqNP)\n  }\n\n  #bams <- dir(fqsDir,full.names = T,pattern = \"fastq$|fastq\\\\.gz$|fq$|fq.gz$\")\n  #fastqLocal <- file.path(fqsDir,basename(fastq))\n  fastqLocal <- unlist(lapply(fastq,function(x)paste0(file.path(fqsDir,basename(unlist(strsplit(x,\";\")))),collapse=\";\")))\n\n  names(fastqLocal) <- names(fastq)\n  bamNames <- names(fastqLocal)\n  names(bamNames) <- fastqLocal\n  PE_logical <- grepl(\";\",names(bamNames))\n  names(PE_logical) <- names(fastqLocal)\n\n  salmonIndex <- referenceFiles[[\"salmonIndexFile\"]]\n  #message(salmonIndex)\n  subreadIndex <- referenceFiles[[\"subreadIndex\"]]\n\n  if(mode==\"RNAseq\"){\n  res_KCount <- bplapply(fastqLocal,kmerCountRNAseq,name=bamNames,\n                         index=salmonIndex,countPath=countsDir,nTH=2,salmonCMD=salmonExecutable)\n\n  if(!file.exists(file.path(degDir,\"dds.RData\"))){\n    kmerDESeq2 <- runDESeq2(newAnalysis,referenceFiles[[\"tx2Gene\"]],countsDir,degDir,referenceFiles$id2Symbol,parallelR=FALSE)\n  }\n  if(!file.exists(file.path(degDir,\"dxd.RData\"))){\n     kmerDEXseq <- runDEXSeq(newAnalysis,referenceFiles[[\"tx2Gene\"]],countsDir,degDir,referenceFiles$id2Symbol,parallelR=FALSE)\n  }\n  if(!pipeOptions$kmerCountOnly){\n    res_Align <- bplapply(fastqLocal,alignRNAseq,name=bamNames,\n                          index=subreadIndex,bamPath=bamsDir,nTH=10)\n    names(bamNames) <- file.path(bamsDir,paste0(\"Sorted_\",bamNames,\".bam\"))\n    res_alignmentStats <- bplapply(names(bamNames),alignmentStats,name=bamNames,\n                            statsPath=statsDir)\n    res_flagStats <- bplapply(names(bamNames),simpleAlignmentStats,name=bamNames,\n                              statsDir=statsDir)\n    res_fCounts <- bplapply(names(bamNames),generateFeatureCounts,\n                          name=bamNames,gtf=referenceFiles$actualGtf,disjointGTF=referenceFiles$disjointGTF,countPath=countsDir,\n                          statsPath=statsDir,nTH=1,strand=\"un\",\n                          PE=PE_logical)\n    #save(res_fCounts,file = \"mytestm.RData\")\n    res_bigWigs <- bplapply(names(bamNames),exportNormalisedBW,\n                            name=bamNames,bigWigPath=bigWigsDir)\n    res_CBG <- bplapply(names(bamNames),coverageByTranscriptFromBAM,\n                            name=bamNames,gtfReduced=referenceFiles$disjointGTF)\n  }\n  constrastList <- dir(degDir,pattern=\"*.DEG\\\\.xls$\",full.names = TRUE)\n  print(constrastList)\n  topGOmapping <- referenceFiles$id2TopGO\n  res_topGO <- bplapply(constrastList,callGOfromDEG,\n                           topGOmapping=topGOmapping,DEGdir=degDir)\n\n  fileLocations <- system.file(\"extdata\",package=\"ngsPipeR\")\n\n  #dir.create(file.path(baseDir,\"reportRMDs\"),recursive = TRUE,showWarnings = FALSE)\n  dir.create(file.path(baseDir,\"reportRMDs\",\"DGE_HTMLs\"),recursive = TRUE,showWarnings = FALSE)\n  dir.create(file.path(baseDir,\"reportRMDs\",\"GenomicFiles\"),recursive = TRUE,showWarnings = FALSE)\n  for(k in 1:length(constrastList)){\n    contrastToHTML <- constrastList[k]\n    contrastHTMLName <- gsub(\"DEG\\\\.xls$\",\"\",basename(constrastList[k]))\n    if(!file.exists(file.path(baseDir,\"reportRMDs\",\"DGE_HTMLs\",paste0(contrastHTMLName,\".html\")))){\n      rmarkdown::render(file.path(fileLocations,\"singleDEContrast.Rmd\"),params=list(title=contrastHTMLName,isHTML=TRUE),\n                        output_file = file.path(baseDir,\"reportRMDs\",\"DGE_HTMLs\",paste0(contrastHTMLName,\".html\")))\n      # rmarkdown::render(file.path(fileLocations,\"singleDEContrast.Rmd\"),params=list(title=contrastHTMLName,isHTML=FALSE),\n      #                   output_file = file.path(baseDir,\"reportRMDs\",\"DGE_HTMLs\",paste0(contrastHTMLName,\".pdf\")))\n    }\n  }\n  # rmarkdown::render(file.path(fileLocations,\"AlignmentStatistics.Rmd\"),\n  #                     output_file = file.path(dirname(degDir),paste0(\"AlignmentMetrics.html\")))\n  # rmarkdown::render(file.path(fileLocations,\"DifferentialExpression.Rmd\"),\n  #                   output_file = file.path(dirname(degDir),paste0(\"DifferentialExpression.html\")))\n  # rmarkdown::render(file.path(fileLocations,\"IGV.Rmd\"),\n  #                   output_file = file.path(dirname(degDir),paste0(\"IGV.html\")))\n  #\n  file.copy(file.path(fileLocations,\"reportRMDs\"),baseDir,\n            overwrite = TRUE, recursive = TRUE,\n            copy.mode = TRUE)\n  file.copy(file.path(fileLocations,\"imgs\"),file.path(baseDir,\"reportRMDs\"),\n            overwrite = TRUE, recursive = TRUE,\n            copy.mode = TRUE)\n  # rmarkdown::render(file.path(fileLocations,\"pdfReport.Rmd\"),\n  #                      output_file = file.path(baseDir,\"RNAseq.pdf\"),output_format = \"pdf_document\",\n  #                   params = list(isHTML=\"pdf\",echoCode=FALSE))\n  # rmarkdown::render(file.path(fileLocations,\"wordReport.Rmd\"),\n  #                   output_file = file.path(baseDir,\"RNAseq.docx\"),output_format = \"word_document\",\n  #                   params = list(isHTML=\"word\",echoCode=FALSE))\n  \n  #bigWigsDir <- \"~/Projects/Results/RNAseqPipeTest/FirstTest/bigWigs/\"\n  bigWigsToCopy <- dir(bigWigsDir,pattern=\"*.FullNormalised.*bw$\",full.names = T)\n\n  file.copy(bigWigsToCopy,file.path(baseDir,\"reportRMDs\",\"GenomicFiles\",basename(bigWigsToCopy)),\n            overwrite = TRUE, recursive = FALSE,\n            copy.mode = TRUE)\n\n  rmarkdown::render_site(file.path(baseDir,\"reportRMDs\"))\n  # rmarkdown::render(file.path(fileLocations,\"MakeReport.Rmd\"),\n  #                    output_file = file.path(dirname(degDir),paste0(\"Report.html\")))\n  }\n  if(mode==\"ATACseq\"){\n    print(fastqLocal)\n    res_Align <- bplapply(fastqLocal,alignDNAseq,name=bamNames,\n                          index=subreadIndex,bamPath=bamsDir,nTH=10)\n    names(bamNames) <- file.path(bamsDir,paste0(\"Sorted_\",bamNames,\".bam\"))\n    message(\"All BAMs processed\")\n    res_pbcStats <- bplapply(names(bamNames),getPBCMetrics,\n                             name=bamNames,statsDir=statsDir)\n    MacsPeaks <- callSampleSheetMacs(newAnalysis,bamsDir,peaksDir,macsExecutable,stdoutDir,stderrDir,callSingleSampleMacs)\n    message(\"All Peaks processed\")\n    # simpleAlignmentStats(names(bamNames),bamNames,statsDir)\n    res_ChIPQC <- callSampleSheetChIPQC(newAnalysis,referenceFiles,bamsDir,MacsPeaks,genome,chipqcDir)\n    names(res_ChIPQC) <- newAnalysis$GenomicsID\n    res_bigWigs <- bplapply(names(bamNames),exportNormalisedBW_DNA,\n                            name=bamNames,bigWigPath=bigWigsDir,qcList=res_ChIPQC)\n    res_alnStats <- bplapply(names(bamNames),simpleAlignmentStats,\n                            name=bamNames,statsDir=statsDir)\n    res_pbcStats <- bplapply(names(bamNames),getPBCMetrics,\n                             name=bamNames,statsDir=statsDir)\n    bamNamesPaired <- bamNames[PE_logical]\n    if(length(bamNamesPaired) > 0){\n      \n      res_fragLens <- bplapply(names(bamNamesPaired),getPairedFragmentLength,\n                             name=bamNamesPaired,statsDir=statsDir)\n      \n      bptry(bplapply(names(bamNamesPaired),atacQC,IGVpos=referenceFiles[[\"GenePosForIGV\"]],statsDir=statsDir,chrOfInterest=NULL))\n      \n    }\n    \n        library(GenomicRanges)\n        lengths <- lapply(MacsPeaks,function(x)length(x[[1]]$xls))\n        peaks <- lapply(MacsPeaks[lengths > 0],function(x)ChIPQC:::GetGRanges(x[[1]]$xls))\n        # peaks <- lapply(1:length(MacsPeaks),function(x)ChIPQC:::GetGRanges(MacsPeaks[[x]][[1]]$xls))\n        # peaks <- lapply(1:length(myPeaks),function(x)ChIPQC:::GetGRanges(myPeaks[[x]]))\n        # names(peaks) <- basename(dirname(myPeaks))\n\n        names(peaks) <- names(MacsPeaks[lengths > 0])\n\n    bamFiles <- file.path(bamsDir,paste0(\"Sorted_\",names(peaks),\".bam\"))\n    message(\"ChIPQC created\")\n    peaks <- lapply(1:length(MacsPeaks[lengths > 0]),function(x)ChIPQC:::GetGRanges(MacsPeaks[lengths > 0][[x]][[1]]$summits))\n    names(peaks) <- names(MacsPeaks[lengths > 0])\n    \n    #message(\"Peaks ARE\")\n    #message(lengths(peaks))\n\n    peakQCresults <- file.path(baseDir,\"ChIPQC\",paste0(gsub(\"\\\\.bam\",\"\",basename(bamFiles)),\"PeakQC.RData\"))\n    \n    \n    bamFilesToQC <- bamFiles[!file.exists(peakQCresults)]\n    \n    #print(bamFilesToQC)\n    if(length(bamFilesToQC) > 0){\n      myRes <- ChIPQC::fragmentlength(res_ChIPQC)\n      \n      frags <- myRes[match(gsub(\"Sorted_|\\\\.bam\",\"\",basename(bamFilesToQC)),names(myRes))]  \n      peaks <- peaks[match(gsub(\"Sorted_|\\\\.bam\",\"\",basename(bamFilesToQC)),names(peaks))]\n      \n      QCPeaks <- bplapply(1:length(bamFilesToQC),\n                          ngsPipeR:::runpeakQCs,\n                          bamFiles=bamFilesToQC,\n                          GRangesOfIs=peaks,\n                          fragLens=frags,\n                          aroundPeakDistCalc=3,\n                          aroundPeakDistReadIn=3)\n      \n      \n      # QCPeaks <- bplapply(1:length(bamFilesToQC),\n      #                     function(x)readClusteringInPeaks(bamFilesToQC[x], peaks[[x]],\n      #                                                      frags[x],aroundPeakDistCalc=3,aroundPeakDistReadIn=3))\n      # QCPeaks2 <- UpdateMcolList(QCPeaks)\n      # names(QCPeaks2) <- names(MacsPeaks)\n    }\n    print(\"ellowoow\")\n    \n    print(\"MyGod\")\n\n    \n\n\n\n#\n#     ###\n#     # myPeaks <- dir(\"~/Projects/Results/chipseq/testRun/Peaks/MACS2/\",recursive=TRUE,pattern=\"*.xls\",full.names = TRUE)\n#     # newAnalysis <- read.delim(\"~/Projects/Software/Github/ngsPipeR/inst/extdata/SampleSheet_ChIPseq.csv\",sep=\",\")\n\n    # countsDir <- \"~/Projects/Results/chipseq/testRun/counts\"\n    # statsDir <- \"~/Projects/Results/chipseq/testRun/stats\"\n    # bamNames <- dir(\"~/Projects/Results/chipseq/testRun/BAMs/\",pattern=\"Sorted_.*.bam$\",full.names = TRUE)\n    # bamNames <- bamnames[!grepl(\"_forMACS2\",bamnames)]\n    # names(bamNames) <- bamNames\n\n#\n#\n    \n    \n    \n    \n    # Make consensus dir and TSS/Promoters\n    consensusPeakDirectory <- file.path(baseDir,\"Consensus\")\n\n    if(!dir.exists(consensusPeakDirectory)){\n      dir.create(consensusPeakDirectory,showWarnings = FALSE,recursive = TRUE)\n    }\n\n    library(rtracklayer)\n    library(GenomicRanges)\n\n    IGVpos <- referenceFiles[[\"GenePosForIGV\"]]\n    #ConsensusDir <- \"~/Projects/Results/chipseq/testRun/Consensus/\"\n    IGVGenePositions <- read.delim(IGVpos,sep=\"\\t\")\n    genePos <- makeGRangesFromDataFrame(IGVGenePositions)\n    names(genePos) <- IGVGenePositions$gene_id\n    promoterPos <- promoters(genePos,2000,500)\n    tssPos <- promoters(genePos,500,500)\n    export.bed(promoterPos,con=file.path(consensusPeakDirectory,\"Promoter_Positions.bed\"))\n    export.bed(tssPos,con=file.path(consensusPeakDirectory,\"TSS_Positions.bed\"))\n#\n#\n#\n#\n#\n# # print(\"GotHere\")\n# # save(MacsPeaks,file=\"/rugpfs/fs0/ruit/scratch/tcarroll/Leticia_ATAC/MacsPeaks.RData\")\n# #\n    print(\"MyGod2\")\n    \n    library(GenomicRanges)\n    if(!file.exists(file.path(consensusPeakDirectory,\"peakOverlaps.RData\"))){\n    lengths <- lapply(MacsPeaks,function(x)length(x[[1]]$xls))\n    peaks <- lapply(MacsPeaks[lengths > 0],function(x)ChIPQC:::GetGRanges(x[[1]]$xls,simplify = TRUE))\n#     # peaks <- lapply(1:length(MacsPeaks),function(x)ChIPQC:::GetGRanges(MacsPeaks[[x]][[1]]$xls))\n#     # peaks <- lapply(1:length(myPeaks),function(x)ChIPQC:::GetGRanges(myPeaks[[x]]))\n#     # names(peaks) <- basename(dirname(myPeaks))\n#\n     names(peaks) <- names(MacsPeaks[lengths > 0])\n#\n#     ###\n#\n    central <- reduce(unlist(GRangesList(peaks)))\n\n    Res <- sapply(peaks,function(x) as.integer(central %over% x))\n\n    noPeaks <- data.frame(noPeaks=rowSums(Res))\n    noPeaksTotals <- data.frame(noPeaks=ncol(Res))\n\n    if(any(colnames(newAnalysis) %in% \"Antibody\")){\n      uniqueAntibodies <- unique(newAnalysis$Antibody)\n      metadata <- dplyr::select(newAnalysis,-GenomicsID,-FQLocation,-BroadCall,-toMerge,-InputToUse,-Antibody)\n      group <- gsub(\"_+$\",\"\",apply(metadata,1,paste,sep=\"_\",collapse=\"_\"))\n      group <- paste(newAnalysis$Antibody,group,sep=\"_\")\n      uniqueGroups <- unique(group)\n      \n      peaksPerAntibody <- list()\n      newCols <- sapply(uniqueAntibodies,function(x)rowSums(Res[,colnames(Res) %in% newAnalysis$GenomicsID[newAnalysis$Antibody %in% x],drop=FALSE]))\n      colnames(newCols) <- paste0(\"noPeaks\",\"_Antibody_\",as.vector(uniqueAntibodies))\n      newColTotalss <- sapply(uniqueAntibodies,function(x)sum(colnames(Res) %in% newAnalysis$GenomicsID[newAnalysis$Antibody %in% x]))\n      names(newColTotalss) <- as.vector(uniqueAntibodies)\n      \n      newCols2 <- sapply(uniqueGroups,function(x)rowSums(Res[,colnames(Res) %in% newAnalysis$GenomicsID[group %in% x],drop=FALSE]))\n      colnames(newCols2) <- paste0(\"noPeaks\",\"_Group_\",as.vector(uniqueGroups))\n      newCol2Totalss <- sapply(uniqueGroups,function(x)sum(colnames(Res) %in% newAnalysis$GenomicsID[group %in% x]))\n      \n      noPeaks <- data.frame(noPeaks,newCols,newCols2)\n      mcols(central) <- data.frame(Res,noPeaks)\n      metadata(central) <- list(Total=noPeaksTotals,TotalAntibody=newColTotalss,TotalGroups=newCol2Totalss)\n    }else{\n      mcols(central) <- data.frame(Res,noPeaks)\n      metadata(central) <- list(Total=noPeaksTotals)\n    }\n    save(central,file=file.path(consensusPeakDirectory,\"peakOverlaps.RData\"))\n    }else{\n      load(file.path(consensusPeakDirectory,\"peakOverlaps.RData\"))\n}\n\n\n    peaksToCount <- list()\n\n    if(any(colnames(newAnalysis) %in% \"Antibody\")){\n      antiBodyGroups <- metadata(central)$TotalAntibody\n      antiBodyGroups <- antiBodyGroups[antiBodyGroups !=0]\n      antiBodyGroupsPeaks <- list()\n      for(l in 1:length(antiBodyGroups)){\n        antiBodyGroupsPeaks[[l]] <- central[as.vector(mcols(central)[grep(paste0(\"noPeaks_Antibody_\",make.names(names(antiBodyGroups[l])),\"$\"),colnames(mcols(central)))][,1]) >= antiBodyGroups[l]/2]\n      }\n      names(antiBodyGroupsPeaks) <- paste0(\"Antibody_\",names(antiBodyGroups))\n      peaksToCount <- c(peaksToCount,antiBodyGroupsPeaks)\n    }else{\n      toCountTotal <- list(central[central$noPeaks >= as.numeric(metadata(central)$Total)/2,])\n      names(toCountTotal) <- paste0(\"Antibody_\",\"All\")\n      peaksToCount <- c(peaksToCount,toCountTotal)\n    }\n\n    for(i in 1:length(peaksToCount)){\n      outTable <- file.path(consensusPeakDirectory,paste0(names(peaksToCount)[i],\"_Consensus_Table.csv\"))\n      outBed <- file.path(consensusPeakDirectory,paste0(names(peaksToCount)[i],\"_Consensus.bed\"))\n      write.table(as.data.frame(peaksToCount[[i]]),outTable,sep=\"\\t\",quote=FALSE,row.names=FALSE)\n      rtracklayer:::export.bed(peaksToCount[[i]],con=outBed)\n    }\n\n    consensusPeakFiles <- dir(consensusPeakDirectory,pattern=\"*.bed\",full.names=TRUE)\n    peakFiles <- lapply(consensusPeakFiles,import.bed)\n    names(peakFiles) <- gsub(\"\\\\.bed\",\"\",basename(consensusPeakFiles))\n    \n    #toCountFeatureS <- lapply(peakFiles,function(x)data.frame(GeneID=paste(\"ID\",seqnames(x),start(x),end(x),sep=\"_\"),Chr=seqnames(x),Start=start(x),End=end(x),Strand=strand(x)))\n    toCountFeatureS <- vector(\"list\",length(peakFiles))\n    for(i in 1:length(peakFiles)){\n      if(all(!is.na(peakFiles[[i]]$name))){\n        toCountFeatureS[[i]] <- data.frame(GeneID=paste(peakFiles[[i]]$name,seqnames(peakFiles[[i]]),\n                                                        start(peakFiles[[i]]),end(peakFiles[[i]]),sep=\":\"),\n                                           Chr=seqnames(peakFiles[[i]]),\n                                           Start=start(peakFiles[[i]]),\n                                           End=end(peakFiles[[i]]),\n                                           Strand=strand(peakFiles[[i]])\n        )        \n      }else{\n        toCountFeatureS[[i]] <- data.frame(GeneID=paste(\"ID\",seqnames(peakFiles[[i]]),start(peakFiles[[i]]),end(peakFiles[[i]]),sep=\":\"),\n                                   Chr=seqnames(peakFiles[[i]]),\n                                   Start=start(peakFiles[[i]]),\n                                   End=end(peakFiles[[i]]),\n                                   Strand=strand(peakFiles[[i]])\n                                 )\n      }\n    }\n    \n    names(toCountFeatureS) <- names(peakFiles)\n\n    toCountFeatureS_long <- rep(toCountFeatureS,each=length(bamNames))\n    bamNames_long <- rep(bamNames,length(toCountFeatureS))\n    #print(bamNames_long)\n    if(extendToFragmentLength==FALSE){\n      res_fCounts <- bplapply(1:length(bamNames_long),generateFeatureCountsPeaks,\n                            name=bamNames_long,PeakSet=toCountFeatureS_long,countPath=countsDir,\n                            statsPath=statsDir,nTH=1,strand=\"un\")\n    }else{\n      fragLens <- rep(ChIPQC:::fragmentlength(res_ChIPQC),length(toCountFeatureS))\n      write.table(cbind(bamNames_long,fragLens),file=file.path(baseDir,\"test.txt\"),sep=\",\",row.names = FALSE)\n      res_fCounts <- bplapply(1:length(bamNames_long),generateFeatureCountsPeaks,\n                              name=bamNames_long,PeakSet=toCountFeatureS_long,countPath=countsDir,\n                              statsPath=statsDir,nTH=1,strand=\"un\",readExtension5=fragLens,read2pos=5)\n    }\n\n    # res_ChIPQC\n    # countsDir <- \"/rugpfs/fs0/ruit/scratch/tcarroll/chipSeq/testRunBroad/counts\"\n    # degDir <- \"/rugpfs/fs0/ruit/scratch/tcarroll/chipSeq/testRunBroad/DE_Genes\"\n    # newAnalysis <- read.delim(\"/rugpfs/fs0/ruit/scratch/tcarroll/SampleSheet_BroadChIPseq.csv\",sep=\",\")\n    consensusPeakCountDirs <- dir(countsDir,include.dirs = TRUE,full.names = TRUE)\n    consensusPeakCountDirs <- consensusPeakCountDirs[dir.exists(consensusPeakCountDirs)]\n\n    # xw <- lapply(1:length(consensusPeakCountDirs),runNoRepChIP,sampleSheet=newAnalysis,\n    #        countDir=file.path(countsDir,basename(consensusPeakCountDirs)),\n    #        DEGdir=file.path(degDir,basename(consensusPeakCountDirs)),\n    #        callnoRepsResultsChIP,\n    #        parallelR=FALSE)\n    # \n    # for(i in 1:length(consensusPeakCountDirs)){\n    #   if(!file.exists(file.path(degDir,basename(consensusPeakCountDirs[i]),\"dds.RData\"))){\n    #     dir.create(file.path(degDir,basename(consensusPeakCountDirs[i])),showWarnings = FALSE)\n    #     kmerDESeq2 <- runDESeq2ChIP2(newAnalysis,file.path(countsDir,basename(consensusPeakCountDirs[i])),file.path(degDir,basename(consensusPeakCountDirs[i])),parallelR=FALSE)\n    #   }\n    # }\n    kmerDESeq2 <- bptry(bplapply(1:length(consensusPeakCountDirs),runDESeq2ChIP3,sampleSheet=newAnalysis,\n                                 countDir=file.path(countsDir,basename(consensusPeakCountDirs)),\n                                 DEGdir=file.path(degDir,basename(consensusPeakCountDirs)),\n                                 callDESeq2ResultsChIP,\n                                 parallelR=FALSE))\n    kmerNoReps2 <- bptry(bplapply(1:length(consensusPeakCountDirs),runNoRepChIP,sampleSheet=newAnalysis,\n                                 countDir=file.path(countsDir,basename(consensusPeakCountDirs)),\n                                 DEGdir=file.path(degDir,basename(consensusPeakCountDirs)),\n                                 callnoRepsResultsChIP,\n                                 parallelR=FALSE))\n    #        kmerDESeq2 <- runDESeq2ChIP2(newAnalysis,file.path(countsDir,basename(consensusPeakCountDirs[2])),file.path(degDir,basename(consensusPeakCountDirs[2])),parallelR=FALSE)\n    \n    \n    # res_Meme <- callSampleSheetMeme(newAnalysis,MacsPeaks[lengths > 0],referenceFiles,motifDir,\n    #                                 memeChIPExecutable,memeChIPdatabase,\n    #                                 stdoutDir,stderrDir,ntop=1000)\n    \n    message(\"Motif analysis done!\")\n    \n    ###\n    \n    fileLocations <- system.file(\"extdata\",package=\"ngsPipeR\")\n    #dir.create(file.path(baseDir,\"reportRMDs\"),recursive = TRUE,showWarnings = FALSE)\n    dir.create(file.path(baseDir,\"reportRMDsChIPseq\",\"DGE_HTMLs\"),recursive = TRUE,showWarnings = FALSE)\n    dir.create(file.path(baseDir,\"reportRMDsChIPseq\",\"GenomicFiles\"),recursive = TRUE,showWarnings = FALSE)\n    constrastList <- dir(file.path(degDir),pattern=\"*.DEG\\\\.xls\",full.names=TRUE,recursive = TRUE)\n    \n    \n    #print(contrastList)\n    #print(length(contrastList))\n    \n     for(k in seq_along(constrastList)){\n      contrastToHTML <- constrastList[k]\n      contrastHTMLName <- gsub(\"DEG\\\\.xls$\",\"\",basename(constrastList[k]))\n      if(!file.exists(file.path(baseDir,\"reportRMDsChIPseq\",\"DGE_HTMLs\",paste0(contrastHTMLName,\".html\")))){\n      rmarkdown::render(file.path(fileLocations,\"singleDBContrast.Rmd\"),params=list(title=contrastHTMLName,isHTML=TRUE),\n                        output_file = file.path(baseDir,\"reportRMDsChIPseq\",\"DGE_HTMLs\",paste0(contrastHTMLName,\".html\")))\n      }\n      # rmarkdown::render(file.path(fileLocations,\"singleDEContrast.Rmd\"),params=list(title=contrastHTMLName,isHTML=FALSE),\n      #                   output_file = file.path(baseDir,\"reportRMDsChIPseq\",\"DGE_HTMLs\",paste0(contrastHTMLName,\".pdf\")))\n\n    }\n    # rmarkdown::render(file.path(fileLocations,\"AlignmentStatistics.Rmd\"),\n    #                     output_file = file.path(dirname(degDir),paste0(\"AlignmentMetrics.html\")))\n    # rmarkdown::render(file.path(fileLocations,\"DifferentialExpression.Rmd\"),\n    #                   output_file = file.path(dirname(degDir),paste0(\"DifferentialExpression.html\")))\n    # rmarkdown::render(file.path(fileLocations,\"IGV.Rmd\"),\n    #                   output_file = file.path(dirname(degDir),paste0(\"IGV.html\")))\n    #\n    file.copy(file.path(fileLocations,\"reportRMDsChIPseq\"),baseDir,\n              overwrite = TRUE, recursive = TRUE,\n              copy.mode = TRUE)\n    file.copy(file.path(fileLocations,\"imgs\"),file.path(baseDir,\"reportRMDsChIPseq\"),\n              overwrite = TRUE, recursive = TRUE,\n              copy.mode = TRUE)\n    # rmarkdown::render(file.path(fileLocations,\"pdfReport.Rmd\"),\n    #                      output_file = file.path(baseDir,\"RNAseq.pdf\"),output_format = \"pdf_document\",\n    #                   params = list(isHTML=\"pdf\",echoCode=FALSE))\n    # rmarkdown::render(file.path(fileLocations,\"wordReport.Rmd\"),\n    #                   output_file = file.path(baseDir,\"RNAseq.docx\"),output_format = \"word_document\",\n    #                   params = list(isHTML=\"word\",echoCode=FALSE))\n    \n    #bigWigsDir <- \"~/Projects/Results/RNAseqPipeTest/FirstTest/bigWigs/\"\n    bigWigsToCopy <- dir(bigWigsDir,pattern=\".*bw$\",full.names = T)\n    peaksToCopy <- dir(file.path(baseDir,\"Peaks\"),pattern=\".*narrowPeak$\",full.names = T,recursive=TRUE)\n    \n    file.copy(c(bigWigsToCopy,peaksToCopy),file.path(baseDir,\"reportRMDsChIPseq\",\"GenomicFiles\",basename(c(bigWigsToCopy,peaksToCopy))),\n              overwrite = TRUE, recursive = FALSE,\n              copy.mode = TRUE)\n    \n#    motifsToCopy <- dir(file.path(baseDir,\"Motif\"),full.names = T,recursive=TRUE)\n    dir.create(file.path(baseDir,\"reportRMDsChIPseq\",\"Motif\"),showWarnings = F,recursive = TRUE)\n    file.copy(file.path(baseDir,\"Motif\",\"MEME\"),file.path(baseDir,\"reportRMDsChIPseq\",\"Motif\"),\n              overwrite = TRUE, recursive = TRUE,\n              copy.mode = TRUE)\n    \n    rmarkdown::render_site(file.path(baseDir,\"reportRMDsChIPseq\"))\n\n  }\n\n  \n  my_session_info <- devtools::session_info()\n  writeLines(text = {\n    paste(sep = \"\\n\", collapse = \"\",\n          paste0(rep(\"-\", 80), collapse = \"\"),\n          paste(paste0(rep(\"-\", 32), collapse = \"\"),\n                \"R environment\",\n                paste0(rep(\"-\", 33), collapse = \"\")),\n          paste0(rep(\"-\", 80), collapse = \"\"),\n          paste(knitr::kable(data.frame(setting = names(my_session_info$platform),\n                                        value = as.character(my_session_info$platform))), collapse = \"\\n\"),\n          paste0(rep(\"-\", 80), collapse = \"\"),\n          paste(paste0(rep(\"-\", 35), collapse = \"\"),\n                \"packages\",\n                paste0(rep(\"-\", 35), collapse = \"\")),\n          paste0(rep(\"-\", 80), collapse = \"\"),\n          paste(knitr::kable(my_session_info$packages), collapse = \"\\n\")\n    )\n  }, con = file.path(baseDir,paste0(\"session_info\",gsub(\" |:\",\"_\",gsub(\"#|-\",\"\",timestamp(quiet = TRUE))),\".txt\")))\n  \n}\n\n",
    "created" : 1522429115359.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1183083327",
    "id" : "1B273F4F",
    "lastKnownWriteTime" : 1522350033,
    "last_content_update" : 1522350033,
    "path" : "~/Projects/Software/Github/ngsPipeR/R/NGSpipeR.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}